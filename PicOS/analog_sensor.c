/* ==================================================================== */
/* Copyright (C) Olsonet Communications, 2002 - 2008                    */
/* All rights reserved.                                                 */
/* ==================================================================== */
#include "kernel.h"
#include "analog_sensor.h"
#include "pins.h"

//
// Driver for a generic analog sensor
//

#define	ASNS_ISI	((word)(params->tp))	// Inter-sample interval
#define	ASNS_NSA	(params->nsamples)	// Number of samples to average

static	lword praa_avg;
static	int praa_count = 0;

#ifndef	sensor_adc_prelude
#define	sensor_adc_prelude(p)	CNOP
#endif

#ifndef	sensor_adc_postlude
#define	sensor_adc_postlude(p)	CNOP
#endif

// Note: the state is now mandatory
void analog_sensor_read (word state, const a_sensdesc_t *params, address val) {

	if (praa_count <= 0) {
		// Starting up
		if (adc_inuse) {
			delay (2, state);
			release;
		}

		// Set the ADC
		sensor_adc_config (params->adcpars);
		// Any prerequisites, e.g., setting the external reference; this
		// happens after adc_config, as the reference may depend on the
		// internal reference generated by the ADC, so, e.g., we can add
		// proper delays
		sensor_adc_prelude (params->adcpars);
		praa_count = ASNS_NSA * 2;
		praa_avg = 0;
Next:
		adc_start;
		if (state != NONE) {
Wait:
			delay (1, state);
			release;
		}
		udelay (10);
	}

	if ((praa_count & 1)) {
		// Return from delay -> start the ADC
		praa_count --;
		goto Next;
	}

	adc_stop;
	// Wait for the end of sampling
	if (adc_busy)
		goto Wait;

	adc_off;
	praa_avg += adc_value;

	if (praa_count > 2) {
		// Must keep going
		praa_count--;
		delay (ASNS_ISI, state);
		release;
	}

	sensor_adc_postlude (params->adcpars);
	adc_disable;
	praa_count = 0;
	*val = (word)(praa_avg / ASNS_NSA);
}
