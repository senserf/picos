#ifndef __types_h__
#define	__types_h__

#include "rfmod_dcf.h"

// HELLO packet types. Note that in SMURPH negative types are used for special
// packets, i.e., ones that are not generated by the traffic generator, but
// internally by the protocol. There are two packet types: HELLO and DATA. The
// type of DATA packets is zero, but more types (and a more elaborated traffic
// generator) can be immediatelly accommodated, as we never assume that type 0
// is all there is.
#define	PKT_TYPE_HELLO		(-1)

// HELLO packet: need the address of original sender, but no recipient address.
// On top of that, we have 8 bytes for the two coordinates + 2 bytes for a
// serial number + 2 bytes for TTL. Note that we use PKT_LENGTH_RTS as a
// reference (i.e., minimum packet length).
#define	PKT_LENGTH_HELLO	(PKT_LENGTH_RTS + (2 + 2 + 4 + 4) * 8)

// A DATA packet has two more addresses (original sender + target recipient) +
// TTL + some serial number (or whatever). Lots of framing, isn't it?
#define	PKT_LENGTH_DATA		(PKT_LENGTH_RTS + (6 + 6 + 2 + 2) * 8)

#define	PKT_TTL_DATA		18	// Initial TTL settings for data packets
#define	PKT_TTL_HELLO		10	// ... and for HELLO

// Tracing options: switch them on (set to 1) to see various traces in the
// output file.
#define	TRACE_PACKETS		0
#define	TRACE_ROUTES		0

// Number of re-forwarding tries on RFM drop
#define	MAX_ROUTE_TRIES		3

// A small distance used as EPSILON
#define	TINY_DISTANCE		0.01	// This is 1 cm

// Reliability parameters
#define	RELIABILITY_MIN		0.0
#define	RELIABILITY_MAX		1.0
#define	RELIABILITY_INC		0.1	// Increment on HELLO
#define	RELIABILITY_THS		0.7
#define	RELIABILITY_STP		0.2
#define	RELIABILITY_ACC		0.1

packet WDPacket : DCFPacket {

	// This is the common component of all our packet types. Note that
	// all packets have some standard attributes (which are not mentioned
	// here). For example Sender is the transport sender of the packet.

	Long	SN;		// Serial number for
	unsigned short TTL;	// Time to live
	unsigned short Retries;	// Routing retries
};

packet HelloPacket : WDPacket {

	// These packets are sent periodically by nodes to announce their
	// coordinates. They essentially flood the network. The standard
	// Sender attribute determines the originator.

	double	X, Y;

	void setup ();
};

packet DataPacket : WDPacket {

	// Data packet: nothing special here. The standard Receiver attribute
	// determines the final destination.

	void setup (Message*);

};

class MY_RFModule : public RFModule {

	public:

	void rcv_data (DCFPacket*, double);
	void suc_data (DCFPacket*, Long);
	void fai_data (DCFPacket*);
	void col_data ();

	MY_RFModule (Transceiver *t, Long pqs, Long nret) : RFModule (t, pqs, nret) { };

};

struct RTE_s {

	// Routing table entry: describes the location of one prospective
	// destination

	struct RTE_s *prev, *next;	// Needed by the pooling operations

	TIME TStamp;			// Time stamp (when last set or updated)
	Long A;				// Node address
	double X, Y;			// Coordinates
};

typedef	struct RTE_s RTE_i;

class RTable {

	// The routing table, i.e., the list of destinations we know about

	RTE_i *Head;

	public:

	// Look up a node and get its coordinates
	Boolean getCoords (Long, double&, double&);

	// Add/update destination info
	void update (Long, double, double);

	RTable () {
		// Starts as empty
		Head = NULL;
	};
};

struct NTE_s {

	// Neighbor table entry: describes the parameters of one neighbor

	struct NTE_s *prev, *next;	// Needed by the pooling operations

	TIME TStamp;			// Time stamp (when last set or updated)
	Long A;				// Node address
	double X, Y;			// Coordinates
	double RSSI;			// Signal strength (neighbors only)
	double Reliability;
};

typedef	struct NTE_s NTE_i;

class NTable {

	// The neighbor table - describing the population of currently known
	// neighbors

	NTE_i *Head;

	public:

	// Add/update neighbor info
	void update (Long, double, double, double rssi);

	// Find the best neighbor to which the packet should be forwarded
	Long route (Long, double, double, double);

	// Mark neighbor as unreliable
	void unreliable (Long);

	// Delete obsolte entries
	void deleteOld (TIME);

	NTable () {
		// Starts as empty
		Head = NULL;
	};
};

inline double ema (double ol, double ne, double alpha) {
// Exponential moving average
	return (ne * alpha + ol * (1.0 - alpha));
};

struct PCache_s {

	// A packet cache item. This is what we store (for a limited time) for
	// every received (and possibly forwarded) packet: Sender (the
	// originator) address, and the serial number.

	struct PCache_s *prev, *next;

	Long Sender,			// The sender
	     SN;			// Serial number
};

typedef struct PCache_s PCache_i;

class PCache {

	// Here is the actual cache

	PCache_i *Head;
	PCache_i *Tail;			// Needed to implement FIFO policy

	Long MaxSize;

	public:

	Boolean add (WDPacket*);

	PCache (Long m) {
		Head = Tail = NULL;
		MaxSize = m;
	};
};

station Node {

	DataPacket Buffer;	// For outgoing session packets
	Transceiver *RFI;	// The RF interface

	MY_RFModule *RFM;

	NTable	*Neighbors;	// The neighbor pool

	RTable 	*NetMap;	// Node coordinate database

	PCache 	*PC;		// Packet cache for duplicate rejection

	Long	Serial;		// Serial number for outgoing packets

	void receive (WDPacket*, double);
	void sent (WDPacket*, Long);
	void dropped (WDPacket*);
	void dispatch ();

	void setup (RATE, Long);
};

process HelloSender (Node) {

	// See node.cc for the code method

	double MinInt, MaxInt;

	states { Delay, SendIt };

	TIME interval () {

		return etuToItu (dRndUniform (MinInt, MaxInt));
	};

	void setup (double mi, double ma) {
		MinInt = mi;
		MaxInt = ma;
	};

	perform;
};

process NeighborCleaner (Node) {

	// See node.cc for the code method

	TIME Interval, ExpirationTime;

	states { Delay, CleanIt };

	void setup (double hi, double ex) {

		Interval = etuToItu (hi);
		ExpirationTime = etuToItu (ex);
	};

	perform;
};

process DataSender (Node) {

	// See node.cc for the code method

	states { WMess } ;

	perform;
};

process PositionReporter {

	// See node.cc for the code method

	states { Report } ;

	perform;
};

void initNodes (Long);
void initMobility ();
Long initChannel ();

inline double dist (double x0, double y0, double x1, double y1) {
	return sqrt ((y1 - y0) * (y1 - y0) + (x1 - x0) * (x1 - x0));
}

#endif
