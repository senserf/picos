#ifndef __types_h__
#define	__types_h__

#include "rfmod_dcf.h"

// HELLO packet types. Note that in SMURPH negative types are used for special
// packets, i.e., ones that are not generated by the traffic generator, but
// internally by the protocol. There are two packet types: HELLO and DATA. The
// type of DATA packets is zero, but more types (and a more elaborated traffic
// generator) can be immediatelly accommodated, as we never assume that type 0
// is all there is.
#define	PKT_TYPE_HELLO		(-1)

// HELLO packet: need the address of original sender, but no recipient address.
// On top of that, we have 8 bytes for the two coordinates + 2 bytes for a
// serial number + 2 bytes for TTL. Note that we use PKT_LENGTH_RTS as a
// reference (i.e., minimum packet length).
#define	PKT_LENGTH_HELLO	(PKT_LENGTH_RTS + (2 + 2 + 4 + 4) * 8)

// A DATA packet has two more addresses (original sender + target recipient) +
// TTL + some serial number (or whatever). Lots of framing, isn't it?
#define	PKT_LENGTH_DATA		(PKT_LENGTH_RTS + (6 + 6 + 2 + 2) * 8)

#define	PKT_TTL_DATA		18	// Initial TTL settings for data packets
#define	PKT_TTL_HELLO		10	// ... and for HELLO

// Tracing options: switch them on (set to 1) to see various traces in the
// output file.
#define	TRACE_PACKETS		1
#define	TRACE_ROUTES		0
#define	TRACE_RTABLES		0

packet WDPacket : DCFPacket {

	// This is the common component of all our packet types. Note that
	// all packets have some standard attributes (which are not mentioned
	// here). For example Sender is the transport sender of the packet.

	Long	SN;	// Serial number for
	int	TTL;	// Time to live
};

packet HelloPacket : WDPacket {

	// These packets are sent periodically by nodes to announce their
	// coordinates. They essentially flood the network. The standard
	// Sender attribute determines the originator.

	double	X, Y;

	void setup ();
};

packet DataPacket : WDPacket {

	// Data packet: nothing special here. The standard Receiver attribute
	// determines the final destination.

	void setup (Message*);

};

struct RTE_s {

	// Routing table entry: describes the wherebouts of a single node

	struct RTE_s *prev, *next;	// Needed by the pooling operations

	TIME TStamp;			// Time stamp (when last set or updated)
	Long A;				// Node address
	double X, Y;			// Coordinates
};

typedef	struct RTE_s RTE_i;

class RTable {

	// The oouting table. This may be too grandiose a word for the present
	// version, but I am sure you will turn this into something more
	// impresive.

	RTE_i *Head;

	public:

	// Look up a node and get its coordinates
	Boolean getCoords (Long, double&, double&);

	// Add/update node coordinates
	void update (Long, double, double);

	// Find the best neighbor towards which the packet should be sent
	Long route (Long, double, double, double);

	// Delete obsolte entries. Only used for the Neighbors pool.
	void deleteOld (TIME);

#if TRACE_RTABLES

	void dump (const char *a) {
		RTE_i *pe;
		trace ("RTable %s at %1d", a, TheStation->getId ());
		for_pool (pe, Head)
			trace ("  %1d %f %f [TS = %f]", pe->A, pe->X, pe->Y,
				ituToEtu (pe->TStamp));
	};
#endif

	RTable () {
		// Starts as empty
		Head = NULL;
	};
};

struct PCache_s {

	// A packet cache item. This is what we store (for a limited time) for
	// every received (and possibly forwarded) packet: Sender (the
	// originator) address, and the serial number.

	struct PCache_s *prev, *next;

	Long Sender,			// The sender
	     SN;			// Serial number
};

typedef struct PCache_s PCache_i;

class PCache {

	// Here is the actual cache

	PCache_i *Head;
	PCache_i *Tail;			// Needed to implement FIFO policy

	Long MaxSize;

	public:

	Boolean add (WDPacket*);

	PCache (Long m) {
		Head = Tail = NULL;
		MaxSize = m;
	};
};

station Node {

	DataPacket Buffer;	// For outgoing session packets
	Transceiver *RFI;	// The RF interface

	RFModule *RFM;

	RTable	*Neighbors,	// The neighbor pool
		*NetMap;	// Node coordinate database

	PCache 	*PC;		// Packet cache for duplicate rejection

	Long	Serial;		// Serial number for outgoing packets

	void receive (WDPacket*, double);
	void sent (WDPacket*, Long);
	void dropped (WDPacket*);
	void dispatch ();

	void setup (RATE, Long);
};

process HelloSender (Node) {

	// See node.cc for the code method

	double MinInt, MaxInt;

	states { Delay, SendIt };

	TIME interval () {

		return etuToItu (dRndUniform (MinInt, MaxInt));
	};

	void setup (double mi, double ma) {
		MinInt = mi;
		MaxInt = ma;
	};

	perform;
};

process NeighborCleaner (Node) {

	// See node.cc for the code method

	TIME Interval, ExpirationTime;

	states { Delay, CleanIt };

	void setup (double hi, double ex) {

		Interval = etuToItu (hi);
		ExpirationTime = etuToItu (ex);
	};

	perform;
};

process DataSender (Node) {

	// See node.cc for the code method

	states { WMess } ;

	perform;
};

process PositionReporter {

	// See node.cc for the code method

	states { Report } ;

	perform;
};

void initNodes (Long);
void initMobility ();
Long initChannel ();

inline double dist (double x0, double y0, double x1, double y1) {
	return sqrt ((y1 - y0) * (y1 - y0) + (x1 - x0) * (x1 - x0));
}

#endif
