PG100628A:

	First for some git-related cleanups:

	1. I propose to use separate RTAG files for the different developers
	   (all two of them ;-). This is RTAGS_PG. I am leaving the original
	   RTAGS file as it was (for the record). I have also created a new
	   file named Version holding the system version to be used by mkmk.

	2. I have modified mkmk (see above), so grab the new version and copy
	   it to your bin. The script fetches the system version from Version
	   and then scans all RTAGS_... selecting the most recent release tag.
	   Tags are expected to contain six digits (according to our tacit
	   standard, e.g., 100628), but may also contain arbitrary other
	   characters, e.g., WO100629A:

	3. We should be using commit messages for meaningful comments. Also, we
	   shouldn't shy away from many small commits (not all of them being
	   necessarily tagged our way), equatting pushes (which should be
	   tagged - the last commit before a push) with previous CVS commits.
	   Note that present commits are lighter weight than old CVS commits.

	=======================================================================

	The four values returned by PHYSOPT_ERROR for CC1100 redefined. Here is
	the description from phys_cc1100.cc

	0 - receptions (all events when receiver is awakened to check for a
	    pkt)

	1 - successfully received packets; note that with hardware CRC +
	    AUTOFLUSH, 0 and 1 will be equal

	2 - LBT/congestion indicator: EMA d(n) = 0.75 * d(n-1) + 0.25 * b,
	    where b is the backoff experienced when trying to access the
	    channel for TX; this is counted over all attempts to access the
	    channel and maxed at 0x0fff, i.e., 4095

	3 - the maximum accumulated backoff time suffered by a single packet so
	    far

	Also read doc.odt from Apps/VUEE/RFTEST.

	The RFTEST Praxis, which I wrote for Gerry a few weeks ago, has been
	brought to a PiComp-compatible form.

	Simplified utimer_set in kernel.c (insignificantly). I have been 
	searching there for weird reasons why a transmit queue might get
	stuck on LBT. One of them would be a stuck utimer, but it doesn't
	seem plausible at all.

	I have done some tests with RFTEST. It seems that setting XMIT queue
	size limit in TCV, say #define TCV_LIMIT_XMT 8 (in options.sys) may be
	a good idea. I did see a few memory problems under the outgoing packet
	rate of 4 pkts/sec (nodes becoming unresponsive to UART because of
	choked up malloc) which diappeared after I introduced the limit. It
	appears that the reception queue size is not a problem.

PG100629A:

	Fixed file permissions. Cygwin creates a lot of mess with file
	permissions (which get screwed up when copying, archiving, untarring,
	etc.). Unfortunately (or rather fortunately, but not in this case),
	when you change the permissions of a file, git recognizes the file as
	modified, which occasionally becomes annoyoing.

	The upshot:

	There is script in Scripts, named permissions, which has been there
	for a while (and I have been using it every now and then). I recommend
	to run it:

		cd PICOS
		Scripts/permissions

	whenever you suspect that file permissions may have been messed up
	(git status shows modified files that haven't really been modified).
	It runs through the tree and sets the right permissions of files (which
	are mostly guessed, but mostly correctly and, most importantly,
	deterministically). In particular, you should do it before checking the
	status, adding, and/or committing.

PG100630A:

	Converted Apps/VUEE/survey to PiComp. Perhaps "converted" is not a good
	word, as the job consists in undoing the previous VUEE hooks. Along the
	way, detected (and fixed) one problem with PiComp: when tokenizing
	initializers, PiComp would split constructs like << into < < (i.e.,
	introducing a space between the two characters).

	Also, PiComp now parses crunning. The case of crunning (NULL) was
	impossible to handle in a macro (so it didn't work under VUEE), as the
	(non-NULL) argument od crunning had to be converted to a SIDE process
	type ID, i.e.,

	#define	_pt_id_(pt)	(&zz_!!THREADNAME(pt)!!_prcs)
	#define	crunning(pt)	zz_crunning (_pt_id_ (pt))

	So when you said crunning (NULL), the macro would produce nonsense. To
	do it right, I would have to remove the macro (crunning) and parse
	crunning in PiComp into zz_crunning recognizing the special case of a
	NULL (generally non-symbol) argument. That, however, would cause
	problems for the old VUEE-compliant praxes (which are not handled by
	PiComp and must rely on the macro).

	As the macro is expanded before PiComp sees the code, I handle two
	cases:

	crunning -> zz_crunning (not used now, waiting for the macro to
	disappear)

	zz_crunning -> zz_crunning (fixing the problem introduced by the macro
	for a non-symbol argument)

	Note that this requires a modification in VUEE. Please use VUEE with
	the same (or higher) release tag, if you want to have crunning working
	correctly with the PiComp-compatible praxes.

PG100705A:	VUEE >= PG100705A, SIDE >= PG100705A

	Introducing type lint (along the line of sint) intended to be PicOS's
	replacement for long. While it is not absolutely required to use this
	type (instead of long) in praxes, it is recommended in order to avoid
	problems with VUEE, especially on 64-bit machines. This required a
	modification in VUEE (PG100705A), which was directly inspired by the
	recent problem signaled by Nick (and his fix). That in turn required
	a (very slight) modification to SIDE. So you should get them all.

	I am not sure if I have fixed Nick's second problem. Nick, please let
	me know.

	I have gone through the source, including most praxes, replacing
	long with lint. Note that the problem of eliminating int and
	replacing it with sint everywhere is a bit more complicated. One reason
	why you have to be careful there is that PicOS (and consequently VUEE)
	uses int for some handles, notably PIDs, which are in fact addresses
	(using type word to store event numbers is another messy feature).
	This may change in the future. Probably, we should have two more types
	(or maybe just one) to take care of process and event handles. This
	cannot be done quickly as a lot in VUEE depends on the assumption that
	PID is an int derived from an address. Note that any problems caused by
	this "overloading" of types will be amplified on 64-bit systems.

	A minor cleanup in kernel.c (code for killing processes improved a
	bit).

	A few fixes to PiComp. Line count (for error diagnostics) would go off
	after an #if(def) or #else, for one thing. For another, PiComp now
	(when compiling for VUEE) recognizes and compiles out heapmem (it
	could not be eliminated by a null macro because of the weird syntax).

	Apps/VUEE/RFPING un-converted from manual VUEE to PiComp
	Apps/TESTS/ToySimple made PiComp-compatible

PG100706A:	3 1	SIDE >= PG100706A, VUEE >= PG100706A

	There is a new script, named deploy, located in this directory (i.e.,
	PICOS). It takes no arguments. When called, it will:

	1. verify whether the versions of all three packages (PICOS, SIDE,
	   VUEE) match,

	2. install/setup all three packages; this includes compiling mks/vuee
	   of SIDE, setting up links in VUEE/PICOS, and copying mkmk and picomp
	   from PICOS/Scripts to bin or BIN

	For 1, it is now possible to declare version (RTAG) dependencies, e.g.,
	see the present tag (i.e., 13 lines up). This particular tag says (in
	addition to providing a release number) that:

	1. the PicOS official system version is now 3.1

	2. PicOS requires SIDE and VUEE to be at least at the same RTAG level

	Similar specifications can be inserted into RTAG files in SIDE and
	VUEE, except that the version numbers in those packages are defined
	differently (and you normally don't care about them). I have also
	unified a couple of things:

	1. In all packages, RTAGs are stored in files named RTAGS..., where ...
	   is an arbitrary suffix (allowing for multiple files, e.g., used by
	   different developers). ALL files with such names are examined and
	   the LAST (most recent or highest-valued) RTAG is selected from
	   amongst them all as the effective release tag. What counts to a
	   tag's value is its number and the (optional) single letter following
	   that number, e.g., WO100711A > WO100711B > PG100710C.

	2. Not all tags must specify dependencies (or system version numbers
	   for PicOS). The version dependency of a package is determined from
	   the most recent tag that actually specifies a dependency. For
	   example, suppose that we have this chronological sequence of most
	   recent tags for PICOS:

	   WO100706A:	SIDE >= PG100704A
	   ...
	   WO100711A:	VUEE >= PG100709A
	   ...
	   PG100712A:
	   ...

	   The system requires VUEE at 100709A (or newer) and SIDE at 100704A
	   (or newer). Note that VUEE and SIDE may declare their own
	   dependencies on the other packages, although SIDE normally does not
	   depend on PICOS.

 	3. I have removed the (short-lived) Version file from PICOS. Its role
	   is now assumed (or resumed) by RTAGS (mostly as it was before our
	   move to git, except that then there was a single RTAGS file).

	4. Each of the three packages now has two scripts at the top level:
	   deploy (to deploy the particular package) and cleanup (to clean it
	   up). They must be called from their respective directories.
	   PICOS/cleanup invokes cleanup from the Apps directory followed by
	   Scripts/permissions, while VUEE/cleanup removes the links from
	   VUEE/PICOS (and executes permissions as well). SIDE/deploy accepts
	   two arguments (defaulting to bin and SOFTWARE/VUEE/PICOS) specifying
	   the destination directory of the mks/vuee compiler and the extra
	   library containing VUEE stuff.

	The PICOS's version of deploy is a bit different from the other two,
	because it calls them to set up the whole thing. So normally you will
	be only invoking deploy in PICOS. This is the recommended thing to do
	after updating any of the packages.

PG100714A:

	Board WARSAW_NEW_BLUE added (includes interface to LinkMatik 2.0 which
	I used for testing Bluetooth connections with the Android). See also
	Apps/TEST/BlueTest.

	Minor cosmetics:

	The deploy script now shows also the version number (not just the
	RTAG release) of PICOS.

	There is an -all option in the cleanup script that cleans up all
	three packages.

PG100716A:	VUEE >= PG100716A

	Naming of "hidden" variables and functions cleaned up (such names now
	begin with __pi_) in preparation for the upcoming revision of PICOS's
	implementation of strands.

	Eliminated the distinction between system and user events (the ETYPE
	attribute of events has been removed from the kernel). I have spent
	some time contemplating this step. It does simplify a lot of things in
	the kernel and appears generally safe. The implication for a praxis
	programmer is that event identifiers should be always derived from
	addresses as to make them unique. Note that generally, even if those
	identifiers are not abolutely unique, there should be no problem, as
	long as we always follow the standard paradigm of re-checking the
	respective condition after receiving an event. One exception (and a
	potential source of problems) is process termination (for join and
	joinall), because the events awaited for those operations are always
	assumed to be authoritative.

	I will explain all this in the new edition of the manual, which will
	probably materialize later, after strands have been redone. You may
	want to know, for example, that the event awaited by join is the PID
	of the child process. Thus, the praxis shouldn't deliver (trigger)
	such an event (unless it knows what it is doing). Note that PIDs are
	basically addresses of data structures in the kernel, so they cannot
	be confused for addresses in the praxis area. Similarly, the event
	awaited by joinall is the address of the process's code function.
	Previously, even though those events were represented in the same
	way, they had an extra attribute differentiating them from user/praxis
	events.

	OK, so the bottom line is this: use addresses for event identifiers,
	pretty much as you have been doing so far. Those addresses may point
	to your static data or code, except that the addresses of process code
	functions trigger joinall. The standard practice of using the addresses
	of global/static variables is always safe.
	
	I have simplified some operations (and even removed some of them)
	eliminating those "features" that have never been used in praxes.
	Again, it will be all described in detail in the new manual, but
	here is an approximate list:

	- Zombies have been eliminated. I introduced them originally in order
	  to provide for foolproof handshakes whereby, say, strand A formally
	  terminates (delivering a join/joinall event), but remains present
	  for a while (as a zombie) until some other (joining) process B
	  is given a chance to see it (or its data). Scenarios like this
	  have never been used, and, if needed, they can be implemented using
	  extra events.

	- Operations kill, killall, join, joinall, trigger, ptrigger used to
	  return values (which nobody ever used). Now they return nothing.

	- Operation status has been eliminated.
	  
	Fixed deploy to correctly handle locations outside the HOME directory
	tree on cygwin.

	The new versions of mkmk and picomp can now handle eCOG compilation
	(the makefile variant). I don't think Cyan SDK projects will ever be
	compatible with picomp. Who cares!

	There is a new option for picomp. With -e it will simply run vuee on
	the existing VUEE_TMP (without recompiling the original sources).
	Any errors from picomp are now stored in a special file in VUEE_TMP
	(named __status__, if you are curious). Using both -e and -n you can
	see those errors without running picomp again. Previously picomp would
	refuse to run vuee after warnings from the C preprocessor. Now, it
	can beter tell warnings from fatal errors.

PG100718A:

	As it turns out, hardware CRC on CC1100 shouldn't be used with the
	AUTOFLUSH mode, as it hangs the chip. Apparently, the chip gets into
	the "received" state (its status changes to IDLE) without properly
	presenting the reception/FIFO status (FIFO is empty unless the CRC
	is correct, which is probably the confusing factor). I have tried
	several (three to be exact) events signaled on GDO0 (1, 7, 15) and
	none of them really works as the correct indication of what has
	happened.

	For now, I am disabling that option, i.e., if you select RADIO_CRC_MODE
	= 2 or 3, you will get compilation errors. I don't want to remove it
	altogether, because there is a chance that the problem has been
	eliminated in newer versions of the chip.

	I have added a few sentences at the end of the document (doc.odt) in
	Apps/VUEE/RFTEST explaining how you can use the praxis to determine
	a good PATABLE setting (by trial and error). Coming up: a command to
	do this automatically.

PG100720A:

	A new command added to praxis RFTEST (Apps/VUEE/RTFEST) allowing you
	to collect statistics correlating PATABLE settings with perceived RSSI
	(for CC1100). Read doc.odt in Apps/VUEE/RFTEST.

PG100721A:	VUEE >= PG100721A

	Hooks and timers in TCV/VNETI (cleaned, redone, and tested). The delay
	is now in (PicOS) milliseconds (not in seconds, as stated in the
	manual). TCV timers have been integrated with the kernel delay
	mechanism.

	Praxis Apps/VUEE/HOOKS (or rather the acknowledging plugin that comes
	with it) illustrates how to use the hooks and timers.

	Irrelevant cosmetics in PiComp.

PG100722A:

	Praxis Apps/VUEE/TIMERS is better than Apps/VUEE/HOOKS. I am removing
	Apps/VUEE/HOOKS. TCV_HOOKS is probably redundant (as an option) and not
	needed.

	Fixed a serious bug in PiComp causing two 'shared' variables with the
	same name in the same file (used by different processes) to be mapped
	into one.

	A minor fix to CC1100 driver. Admitting RX chip state after a
	reception (nonempty FIFO), which may result from two packets being
	received (almost) back to back. While the second packet will not
	always succeed in such circumstances, it doesn't absolutely have to
	fail.

PG100723A:

	RADIO_OPTIONS & 0x80 (together with ENTROPY_COLLECTION) initializes
	entropy (for rnd) from the air when the node resets (CC1100 only).
	The driver 1) enters RX mode, 2) delays for 1 msec, 3) collects RSSI,
	4) appends four least significant bits of the RSSI to entropy,
	5) enters IDLE. This procedure is repeated 8 times to collect 32 bits.
	Optical inspection convinces me that the randomness of a thusly
	collected value is very good.

	Praxis Apps/VUEE/TIMERS modified slightly to facilitate some tests.
	For example, I have added there a command to produce a sequence of
	random numbers, which I am going to subject to formal conformance
	tests.

	A minor fix to tcvp_settimer (in tcv.c). Things should be a tiny bit
	more efficient.

PG100723B:

	Sorry, sorry, sorry! PG100722A is crap. Mea culpa. The HOOKS are
	required after all. The present version of Apps/VUEE/TIMERS contains
	my last word (so far ;-). I forgot that TCV/VNETI can drop packets
	silently (when TX goes off) in which case the plugin will not now that
	its hooked packets are gone (unless it is using TCV_HOOKS).

	By the same token, the plugin cannot have an internal tally of hooked
	packets, so I have removed the variable NFreeHooks, along with the
	event supposedly triggered when a hook becomes free. There can be no
	such thing unless we add something (like an extra plugin function) to
	convey the message. Do we need it? Probably not. So there's now a
	function that you can call to get the number of free hooks, which are
	counted explicitly on each request.

	Upgraded uf.tcl (in Scripts) to make it possible to copy the UART
	output to a file. This is much better than Terminal, especially that
	I am now working with Linux.

PG100724A:

	The random number generator improved. If entropy fails to collect, it
	will fall back to a decent linear congruential 32-bit based generator
	with a long cycle.

	Cosmetics in phys_cc1100 to appease the compiler.

	Fixed a problem in tcv.c causing a compilation error with VUEE.

PG100724B:

	tcvp_unhook(p) accepts p == NULL (and does nothing in such a case).

	The random number generator improved even more. We now have two RNGs:

		word rnd ()
		lword lrnd ()

	basically for the price of one. They are both available with options:

		#define RANDOM_NUMBER_GENERATOR 1

	as well as 
	
		#define RANDOM_NUMBER_GENERATOR 2

	Recall that the second option selects a better quality generator (the
	first option sucks, but is more efficient, and, probably, with entropy
	collection:

		#define	ENTROPY_COLLECTION 1

	will not be perceptibly worse than 2.

PG100725A:

	tcv_drop(p) accepts p == NULL (and does nothing in such a case). This
	is a logical consequence of the last mod to tcvp_unhook.

	Fixed a problem in TCV/VNETI concerning packets that have been removed
	from the buffer pool with their timers (and hooks) dangling.
	This relates to two operations: tcv_rnp and tcvphy_get. Each of them
	produces a packet that:

	1. FAPP has been extracted (eliminated) from the buffer pool
	2. has not been deallocated yet
	3. it may have to remain available for processing beyond the state
	   in which it has been acquired

	Thus, if the packet has a timer set, and the timer goes off while the
	packet is being handled after its extraction, we are likely to get into
	a mess. Note that this also concerns hooks, which can also be handled
	asynchronously (by other threads) yielding races.

	The fix consists in making sure that a packet returned by tcv_rnd and
	tcvphy_get has its timer cleared and its hook removed.

PG100727A:	VUEE >= PG100727A

	Correction: hooks are left intact with tcv_rnp and tcvphy_get (while
	timers are cleared). This makes more sense.

	New functions added to TCV/VNETI (to be documented, as lots of other
	things):

	Boolean tcvp_isqueued (address packet);
	Boolean tcvp_issettimer (address packet);
	address *tcvp_gethook (address packet);

	I have introduced a tentative fix into Wlodek's LicComms/tarp.c (to be
	revised and cleaned up by Wlodek).

	Some prerequisite cleanups for improving the parameterization of LBT,
	mostly for CC1100, but not only. Don't be concerned about the large
	number of modified files. These are mostly renames of different
	constants with the same meaning, so they are consistent across all
	drivers.

	CC1100 driver augmented by options to better control LBT. This is still
	half cooked. The size of the array returned by PHYSOPT_ERROR increased
	to 6 words. See PicOS/cc1100.h for their description as well as for 
	new driver options. Note that there will be more coming up shortly.

	Praxis VUEE/RFTEST modified for the new version of PHYSOPT_ERROR, but
	untested yet.

PG100727B:

	A few minor (but essential) fixes to the CC1100 driver (I have tested
	it [roughly] and it seems OK). I have started writing a doc explaining
	its workings and parameters, but it will take me a couple of days
	(being a low-priority task). If desperate, see PicOS/cc1100.h for
	hints.

PG100729A: VUEE >= PG100729A

	Headers of the new functions added to tcv.c included in tcvplug.h
	(I forgot to put them there).

	A few cosmetic cleanups of little consequence. I am tagging because a
	matching VUEE version is required (one extra constant must be defined
	in VUEE's sysio.h).
