PG100628A:

	First for some git-related cleanups:

	1. I propose to use separate RTAG files for the different developers
	   (all two of them ;-). This is RTAGS_PG. I am leaving the original
	   RTAGS file as it was (for the record). I have also created a new
	   file named Version holding the system version to be used by mkmk.

	2. I have modified mkmk (see above), so grab the new version and copy
	   it to your bin. The script fetches the system version from Version
	   and then scans all RTAGS_... selecting the most recent release tag.
	   Tags are expected to contain six digits (according to our tacit
	   standard, e.g., 100628), but may also contain arbitrary other
	   characters, e.g., WO100629A:

	3. We should be using commit messages for meaningful comments. Also, we
	   shouldn't shy away from many small commits (not all of them being
	   necessarily tagged our way), equatting pushes (which should be
	   tagged - the last commit before a push) with previous CVS commits.
	   Note that present commits are lighter weight than old CVS commits.

	=======================================================================

	The four values returned by PHYSOPT_ERROR for CC1100 redefined. Here is
	the description from phys_cc1100.cc

	0 - receptions (all events when receiver is awakened to check for a
	    pkt)

	1 - successfully received packets; note that with hardware CRC +
	    AUTOFLUSH, 0 and 1 will be equal

	2 - LBT/congestion indicator: EMA d(n) = 0.75 * d(n-1) + 0.25 * b,
	    where b is the backoff experienced when trying to access the
	    channel for TX; this is counted over all attempts to access the
	    channel and maxed at 0x0fff, i.e., 4095

	3 - the maximum accumulated backoff time suffered by a single packet so
	    far

	Also read doc.odt from Apps/VUEE/RFTEST.

	The RFTEST Praxis, which I wrote for Gerry a few weeks ago, has been
	brought to a PiComp-compatible form.

	Simplified utimer_set in kernel.c (insignificantly). I have been 
	searching there for weird reasons why a transmit queue might get
	stuck on LBT. One of them would be a stuck utimer, but it doesn't
	seem plausible at all.

	I have done some tests with RFTEST. It seems that setting XMIT queue
	size limit in TCV, say #define TCV_LIMIT_XMT 8 (in options.sys) may be
	a good idea. I did see a few memory problems under the outgoing packet
	rate of 4 pkts/sec (nodes becoming unresponsive to UART because of
	choked up malloc) which diappeared after I introduced the limit. It
	appears that the reception queue size is not a problem.

PG100629A:

	Fixed file permissions. Cygwin creates a lot of mess with file
	permissions (which get screwed up when copying, archiving, untarring,
	etc.). Unfortunately (or rather fortunately, but not in this case),
	when you change the permissions of a file, git recognizes the file as
	modified, which occasionally becomes annoyoing.

	The upshot:

	There is script in Scripts, named permissions, which has been there
	for a while (and I have been using it every now and then). I recommend
	to run it:

		cd PICOS
		Scripts/permissions

	whenever you suspect that file permissions may have been messed up
	(git status shows modified files that haven't really been modified).
	It runs through the tree and sets the right permissions of files (which
	are mostly guessed, but mostly correctly and, most importantly,
	deterministically). In particular, you should do it before checking the
	status, adding, and/or committing.

PG100630A:

	Converted Apps/VUEE/survey to PiComp. Perhaps "converted" is not a good
	word, as the job consists in undoing the previous VUEE hooks. Along the
	way, detected (and fixed) one problem with PiComp: when tokenizing
	initializers, PiComp would split constructs like << into < < (i.e.,
	introducing a space between the two characters).

	Also, PiComp now parses crunning. The case of crunning (NULL) was
	impossible to handle in a macro (so it didn't work under VUEE), as the
	(non-NULL) argument od crunning had to be converted to a SIDE process
	type ID, i.e.,

	#define	_pt_id_(pt)	(&zz_!!THREADNAME(pt)!!_prcs)
	#define	crunning(pt)	zz_crunning (_pt_id_ (pt))

	So when you said crunning (NULL), the macro would produce nonsense. To
	do it right, I would have to remove the macro (crunning) and parse
	crunning in PiComp into zz_crunning recognizing the special case of a
	NULL (generally non-symbol) argument. That, however, would cause
	problems for the old VUEE-compliant praxes (which are not handled by
	PiComp and must rely on the macro).

	As the macro is expanded before PiComp sees the code, I handle two
	cases:

	crunning -> zz_crunning (not used now, waiting for the macro to
	disappear)

	zz_crunning -> zz_crunning (fixing the problem introduced by the macro
	for a non-symbol argument)

	Note that this requires a modification in VUEE. Please use VUEE with
	the same (or higher) release tag, if you want to have crunning working
	correctly with the PiComp-compatible praxes.

PG100705A:	VUEE >= PG100705A, SIDE >= PG100705A

	Introducing type lint (along the line of sint) intended to be PicOS's
	replacement for long. While it is not absolutely required to use this
	type (instead of long) in praxes, it is recommended in order to avoid
	problems with VUEE, especially on 64-bit machines. This required a
	modification in VUEE (PG100705A), which was directly inspired by the
	recent problem signaled by Nick (and his fix). That in turn required
	a (very slight) modification to SIDE. So you should get them all.

	I am not sure if I have fixed Nick's second problem. Nick, please let
	me know.

	I have gone through the source, including most praxes, replacing
	long with lint. Note that the problem of eliminating int and
	replacing it with sint everywhere is a bit more complicated. One reason
	why you have to be careful there is that PicOS (and consequently VUEE)
	uses int for some handles, notably PIDs, which are in fact addresses
	(using type word to store event numbers is another messy feature).
	This may change in the future. Probably, we should have two more types
	(or maybe just one) to take care of process and event handles. This
	cannot be done quickly as a lot in VUEE depends on the assumption that
	PID is an int derived from an address. Note that any problems caused by
	this "overloading" of types will be amplified on 64-bit systems.

	A minor cleanup in kernel.c (code for killing processes improved a
	bit).

	A few fixes to PiComp. Line count (for error diagnostics) would go off
	after an #if(def) or #else, for one thing. For another, PiComp now
	(when compiling for VUEE) recognizes and compiles out heapmem (it
	could not be eliminated by a null macro because of the weird syntax).

	Apps/VUEE/RFPING un-converted from manual VUEE to PiComp
	Apps/TESTS/ToySimple made PiComp-compatible

PG100706A:	3 1	SIDE >= PG100706A, VUEE >= PG100706A

	There is a new script, named deploy, located in this directory (i.e.,
	PICOS). It takes no arguments. When called, it will:

	1. verify whether the versions of all three packages (PICOS, SIDE,
	   VUEE) match,

	2. install/setup all three packages; this includes compiling mks/vuee
	   of SIDE, setting up links in VUEE/PICOS, and copying mkmk and picomp
	   from PICOS/Scripts to bin or BIN

	For 1, it is now possible to declare version (RTAG) dependencies, e.g.,
	see the present tag (i.e., 13 lines up). This particular tag says (in
	addition to providing a release number) that:

	1. the PicOS official system version is now 3.1

	2. PicOS requires SIDE and VUEE to be at least at the same RTAG level

	Similar specifications can be inserted into RTAG files in SIDE and
	VUEE, except that the version numbers in those packages are defined
	differently (and you normally don't care about them). I have also
	unified a couple of things:

	1. In all packages, RTAGs are stored in files named RTAGS..., where ...
	   is an arbitrary suffix (allowing for multiple files, e.g., used by
	   different developers). ALL files with such names are examined and
	   the LAST (most recent or highest-valued) RTAG is selected from
	   amongst them all as the effective release tag. What counts to a
	   tag's value is its number and the (optional) single letter following
	   that number, e.g., WO100711A > WO100711B > PG100710C.

	2. Not all tags must specify dependencies (or system version numbers
	   for PicOS). The version dependency of a package is determined from
	   the most recent tag that actually specifies a dependency. For
	   example, suppose that we have this chronological sequence of most
	   recent tags for PICOS:

	   WO100706A:	SIDE >= PG100704A
	   ...
	   WO100711A:	VUEE >= PG100709A
	   ...
	   PG100712A:
	   ...

	   The system requires VUEE at 100709A (or newer) and SIDE at 100704A
	   (or newer). Note that VUEE and SIDE may declare their own
	   dependencies on the other packages, although SIDE normally does not
	   depend on PICOS.

 	3. I have removed the (short-lived) Version file from PICOS. Its role
	   is now assumed (or resumed) by RTAGS (mostly as it was before our
	   move to git, except that then there was a single RTAGS file).

	4. Each of the three packages now has two scripts at the top level:
	   deploy (to deploy the particular package) and cleanup (to clean it
	   up). They must be called from their respective directories.
	   PICOS/cleanup invokes cleanup from the Apps directory followed by
	   Scripts/permissions, while VUEE/cleanup removes the links from
	   VUEE/PICOS (and executes permissions as well). SIDE/deploy accepts
	   two arguments (defaulting to bin and SOFTWARE/VUEE/PICOS) specifying
	   the destination directory of the mks/vuee compiler and the extra
	   library containing VUEE stuff.

	The PICOS's version of deploy is a bit different from the other two,
	because it calls them to set up the whole thing. So normally you will
	be only invoking deploy in PICOS. This is the recommended thing to do
	after updating any of the packages.

PG100714A:

	Board WARSAW_NEW_BLUE added (includes interface to LinkMatik 2.0 which
	I used for testing Bluetooth connections with the Android). See also
	Apps/TEST/BlueTest.

	Minor cosmetics:

	The deploy script now shows also the version number (not just the
	RTAG release) of PICOS.

	There is an -all option in the cleanup script that cleans up all
	three packages.

PG100716A:	VUEE >= PG100716A

	Naming of "hidden" variables and functions cleaned up (such names now
	begin with __pi_) in preparation for the upcoming revision of PICOS's
	implementation of strands.

	Eliminated the distinction between system and user events (the ETYPE
	attribute of events has been removed from the kernel). I have spent
	some time contemplating this step. It does simplify a lot of things in
	the kernel and appears generally safe. The implication for a praxis
	programmer is that event identifiers should be always derived from
	addresses as to make them unique. Note that generally, even if those
	identifiers are not abolutely unique, there should be no problem, as
	long as we always follow the standard paradigm of re-checking the
	respective condition after receiving an event. One exception (and a
	potential source of problems) is process termination (for join and
	joinall), because the events awaited for those operations are always
	assumed to be authoritative.

	I will explain all this in the new edition of the manual, which will
	probably materialize later, after strands have been redone. You may
	want to know, for example, that the event awaited by join is the PID
	of the child process. Thus, the praxis shouldn't deliver (trigger)
	such an event (unless it knows what it is doing). Note that PIDs are
	basically addresses of data structures in the kernel, so they cannot
	be confused for addresses in the praxis area. Similarly, the event
	awaited by joinall is the address of the process's code function.
	Previously, even though those events were represented in the same
	way, they had an extra attribute differentiating them from user/praxis
	events.

	OK, so the bottom line is this: use addresses for event identifiers,
	pretty much as you have been doing so far. Those addresses may point
	to your static data or code, except that the addresses of process code
	functions trigger joinall. The standard practice of using the addresses
	of global/static variables is always safe.
	
	I have simplified some operations (and even removed some of them)
	eliminating those "features" that have never been used in praxes.
	Again, it will be all described in detail in the new manual, but
	here is an approximate list:

	- Zombies have been eliminated. I introduced them originally in order
	  to provide for foolproof handshakes whereby, say, strand A formally
	  terminates (delivering a join/joinall event), but remains present
	  for a while (as a zombie) until some other (joining) process B
	  is given a chance to see it (or its data). Scenarios like this
	  have never been used, and, if needed, they can be implemented using
	  extra events.

	- Operations kill, killall, join, joinall, trigger, ptrigger used to
	  return values (which nobody ever used). Now they return nothing.

	- Operation status has been eliminated.
	  
	Fixed deploy to correctly handle locations outside the HOME directory
	tree on cygwin.

	The new versions of mkmk and picomp can now handle eCOG compilation
	(the makefile variant). I don't think Cyan SDK projects will ever be
	compatible with picomp. Who cares!

	There is a new option for picomp. With -e it will simply run vuee on
	the existing VUEE_TMP (without recompiling the original sources).
	Any errors from picomp are now stored in a special file in VUEE_TMP
	(named __status__, if you are curious). Using both -e and -n you can
	see those errors without running picomp again. Previously picomp would
	refuse to run vuee after warnings from the C preprocessor. Now, it
	can beter tell warnings from fatal errors.

PG100718A:

	As it turns out, hardware CRC on CC1100 shouldn't be used with the
	AUTOFLUSH mode, as it hangs the chip. Apparently, the chip gets into
	the "received" state (its status changes to IDLE) without properly
	presenting the reception/FIFO status (FIFO is empty unless the CRC
	is correct, which is probably the confusing factor). I have tried
	several (three to be exact) events signaled on GDO0 (1, 7, 15) and
	none of them really works as the correct indication of what has
	happened.

	For now, I am disabling that option, i.e., if you select RADIO_CRC_MODE
	= 2 or 3, you will get compilation errors. I don't want to remove it
	altogether, because there is a chance that the problem has been
	eliminated in newer versions of the chip.

	I have added a few sentences at the end of the document (doc.odt) in
	Apps/VUEE/RFTEST explaining how you can use the praxis to determine
	a good PATABLE setting (by trial and error). Coming up: a command to
	do this automatically.
