#!/bin/sh
##########################\
exec tclsh "$0" "$@"

############################################################################
# This script generates makefiles for mspgcc and project files for CyanIDE #
#                                                                          #
# See: proc bad_usage for usage                                            #
#                                                                          #
# Copyright (C) Olsonet Communications, 2005 - 2008 All Rights Reserved    #
############################################################################

set DEBUG 0

if $DEBUG {
	proc dmp { t } {
		puts $t
	}
} else {
	proc dmp { t } { }
}

#
# Legitimate targets, the corresponding modes, and default comp params
#
set Targets {
		{ "MSP430"	"M" "msp430x148" }
		{ "eCOG"	"E" "" }
}
# eCOG has no parameters for now

#
# Directories to be searched (in this order). This also reflects the order of
# search.
#
set DirList {
		"PicOS/@TARGET@"
		"PicOS/@TARGET@/BOARDS"
		"PicOS/kernel"
		"PicOS"
		"PicOS/Libs/*"
		"."
		"./*"
}

#
# List of patterns identifying the "to compile" files to be moved to the end
# of list, e.g., because of relocation problems.
#
set TocTail {
		"kernel"
}

proc lappend_toc { li i } {

	global TocTail
	upvar $li l

	if ![info exists l] {
		lappend l $i
		return
	}

	if { [lsearch -exact $l $i] >= 0 } {
		return
	}

	foreach p $TocTail {
		if [regexp -nocase $p $i] {
			lappend l $i
			return
		}
	}

	set x 0
	foreach u $l {
		set f 0
		foreach p $TocTail {
			if [regexp -nocase $p $u] {
				set f 1
				break
			}
		}
		if $f {
			# insert here
			set l [linsert $l $x $i]
			return
		}
		incr x
	}
	lappend l $i
}

proc islibrun { } {

	global Run

	# run type letter is anything upper case
	return [regexp "^\[A-Z\]" $Run(type)]
}

proc lappend_unique { li i } {

	upvar $li l

	if { ![info exists l] || [lsearch -exact $l $i] < 0 } {
		lappend l $i
	}
}

proc errab { m } {

	puts stderr $m
	exit 1
}

proc addeps { flist } {

	global Depend Locdep

	foreach fn $flist {
		if ![info exists Locdep($fn)] {
			set Locdep($fn) ""
			if [info exists Depend($fn)] {
				addeps $Depend($fn)
			}
		}
	}
}

proc trimdir { } {
#
# Trim the directories
#
	global DirList DirShort IncShort Depend SrcLists

	set dc 0
	set ic 0
	array unset DirShort
	foreach tar [array names SrcLists] {
		foreach fn $SrcLists($tar) {
			set dir [file dirname $fn]
			if ![info exists DirShort($dir)] {
				set DirShort($dir) [format "S%02d" $dc]
				incr dc
			}
		}
	}

	foreach dep [array names Depend] {
		foreach fn $Depend($dep) {
			set dir [file dirname $fn]
			set ishort($dir) ""
		}
	}

	# sort the include directories
	set idl ""
	foreach dir $DirList {
		if [info exists ishort($dir)] {
			lappend idl $dir
			unset ishort($dir)
			set IncShort($dir) [format "I%02d" $ic]
			incr ic
		}
	}
}

proc getstubs { srcs } {
#
# Find the stubs to be compiled separately (CYAN only)
#
	global DirList PDirList StubDir StubList RPREF Depend

	# locate the Stubs directory
	set StubList ""
	set StubDir ""

	set fn ""
	foreach dir $DirList {
		if { [string tolower [file tail $dir]] == "stubs" &&
		    [file isdirectory $dir] &&
		    [lsearch -exact $PDirList $dir] < 0 } {
			set fn [uxname $dir]
			break
		}
	}
			
	if { $fn == "" } {
		return
	}

	if [catch { exec ls $fn } sli] {
		errab "Cannot list stub directory $fn"
	}

	foreach st $sli {

		if ![regexp "\\.c$" $st] {
			# all stubs must be .c files
			continue
		}
		# find the contingencies
		set sf [file join $fn $st]
		if [catch { open $sf "r" } sd] {
			errab "Cannot access stub $sf"
		}
		if [catch { read $sd } sc] {
			errab "Cannot read stub $sf"
		}
		catch { close $sd }

		# build the contingency list (this is a bit heuristic, as if
		# this were news)
		set cl ""
		while 1 {
			if ![regexp "//\[ \t\]*\\+\\+\\+(\[^\n\]*)" $sc m c] {
				break
			}
			foreach c [needlist $c $sf] {
				lappend_unique cl $c
			}
			set ix [string first $m $sc]
			if { $ix < 0 } {
				# impossible
				break
			}
			set sc [string range $sc \
				[expr $ix + [string length $m]] end]
		}

		# verify that all contingency files are included in the lib
		set ok 1
		foreach c $cl {
			set c [string tolower $c]
			set fnd 0
			if [regexp "\\.h$" $c] {
				# this is a header, search dependencies
				foreach dep [array names Depend] {
					foreach dn $Depend($dep) {
						set rn [string tolower \
							[file tail $dn]]
						if { $rn == $c } {
							set fnd 1
							break
						}
					}
					if $fnd {
						break
					}
				}
			} else {
				foreach dn $srcs {
					set rn [string tolower [file tail $dn]]
					if { $rn == $c } {
						set fnd 1
						break
					}
				}
			}
			if !$fnd {
				# first not found stops us
				set ok 0
				break
			}
		}

		if $ok {
			lappend StubList $st
		}
	}

	if { $StubList != "" } {
		set StubDir $fn
	}
}

proc outprf { def cpu } {
#
# Output a project file for CyanIDE. The second argument (compilation params)
# ignored for now, but may be useful later.
#
	global IncShort SrcLists Depend CWD Locdep Run

	# build a trimmed list of relevant directories
	trimdir

	if [islibrun] {
		set LD [file join $Run(library) asm]
		set LI [file join $Run(library) include]
		set LS [file join $Run(library) stubs]
		# prepare the list of ASM files in the library
		if [catch { exec ls [uxname [file join $Run(library) asm]] } \
		    asl] {
			errab "Cannot access the ASM component of library at\					$Run(library)"
		}
		set flist ""
		foreach fi $asl {
			if [regexp -nocase "\\.asm$" $fi] {
				# tolower is not necessary
				lappend flist [string tolower $fi]
			}
		}
	} else {
		set LD ""
		set LI ""
		set LS ""
	}

	foreach tar [array names SrcLists] {
		# build the file suffix
		if { $tar == "" } {
			set tarn ""
		} else {
			set tarn "_$tar"
		}

		set pname "[file tail $CWD]${tarn}.cyp"

		if [catch { open $pname "w" } mfd] {
			errab "cannot open $pname for writing: $mfd"
		}

		puts $mfd "<project buildenvironment=\"{5bb3321d-c620-467d-8787-1a268e2edf63}\" executionenvironment=\"{ab5780d6-ed62-47a1-a50c-bc70aee3b715}\" executionenvironmentname=\"eCOG1 Eval Board\" version=\"1.00.0003\" buildenvironmentname=\"eCOG1\" >\n"

		# asm files
		puts $mfd "<folder name=\"ASM Files\">"
		puts $mfd "<extension name=\"asm\"/>\n"

		if [islibrun] {
			# all asm files from the library
			foreach fn $flist {
				puts $mfd "<file path=\"[file join $LD $fn]\"/>"
			}
		} else {
			# add the standard files
			foreach fn { "cstartup.asm" "irq.asm" } {
				puts $mfd "<file path=\"$fn\"/>"
			}
		}

		# any application's asm files
		foreach fn $SrcLists($tar) {
			if { [file extension $fn] == ".asm" } {
				puts $mfd "<file path=\"$fn\"/>"
			}
		}

		puts $mfd "</folder>"
		puts $mfd "<folder name=\"C Files\">\n<extension name=\"c\"/>\n"

		foreach fn $SrcLists($tar) {
			set fex [file extension $fn]
			if { $fex == ".cc" } {
				# must copy to .c (we shouldn't trust links as
				# this will be ultimately handled by Windows)
				set tfn [file join $CWD "KTMP"]
				# create KTMP
				if [catch { exec mkdir -p $tfn } err] {
					errab \
					    "cannot mkdir '$tfn': $err"
				}
				set tfn [file join $tfn \
					 "[file rootname [file tail $fn]].c"]
			
				if [catch { exec cp $fn $tfn } err] {
					errab \
					   "cannot copy '$fn' to 'xxx.c': $err"
				}
				set fn $tfn
			} elseif { $fex != ".c" } {
				continue
			}
			puts $mfd "<file path=\"$fn\"/>"
		}

		# there should be no other files
		puts $mfd "</folder>"
		puts $mfd "<folder name=\"header Files\">"
		puts $mfd "<extension name=\"h\"/>\n"

		# internal.map should be mentioned here, I guess
		if [islibrun] {
			puts $mfd \
				"<file path=\"[file join $LD internal.map]\"/>"
		} else {
			puts $mfd "<file path=\"internal.map\"/>"
		}

		# I am not sure if we could use a cfg file

		# collect the proper dependency subset
		array unset Locdep
		foreach fn $SrcLists($tar) {
			if [info exists Depend($fn)] {
				addeps $Depend($fn)
			}
		}

		foreach fn [array names Locdep] {
			if { [file extension $fn] == ".h" } {
				puts $mfd "<file path=\"$fn\"/>"
			}
		}
		array unset Locdep

		puts $mfd "</folder>"

		puts $mfd "<properties currentconfiguration=\"Release\">"
		foreach cnam { "Release" "Debug" } {
			puts $mfd "<configuration name=\"$cnam\">"
			if { $def != "" || $cnam == "Release" } {
				puts -nonewline $mfd \
					"<property key=\"defines\">"
				if { $cnam == "Release" } {
					puts -nonewline $mfd "NDEBUG"
					set first 0
				} else {
					set first 1
				}
				foreach fn $def {
					if !$first {
						puts -nonewline $mfd ";"
					} else {
						set first 0
					}
					puts -nonewline $mfd "$fn"
				}
				puts $mfd "</property>"
			}
			if { $cnam == "Debug" } {
				puts $mfd \
				  "<property key=\"keepAssembler\">1</property>"
			}

   			puts $mfd \
				"<property key=\"brkInstallAddr\" >0</property>"
			puts $mfd \
				    "<property key=\"outputDir\">out</property>"
			puts $mfd \
			     "<property key=\"intermediateDir\">temp</property>"

			if [islibrun] {
				puts $mfd \
   	 "<property key=\"mapFile\">[file join $LD internal]</property>"
				puts $mfd \
	 "<property key=\"packFile\">[file join $LD cstartup.asm]</property>"
				puts $mfd \
	 "<property key=\"libDirs\">$LS</property>"

			} else {
				puts $mfd \
			    	 "<property key=\"mapFile\">internal</property>"
				puts $mfd \
			    "<property key=\"packFile\">cstartup.asm</property>"
			}

   			puts $mfd "<property key=\"stabsInfo\" >1</property>"

			puts -nonewline $mfd "<property key=\"includeDirs\">"

			set first 1
			set idirs ""

			if [islibrun] {
				lappend idirs $LI
				set first 0
			}

			foreach { dir sht } [array get IncShort] {
				lappend idirs [list $dir $sht]
			}
			set idirs [lsort -index 1 $idirs]
			foreach dir $idirs {
				if !$first {
					puts -nonewline $mfd ";"
				} else {
					set first 0
				}
				puts -nonewline $mfd [lindex $dir 0]
			}
			puts $mfd "</property>"
			puts $mfd "</configuration>"
		}
		puts $mfd "</properties>"
		puts $mfd "</project>"
		catch { close $mfd }
	}

	foreach ef { "internal.map" "cstartup.asm" "irq.asm" } {
		set fn [lookup $ef ""]
		if { $fn == "" } {
			lappend NotFound $ef
		} else {
			exec cp $fn $CWD
		}
	}
}

proc outmkfc { def } {
#
# Output a makefile for CYANIDE: this should allow for multiple praxes in one
# directory, similar to MSP430
#
#	IncShort:	array of include directories indexed by paths
#	DirShort:	array of source directories
#	Depend:		array of dependency lists (can be global)
#	SrcLists:	per-target array of files to compile (ToCompile)
#
	global DirShort IncShort SrcLists Depend CWD NotFound Run

	# build a trimmed list of relevant directories
	trimdir

	if [catch { open "Makefile" "w" } mfd] {
		error "cannot open Makefile for writing: $mfd"
	}

	puts $mfd "#\n# Created by mkmk, DO NOT EDIT!!!\n#"
	puts $mfd "CC=ecogncc"
	puts $mfd "CL=ecogcl"

	puts -nonewline $mfd "CF=-quiet"
	foreach sht $def {
		puts -nonewline $mfd " -D$sht"
	}

	puts $mfd ""
	puts $mfd "OF=-g -DNDEBUG"
	puts $mfd "TD=temp"
	puts $mfd "OD=out"

	if [islibrun] {
		# using a library
		set lid [file join $Run(library) asm]
		puts $mfd "LD=$lid"
		puts $mfd "LDU=[uxname $lid]"
		puts $mfd "LI=-I[file join $Run(library) include]"
		puts $mfd "LS=-lib [file join $Run(library) stubs]"
		# prepare the list of ASM files in the library
		if [catch { exec ls [uxname [file join $Run(library) ASM]] }\
		    asl] {
			errab "Cannot access the ASM component of library at\					$Run(library)"
		}
		set flist ""
		foreach fi $asl {
			if [regexp -nocase "\\.asm$" $fi] {
				# tolower is not necessary
				set fi [string tolower $fi]
				if { $fi != "irq.asm" && 
						      $fi != "cstartup.asm" } {
					lappend flist $fi
				}
			}
		}
	} else {
		puts $mfd "LD=\$(TD)"
		puts $mfd "LDU=\$(TD)"
		puts $mfd "LI="
		puts $mfd "LS="
	}

	# output the list of directories
	puts $mfd "# include directories"
	set idirs ""
	foreach { dir sht } [array get IncShort] {
		lappend idirs [list $dir $sht]
	}
	set idirs [lsort -index 1 $idirs]
	foreach dir $idirs {
		set fna [lindex $dir 0]
		set tag [lindex $dir 1]
		puts $mfd "$tag=$fna"
		puts $mfd "${tag}U=[uxname $fna]"
	}
	puts $mfd "# source directories"

	set sdirs ""
	foreach { dir sht } [array get DirShort] {
		lappend sdirs [list $dir $sht]
	}
	set sdirs [lsort -index 1 $sdirs]
	foreach dir $sdirs {
		set fna [lindex $dir 0]
		set tag [lindex $dir 1]
		puts $mfd "$tag=$fna"
		puts $mfd "${tag}U=[uxname $fna]"
	}
	puts $mfd "#"

	puts -nonewline $mfd "IN="
	foreach dir $idirs {
		puts -nonewline $mfd "-I\$([lindex $dir 1]) "
	}
	puts $mfd "\n"

	# target names
	set tnames [lsort [array names SrcLists]]

	# the "all" target becomes the default
	puts -nonewline $mfd "all :	"

	if { [llength $tnames] == 1 && [lindex $tnames 0] == "" } {
		# Single simple target
		puts $mfd "\$(OD)/app.xpv\n"
	} else {
		foreach tar $tnames {
			if { $tar == "" } {
				# this will not happen
				errab "illegal default target"
			}
			puts -nonewline $mfd "$tar "
		}
		puts $mfd "\n"
	
		foreach tar $tnames {
			puts $mfd "$tar :\t\$(OD)/app_${tar}.xpv\n"
		}
		puts $mfd "\n"
	}

	array unset tgts

	foreach tar $tnames {
		# we do this for every target
		puts $mfd "# target: \"$tar\""
		if { $tar != "" } {
			set tarn "_$tar"
		} else {
			set tarn ""
		}
		# names the list of binary files comprising the target

		puts -nonewline $mfd \
			"BFU${tarn}=\$(LDU)/irq.asm \$(LDU)/cstartup.asm"

		foreach fn $SrcLists($tar) {
			puts -nonewline $mfd \
				" \$(TD)/[file rootname [file tail $fn]].asm"
		}
		if [islibrun] {
			foreach fi $flist {
				puts -nonewline $mfd " \$(LDU)/$fi"
			}
		}
		puts $mfd "\n"

		puts -nonewline $mfd \
			"BF${tarn}=\$(LD)/irq.asm \$(LD)/cstartup.asm"

		foreach fn $SrcLists($tar) {
			puts -nonewline $mfd \
				" \$(TD)/[file rootname [file tail $fn]].asm"
		}
		if [islibrun] {
			foreach fi $flist {
				puts -nonewline $mfd " \$(LD)/$fi"
			}
		}
		puts $mfd "\n"

		# the actual target
		set targ "\$(OD)/app${tarn}.xpv"

		puts $mfd "$targ :\t\$(BFU$tarn)"

		puts -nonewline $mfd "\t\$(CL) -g -pack \$(LD)/cstartup.asm "
		puts $mfd "-map \$(LD)/internal \$(LS) -o $targ \$(BF$tarn)\n"

		# the list of compileable sources
		foreach sf $SrcLists($tar) {
			set rfn [file tail $sf]
			set suf [file extension $rfn]
			set rna [file rootname $rfn]
			if [info exists tgts($rna)] {
				# already present
				continue
			}
			set tgts($rna) ""
			set ofn "${rna}.asm"
			set dir [file dirname $sf]
			set dsh $DirShort($dir)
			puts -nonewline $mfd "\$(TD)/$ofn : \$(${dsh}U)/$rfn"
			# dependencies
			if [info exists Depend($sf)] {
				foreach df $Depend($sf) {
					set rfd [file tail $df]
					set did [file dirname $df]
					puts -nonewline $mfd \
						" \$($IncShort($did)U)/$rfd"
				}
			}
			puts $mfd ""
			puts $mfd "\tmkdir -p \$(TD)"
			if { $suf == ".cc" } {
				# this is a VUEE source, copy it to plain C
				set rfn "${rna}.c"
				puts $mfd "\tcp \$($dsh)/${rfn}c \$(TD)/$rfn"
				set spfx "\$(TD)"
				puts -nonewline $mfd \
					"\t\$(CC) \$(CF) \$(OF) \$(LI) \$(IN)"
			} else {
				set spfx "\$($dsh)"
				if { $suf == ".c" } {
					puts -nonewline $mfd \
					  "\t\$(CC) \$(CF) \$(OF) \$(LI) \$(IN)"
				} else {
					errab "illegal source suffix '$sf'"
				}
			}
			puts $mfd " $spfx/$rfn -o \$(TD)/$ofn\n"
		}
		puts $mfd "\n"
	}

	puts $mfd "clean :\n\trm -rf \$(TD)/*"
	catch { close $mfd }

	if ![islibrun] {
		# fetch the auxiliary files
		foreach ef { "internal.map" "cstartup.asm" "irq.asm" } {
			set fn [lookup $ef ""]
			if { $fn == "" } {
				lappend NotFound $ef
			} else {
				exec cp $fn $CWD/temp/
			}
		}
	}
}

proc outmkfc_lib { def } {
#
# Output a makefile for lib run on eCOG
#
#	IncShort:	array of include directories indexed by paths
#	DirShort:	array of source directories
#	Depend:		array of dependency lists (can be global)
#	SrcLists:	per-target array of files to compile (ToCompile)
#
	global DirShort IncShort SrcLists Depend CWD NotFound LIncludes
	global StubDir StubList

	# build a trimmed list of relevant directories
	trimdir

	if [catch { open "Makefile" "w" } mfd] {
		error "cannot open Makefile for writing: $mfd"
	}

	puts $mfd "#\n# Created by mkmk, DO NOT EDIT!!!\n#"
	puts $mfd "CC=ecogncc"
	puts $mfd "RM=rm"

	puts -nonewline $mfd "CF=-quiet"
	foreach sht $def {
		puts -nonewline $mfd " -D$sht"
	}

	puts $mfd ""
	puts $mfd "OF=-g -DNDEBUG"
	puts $mfd "TD=temp"
	puts $mfd "TS=temp/stubs"
	puts $mfd "TR=LIBRARY/include/sysio.h"

	# any stubs?
	getstubs $SrcLists()

	if { $StubList != "" } {
		puts $mfd "SD=[canon $StubDir]"
		puts $mfd "SDU=$StubDir"
	}

	# output the list of directories
	puts $mfd "# include directories"
	set idirs ""
	foreach { dir sht } [array get IncShort] {
		lappend idirs [list $dir $sht]
	}
	set idirs [lsort -index 1 $idirs]
	foreach dir $idirs {
		set fna [lindex $dir 0]
		set tag [lindex $dir 1]
		puts $mfd "$tag=$fna"
		puts $mfd "${tag}U=[uxname $fna]"
	}
	puts $mfd "# source directories"

	set sdirs ""
	foreach { dir sht } [array get DirShort] {
		lappend sdirs [list $dir $sht]
	}
	set sdirs [lsort -index 1 $sdirs]
	foreach dir $sdirs {
		set fna [lindex $dir 0]
		set tag [lindex $dir 1]
		puts $mfd "$tag=$fna"
		puts $mfd "${tag}U=[uxname $fna]"
	}
	puts $mfd "#"

	puts -nonewline $mfd "IN="
	foreach dir $idirs {
		puts -nonewline $mfd "-I\$([lindex $dir 1]) "
	}
	puts $mfd "\n"

	# the "all" target becomes the default
	puts -nonewline $mfd "all :\t\$(TR)\n\n"

	puts -nonewline $mfd "BF="

	foreach fn $SrcLists() {
		puts -nonewline $mfd \
			"\$(TD)/[file rootname [file tail $fn]].asm "
	}

	if { $StubList != "" } {
		foreach fn $StubList {
			puts -nonewline $mfd \
				"\$(TS)/[file rootname $fn].asm "
		}
	}

	puts $mfd "\n"

	# the actual target
	puts $mfd "\$(TR):\t\$(BF)"

	set asmcp [scrloc "move_ecog_asm"]
	puts $mfd "\t$asmcp \$(TD) LIBRARY/asm\n"

	if { $StubList != "" } {
		puts $mfd "\t$asmcp \$(TS) LIBRARY/stubs\n"
	}

	# the list of compileable sources
	foreach sf $SrcLists() {
		set rfn [file tail $sf]
		set suf [file extension $rfn]
		set rna [file rootname $rfn]
		set ofn "${rna}.asm"
		set dir [file dirname $sf]
		set dsh $DirShort($dir)
		puts -nonewline $mfd "\$(TD)/$ofn : \$(${dsh}U)/$rfn"
		# dependencies
		if [info exists Depend($sf)] {
			foreach df $Depend($sf) {
				set rfd [file tail $df]
				set did [file dirname $df]
				puts -nonewline $mfd \
					" \$($IncShort($did)U)/$rfd"
			}
		}
		puts $mfd ""
		puts $mfd "\tmkdir -p \$(TD)"
		if { $suf == ".cc" } {
			# this is a VUEE source, copy it to plain C
			set rfn "${rna}.c"
			puts $mfd "\tcp \$($dsh)/${rfn}c \$(TD)/$rfn"
			set spfx "\$(TD)"
			puts -nonewline $mfd "\t\$(CC) \$(CF) \$(OF) \$(IN)"
		} else {
			set spfx "\$($dsh)"
			if { $suf == ".c" } {
				puts -nonewline $mfd \
					"\t\$(CC) \$(CF) \$(OF) \$(IN)"
			} else {
				errab "illegal source suffix '$sf'"
			}
		}
		puts $mfd " $spfx/$rfn -o \$(TD)/$ofn\n"
	}

	if { $StubList != "" } {
		foreach sf $StubList {
			set rna [file rootname $sf]
			set ofn "${rna}.asm"
			puts $mfd "\$(TS)/$ofn : \$(SDU)/$sf"
			puts $mfd "\tmkdir -p \$(TS)"
			puts -nonewline $mfd "\t\$(CC) \$(CF) \$(OF) \$(IN)"
			puts $mfd " \$(SD)/$sf -o \$(TS)/$ofn\n"
		}
	}

	puts $mfd "\n"

	puts $mfd "clean :\n\trm -rf \$(TD)/*"
	catch { close $mfd }

	catch { file mkdir "LIBRARY/asm" }
	catch { file mkdir "LIBRARY/stubs" }

	foreach ef { "internal.map" "cstartup.asm" "irq.asm" } {
		set fn [lookup $ef ""]
		if { $fn == "" } {
			lappend NotFound $ef
		} else {
			exec cp $fn LIBRARY/asm/
		}
	}

	# copy the includes
	foreach dep [array names Depend] {
		foreach fn $Depend($dep) {
			lappend_unique LIncludes $fn
		}
	}

	foreach fn $LIncludes {
		if [catch { exec cp $fn LIBRARY/include/ } ] {
			errab "cannot copy include file: $fn"
		}
	}
}

proc outmkf { def cpu } {
#
# Output a makefile for MSP430
#
#	IncShort:	array of include directories indexed by paths
#	DirShort:	array of source directories
#	Depend:		array of dependency lists (can be global)
#	SrcLists:	per-target array of files to compile (ToCompile)
#
	global DirShort IncShort SrcLists Depend CWD NotFound Run

	# build a trimmed list of relevant directories
	trimdir

	if [catch { open "Makefile" "w" } mfd] {
		error "cannot open Makefile for writing: $mfd"
	}

	puts $mfd "#\n# Created by mkmk, DO NOT EDIT!!!\n#"
	puts $mfd "CC=msp430-gcc"
	puts $mfd "AS=msp430-as"
	puts $mfd "OC=msp430-objcopy -O ihex"
	puts $mfd "SI=msp430-size -Ax"
	puts -nonewline $mfd "CF=-mmcu=$cpu -mendup-at=main"
	foreach sht $def {
		puts -nonewline $mfd " -D$sht"
	}
	puts $mfd ""
	puts $mfd "AF=-mmcu=$cpu"
	puts $mfd "OF=-O2 -g -Wundef"
	puts $mfd "TR=Image"
	puts $mfd "TD=./KTMP"

	if [islibrun] {
		puts $mfd "LI=-I[file join $Run(library) include]"
		puts $mfd "LD=-L$Run(library) -lpicos"
	} else {
		puts $mfd "LD="
		puts $mfd "LI="
	}

	# output the list of directories
	puts $mfd "# include directories"
	set idirs ""
	foreach { dir sht } [array get IncShort] {
		lappend idirs [list $dir $sht]
	}
	set idirs [lsort -index 1 $idirs]
	foreach dir $idirs {
		set fna [lindex $dir 0]
		set tag [lindex $dir 1]
		puts $mfd "$tag=$fna"
		if { $Run(DNM) == 1 } {
			# canonical names are DOS-style
			puts $mfd "${tag}U=[uxname $fna]"
		}
	}
	puts $mfd "# source directories"

	set sdirs ""
	foreach { dir sht } [array get DirShort] {
		lappend sdirs [list $dir $sht]
	}
	set sdirs [lsort -index 1 $sdirs]
	foreach dir $sdirs {
		set fna [lindex $dir 0]
		set tag [lindex $dir 1]
		puts $mfd "$tag=$fna"
		if { $Run(DNM) == 1 } {
			# canonical names are DOS-style
			puts $mfd "${tag}U=[uxname $fna]"
		}
	}
	puts $mfd "#"

	puts -nonewline $mfd "IN="
	foreach dir $idirs {
		puts -nonewline $mfd "-I \$([lindex $dir 1]) "
	}
	puts $mfd "\n"

	# target names
	set tnames [lsort [array names SrcLists]]

	# the "all" target becomes the default
	puts -nonewline $mfd "all :	"

	if { [llength $tnames] == 1 && [lindex $tnames 0] == "" } {
		# Single simple target
		puts $mfd "\$(TR)\n"
	} else {
		foreach tar $tnames {
			if { $tar == "" } {
				# this will not happen
				errab "illegal default target"
			}
			puts -nonewline $mfd "$tar "
		}
		puts $mfd "\n"
	
		foreach tar $tnames {
			puts $mfd "$tar :\t\$(TR)_$tar\n"
		}
		puts $mfd "\n"
	}

	array unset tgts

	# the discriminator between UNIX and DOS path names
	if { $Run(DNM) == 1 } {
		set U "U"
	} else {
		set U ""
	}

	foreach tar $tnames {
		# we do this for every target
		puts $mfd "# target: \"$tar\""
		if { $tar != "" } {
			set tarn "_$tar"
		} else {
			set tarn ""
		}
		# names the list of binary files comprising the target
		puts -nonewline $mfd "BF${tarn}="
		foreach fn $SrcLists($tar) {
			puts -nonewline $mfd \
				"\$(TD)/[file rootname [file tail $fn]].o "
		}
		puts $mfd "\n"

		# the actual target
		puts $mfd "\$(TR)$tarn :\t\$(BF$tarn)"
		puts $mfd "\t\$(CC) -o \$(TR)$tarn \$(CF) \$(BF$tarn) \$(LD)"
		puts $mfd "\t\$(OC) \$(TR)$tarn \$(TR)${tarn}.a43"
		puts $mfd "\t\$(SI) \$(TR)$tarn\n"

		# the list of compileable sources
		foreach sf $SrcLists($tar) {
			set rfn [file tail $sf]
			set suf [file extension $rfn]
			set rna [file rootname $rfn]
			if [info exists tgts($rna)] {
				# already present
				continue
			}
			set tgts($rna) ""
			set ofn "${rna}.o"
			set dir [file dirname $sf]
			set dsh $DirShort($dir)

			puts -nonewline $mfd "\$(TD)/$ofn : \$($dsh$U)/$rfn"
			# dependencies
			if [info exists Depend($sf)] {
				foreach df $Depend($sf) {
					set rfd [file tail $df]
					set did [file dirname $df]
					puts -nonewline $mfd \
						" \$($IncShort($did)$U)/$rfd"
				}
			}
			puts $mfd ""
			puts $mfd "\tmkdir -p \$(TD)"
			if { $suf == ".cc" } {
				# this is a VUEE source, copy it to plain C
				set rfn "${rna}.c"
				puts $mfd "\tcp \$($dsh$U)/${rfn}c \$(TD)/$rfn"
				set spfx "\$(TD)"
				puts -nonewline $mfd \
					"\t\$(CC) \$(CF) \$(OF) \$(LI) \$(IN)"
			} else {
				set spfx "\$($dsh)"
				if { $suf == ".c" } {
					puts -nonewline $mfd \
					  "\t\$(CC) \$(CF) \$(OF) \$(LI) \$(IN)"
				} elseif { [string first ".a" $suf] == 0 } {
					puts -nonewline $mfd \
						"\t\$(AS) \$(AF) \$(LI) \$(IN)"
				} else {
					errab "illegal source suffix '$sf'"
				}
			}
			puts $mfd " -c $spfx/$rfn -o \$(TD)/$ofn\n"
		}
		puts $mfd "\n"
	}

	puts $mfd "clean :\n\trm -rf \$(TD)/*"
	catch { close $mfd }
	# output the gdb.ini file
	set    gdbi "set remoteaddresssize 64\n"
	append gdbi "set remotetimeout 999999\n"
	append gdbi "target remote localhost:2000\n"
	foreach fn { ".gdbinit" "gdb.ini" } {
		exec cat > $fn << $gdbi
	}
}

proc outmkf_lib { def cpu } {
#
# Output a makefile for lib run of MSP430
#
#	IncShort:	array of include directories indexed by paths
#	DirShort:	array of source directories
#	Depend:		array of dependency lists (can be global)
#	SrcLists:	per-target array of files to compile (ToCompile)
#
	global DirShort IncShort SrcLists Depend CWD NotFound LIncludes Run

	# build a trimmed list of relevant directories
	trimdir

	if [catch { open "Makefile" "w" } mfd] {
		error "cannot open Makefile for writing: $mfd"
	}

	puts $mfd "#\n# Created by mkmk, DO NOT EDIT!!!\n#"
	puts $mfd "CC=msp430-gcc"
	puts $mfd "AS=msp430-as"
	puts $mfd "AR=msp430-ar"
	puts $mfd "RL=msp430-ranlib"
	puts $mfd "RM=rm"
	puts -nonewline $mfd "CF=-mmcu=$cpu -mendup-at=main"
	foreach sht $def {
		puts -nonewline $mfd " -D$sht"
	}
	puts $mfd ""
	puts $mfd "AF=-mmcu=$cpu"
	puts $mfd "OF=-O2 -g -Wundef"
	puts $mfd "TR=LIBRARY/libpicos.a"
	puts $mfd "TD=./KTMP"

	# output the list of directories
	puts $mfd "# include directories"
	set idirs ""
	foreach { dir sht } [array get IncShort] {
		lappend idirs [list $dir $sht]
	}
	set idirs [lsort -index 1 $idirs]
	foreach dir $idirs {
		set fna [lindex $dir 0]
		set tag [lindex $dir 1]
		puts $mfd "$tag=$fna"
		if { $Run(DNM) == 1 } {
			# canonical names are DOS-style
			puts $mfd "${tag}U=[uxname $fna]"
		}
	}
	puts $mfd "# source directories"

	set sdirs ""
	foreach { dir sht } [array get DirShort] {
		lappend sdirs [list $dir $sht]
	}
	set sdirs [lsort -index 1 $sdirs]
	foreach dir $sdirs {
		set fna [lindex $dir 0]
		set tag [lindex $dir 1]
		puts $mfd "$tag=$fna"
		if { $Run(DNM) == 1 } {
			# canonical names are DOS-style
			puts $mfd "${tag}U=[uxname $fna]"
		}
	}
	puts $mfd "#"

	puts -nonewline $mfd "IN="
	foreach dir $idirs {
		puts -nonewline $mfd "-I \$([lindex $dir 1]) "
	}
	puts $mfd "\n"

	# the "all" target becomes the default
	puts -nonewline $mfd "all :\t\$(TR)\n"

	puts -nonewline $mfd "BF="

	foreach fn $SrcLists() {
		puts -nonewline $mfd "\$(TD)/[file rootname [file tail $fn]].o "
	}
	puts $mfd "\n"

	# the actual target
	puts $mfd "\$(TR):\t\$(BF)"
	puts $mfd "\trm -rf \$(TR)"
	puts $mfd "\t\$(AR) q \$(TR) \$(BF)"
	puts $mfd "\t\$(RL) \$(TR)"

	# the discriminator between UNIX and DOS path names
	if { $Run(DNM) == 1 } {
		set U "U"
	} else {
		set U ""
	}

	# the list of compileable sources
	foreach sf $SrcLists() {
		set rfn [file tail $sf]
		set suf [file extension $rfn]
		set rna [file rootname $rfn]
		set ofn "${rna}.o"
		set dir [file dirname $sf]
		set dsh $DirShort($dir)
		puts -nonewline $mfd "\$(TD)/$ofn : \$($dsh$U)/$rfn"
		# dependencies
		if [info exists Depend($sf)] {
			foreach df $Depend($sf) {
				set rfd [file tail $df]
				set did [file dirname $df]
				puts -nonewline $mfd \
					" \$($IncShort($did)$U)/$rfd"
			}
		}
		puts $mfd ""
		puts $mfd "\tmkdir -p \$(TD)"
		if { $suf == ".cc" } {
			# this is a VUEE source, copy it to plain C
			set rfn "${rna}.c"
			puts $mfd "\tcp \$($dsh$U)/${rfn}c \$(TD)/$rfn"
			set spfx "\$(TD)"
			puts -nonewline $mfd "\t\$(CC) \$(CF) \$(OF) \$(IN)"
		} else {
			set spfx "\$($dsh)"
			if { $suf == ".c" } {
				puts -nonewline $mfd \
					"\t\$(CC) \$(CF) \$(OF) \$(IN)"
			} elseif { [string first ".a" $suf] == 0 } {
				puts -nonewline $mfd \
					"\t\$(AS) \$(AF) \$(IN)"
			} else {
				errab "illegal source suffix '$sf'"
			}
		}
		puts $mfd " -c $spfx/$rfn -o \$(TD)/$ofn\n"
	}
	puts $mfd "\n"

	puts $mfd "clean :\n\trm -rf \$(TD)/*"
	catch { close $mfd }

	# copy the includes
	foreach dep [array names Depend] {
		foreach fn $Depend($dep) {
			lappend_unique LIncludes $fn
		}
	}

	foreach fn $LIncludes {
		if [catch { exec cp $fn LIBRARY/include/ } ] {
			errab "cannot copy include file: $fn"
		}
	}
}

proc uxname { fn } {
#
# Convert Windows file name to UNIX
#
	global Run

	if [regexp -nocase "^(\[A-Z\]):" $fn junk DP] {
		# DOS filename prefix
		set cn [string first "/home/" $fn]
		if { $cn > 0 } {
			# this is inside our Cygwin home
			set fn [string range $fn $cn end]
		} else {
			set fn "/cygdrive/$DP[string range $fn 2 end]"
		}
	}
	return $fn
}

proc canon { fnf } {
#
# Normalize file name
#
	global Run

	if [catch { file normalize $fnf } fn] {
		set fn $fnf
	}
	if { $Run(mode) != "E" && !$Run(DNM) } {
		# canonical names are UNIX style
		set fn [uxname $fn]
	}
	return $fn
}

proc rootpf { } {
#
# Find the root prefix for all directories, i.e., PICOS, as the one containing
# "Apps"
#
	global CWD RPREF

	set RPREF $CWD
	set dlist ""

	while { [file tail $RPREF] != "Apps" } {
		set tmp [file dirname $RPREF]
		if { $tmp == $RPREF } {
			errab "path to current directory contains no \"Apps\""
		}
		set RPREF $tmp
	}
	set RPREF [file dirname $RPREF]

	# get the last release tag

	if [catch { open [file join $RPREF "RTAGS"] "r" } fd] {
		puts "cannot open RTAGS"
		return "uknown"
	}

	if [catch { read $fd } rtf] {
		puts "cannot read RTAGS"
		catch { close $fd }
		return "unknown"
	}

	catch { close $fd }

	# the last RTAG
	if ![regexp -nocase ".*\n(R\[0-9A-Z\]+):" $rtf fd rtag] {
		set rtag "unknown"
	}

	# version number
	if ![regexp -nocase \
	    ".*\nR\[0-9A-Z\]+:\[ \t\]*(\[0-9\]+)\[ \t\]+(\[0-9\]+)" $rtf fd \
		maj min] {

		set maj 0
		set min 0
	}

	puts "PicOS version ${maj}.${min}, release $rtag"

	return [list "SYSVER_U=$maj" "SYSVER_L=$min" "SYSVER_T=$rtag"]
}

proc lboard { tgt } {
#
# Locate the board directory
#
	global RPREF Run DirList Targets Flags
	upvar $tgt target

	set nof 1
	foreach dir $DirList {
		if [regexp "/BOARDS$" $dir] {
			set nof 0
			break
		}
	}

	if $nof {
		errab "DirList is broken: BOARDS not found"
	}

	foreach tar $Targets {
		set target [lindex $tar 0]
		# try each in turn until you find the right board
		regsub "@TARGET@" $dir $target tdir
		set pard [file join $RPREF $tdir $Run(board)]
		set uprd [uxname $pard]
		if ![file isdirectory $uprd] {
			continue
		}
		# we have found the target
		set Run(bdir) $pard
		set uprd [file join $uprd "params.sys"]
		set Run(mode) [lindex $tar 1]
		if [catch { open $uprd "r" } pfd] {
			# no parameters, use defaults
			set Flags [lindex $tar 2]
			return
		}
		# params file present, read it
		if [catch { read $pfd } Flags] {
			catch { close $pfd }
			error "cannot read '$uprd'"
		}
		catch { close $pfd }
		#
		# this consists of lines in the format:
		#	-x param
		# exceptionally, the CPU ID may appear without -c
		#
		set Flags [string trim $Flags]
		if { $Flags == "" } {
			set Flags [lindex $tar 2]
		}
		set Flags [split $Flags "\n"]
		return
	}

	errab "board '$Run(board)' not found"
}

proc dboard { tgt } {
#
# Locate the default board
#
	global RPREF Run DirList Targets Flags
	upvar $tgt TGT

	set nof 1
	foreach dir $DirList {
		if [regexp "/BOARDS$" $dir] {
			set nof 0
			break
		}
	}

	if $nof {
		errab "DirList is broken: BOARDS not found"
	}

	set bfi ""

	foreach tar $Targets {
		set target [lindex $tar 0]
		regsub "@TARGET@" $dir $target tdir
		set pard [file join $RPREF $tdir]
		set uprd [uxname $pard]
		if ![file isdirectory $uprd] {
			continue
		}
		if [catch { exec ls $uprd } bli] {
			continue
		}

		set ble [lsearch -exact $bli "CVS"]
		if { $ble >= 0 } {
			set bli [lreplace $bli $ble $ble]
		}

		set ble [llength $bli]
		if { $ble == 0 } {
			continue
		}

		if { $bfi != "" || $ble > 1 } {
			# too much
			errab "More than one board to choose from, board name\
				required"
		}

		set bfi [lindex $bli 0]
		set bta $tar
		set btd $tdir
	}

	if { $bfi == "" } {
		errab "No boards configured"
	}

	set Run(board) $bfi
	set pard [file join $RPREF $btd $Run(board)]
	set uprd [uxname $pard]
	if ![file isdirectory $uprd] {
		errab "Cannot access board directory $bfi ($pard)"
	}

	if [file isdirectory [file join $uprd LIBRARY]] {
		# library present
		set lif 1
	} else {
		set lif 0
	}

	set TGT [lindex $bta 0]
	# board directory
	set Run(bdir) $pard
	set uprd [file join $uprd "params.sys"]
	set Run(mode) [lindex $bta 1]
	if [catch { open $uprd "r" } pfd] {
		# no parameters, use defaults
		set Flags [lindex $bta 2]
		return $lif
	}
	# params file present, read it
	if [catch { read $pfd } Flags] {
		catch { close $pfd }
		error "cannot read '$pard'"
	}
	catch { close $pfd }
	set Flags [string trim $Flags]
	if { $Flags == "" } {
		set Flags [lindex $bta 2]
	}
	set Flags [split $Flags "\n"]
	return $lif
}
		
proc mkdlist { cpu } {
#
# Create the complete canonical list of directories to be searched
#
	global PDirList DirList DLIST CWD RPREF MKRECV Run

	# working copy of the target list
	set DLIST ""
	set PDirList ""

	foreach p $DirList {
		set target [regsub -all "@TARGET@" $p $cpu p]
		if [regexp "/BOARDS$" $p] {
			# insert the proper board directory
			set p "${p}/$Run(board)"
		} elseif [regexp {/\*$} $p] {
			# wildcard means all subdirectories (recursively)
			set p [string range $p 0 end-2]
			if { $p != "." } {
				set p [file join $RPREF $p]
			}
			set p [canon $p]
			mkdrec $p
			foreach p [lsort [array names MKRECV]] {
				lappend_unique DLIST $p
			}
			array unset MKRECV
			continue
		}
		# just this directory
		if { $p != "." } {
			set p [canon [file join $RPREF $p]]
			if { $PDirList != "" } {
				# local directories, i.e., subdirs of .
				lappend_unique PDirList $p
			}
		} else {
			set p [canon $p]
			# first one considered local
			lappend PDirList $p
		}
		set p [canon $p]
		lappend_unique DLIST $p
	}

	# Replace the original patterns
	set DirList $DLIST
	dmp "DLIST: $DirList"
	unset DLIST
}

proc mkdrec { dname } {
#
# Add all subdirectories of the indicated directory (in alphabetical order)
#
	global MKRECV

	if [catch { exec ls $dname } sdl] {
		# doesn't exist
		return
	}
	
	foreach f [exec ls $dname] {
		if [regexp -nocase "attic|junk" $f] {
			# ignore oldies and garbage
			continue
		}
		if [regexp "\\~\\$" $f] {
			# ignore exotic filenames (cause problems on Windows)
			continue
		}
		set ff [canon [file join $dname $f]]
		if { $ff == "" } {
			continue
		}
		if [info exists MKRECV($ff)] {
			# avoid link loops
			continue
		}
		if [file isdirectory $ff] {
			set MKRECV($ff) ""
			mkdrec $ff
		}
	}
}

proc needlist { ar fname } {
#
# Returns the list of files from "//+++". The argument is the piece of line
# past the +++ string.
#
	set fl ""
	while 1 {
		set ar [string trim $ar]
		if { $ar == "" } {
			break
		}
		set del [string index $ar 0]
		if { $del == "\"" } {
			if ![regexp "\"(\[^ \t\"]+\\.(c|asm?))\"" $ar jk nfn] {
				# we don't understand this
				puts stdout \
				"Warning: '//+++' syntax error: '$ar' in $fname"
				break
			}
		} elseif { $del == "<" } {
			if ![regexp "<(\[^ \t<>]+\\.(c|asm?))>" $ar jk nfn] {
				puts stdout \
				"Warning: '//+++' syntax error: '$ar' in $fname"
				break
			}
		} else {
			if ![regexp "\[^ \t]+\\.(c|asm?)" $ar jk] {
				puts stdout \
				"Warning: '//+++' syntax error: '$ar' in $fname"
				break
			} else {
				set nfn $jk
			}
		}

		set cm [string first $jk $ar]

		if { $cm < 0 } {
			# impossible
			set ar ""
		} else {
			set ar [string range $ar [expr $cm + \
				[string length $jk]] end]
		}

		lappend fl $nfn
	}

	return $fl
}

proc lookup { fn prefdir } {
#
# Lookup the given file, prefdir is prefered directory, returns the
# complete path
#
	global DirList

	foreach dir [concat [list $prefdir] $DirList] {
		if { $dir == "" } {
			continue
		}
		set ffn [canon [file join $dir $fn]]
		if [file isfile $ffn] {
			return $ffn
		}
	}

	return ""
}

proc llookup { fn prefdir } {
#
# Lookup the given file in local directory or globally, depending whether
# we are in library mode or not
#
	global DirList PDirList Run

	if [islibrun] {
		set pd $PDirList
	} else {
		set pd $DirList
	}

	foreach dir [concat [list $prefdir] $pd] {
		if { $dir == "" } {
			continue
		}
		set ffn [canon [file join $dir $fn]]
		if [file isfile $ffn] {
			return $ffn
		}
	}

	return ""
}

proc scrloc { fn } {
#
# Locate a script in PicOS script library

	global RPREF

	set fn [file join $RPREF "Scripts" $fn]
	if ![file exists $fn] {
		errab "cannot locate $fn script"
	}

	return [uxname $fn]
}

proc sexpr { str } {
#
# Evaluates naive IF conditions
#
	global Symbols

	if [info exists Symbols(mkmk_eval)] {
		# do not evaluate
		set es $Symbols(mkmk_eval)
		if { $es == "" } {
			set es 0
		}
		if [catch { expr $es } es] {
			set es 0
		}
		if { $es == 0 } {
			return 0
		}
		return 1
	}

	set es [string first "//" $str]
	set ps [string first "/*" $str]
	set sl [string length $str]

	if { $es < 0 } {
		set es $sl
	}
	if { $ps < 0 } {
		set ps $sl
	}
	if { $es < $ps } {
		set ps $es
	}
	# eliminate any trailing comments
	set str [string trim [string range $str 0 [expr $ps - 1]]]
	if { $str == "" } {
		return -1
	}

	set cond ""

	while { $str != "" } {
		set es [string first "&&" $str]
		if { $es < 0 } {
			set es [string first "||" $str]
			if { $es >= 0 } {
				if { $cond == "A" } {
					# too complicated
					return -1
				}
				set cond "O"
			}
		} else {
			if { $cond == "O" } {
				return -1
			}
			set cond "A"
		}

		if { $es < 0 } {
			set chunk $str
			set str ""
		} else {
			set chunk [string range $str 0 [expr $es - 1]]
			set str [string trim [string range $str [expr $es + 2] \
				end]]
			if { $str == "" } {
				return -1
			}
		}
		set chunk [string trim $chunk]
		# I don't believe I am doing this
		set chunk [string trimleft $chunk "("]
		set chunk [string trimright $chunk ")"]
		if { $chunk == "" } {
			return -1
		}

		dmp "EXPR COMP: '$chunk'"

		if ![regexp -nocase \
		"^(\[a-z_0-9.\]+)\[ \t\]*(\[=<>!&|\]+)\[ \t\]*(\[a-z_0-9.\]+)$"\
		    $chunk junk a0 op a1] {
			# check for a single item
			set neg ""
			if ![regexp -nocase "^(!\[ \t\]*)?(\[a-z_0-9.\]+)$"\
			    $chunk jk neg a0] {
				# we don't understand this
				dmp "EXPR: '$chunk' (unrecognized)"
				return -1
			}
			if [catch { expr $a0 } v0] {
				set v0 0
				set lc 0
				while { [info exists Symbols($a0)] } {
					if [catch { expr $Symbols($a0) } v0] {
						incr lc
						if { $Symbols($a0) == "" || \
						    $lc > 16 } {
							set v0 0
							break
						}
						set a0 $Symbols($a0)
					} else {
						break
					}
				}
			}
			if { $v0 != 0 } {
				set v0 1
			}
			if { $neg != "" } {
				set v0 [expr ($v0 == 0)]
			}

		} else {
			# obtain the values
			dmp "EXPR COMP: $a0 $op $a1"
			if [catch { expr $a0 } v0] {
				# not an expression
				set v0 ""
				set lc 0
				while { [info exists Symbols($a0)] } {
					if [catch { expr $Symbols($a0) } v0] {
						incr lc
						set v0 ""
						if { $Symbols($a0) == "" || \
						    $lc  > 16 } {
							break
						}
						set a0 $Symbols($a0)
					} else {
						break
					}
				}
			}
			if [catch { expr $a1 } v1] {
				# not an expression
				set v1 ""
				set lc 0
				while { [info exists Symbols($a1)] } {
					if [catch { expr $Symbols($a1) } v1] {
						incr lc
						set v1 ""
						if { $Symbols($a1) == "" || \
						    $lc > 16 } {
							break
						}
						set a1 $Symbols($a1)
					} else {
						break
					}
				}
			}
			if { $v0 == "" || $v1 == "" } {
				# we don't understand this
				dmp "EXPR COMP: '$v0' $op '$v1' (unrecognized)"
				return -1
			}

			switch $op {
		  	"==" { set v0 [expr $v0 == $v1] }
		  	"<"  { set v0 [expr $v0 <  $v1] }
		  	">"  { set v0 [expr $v0 >  $v1] }
		  	"<=" { set v0 [expr $v0 <= $v1] }
		  	">=" { set v0 [expr $v0 >= $v1] }
		  	"!=" { set v0 [expr $v0 != $v1] }
		  	"&"  { set v0 [expr $v0 & $v1] }
		  	"|"  { set v0 [expr $v0 | $v1] }
		  	default { set v0 -1 }
			}
	
			if { $v0 < 0 } {
				# we don't understand this
				dmp "EXPR COMP: $op (unrecognized)"
				return -1
			}
		}

		if $v0 {
			if { $cond == "O" || $str == "" } {
				return 1
			}
		} else {
			if { $cond == "A" || $str == "" } {
				return 0
			}
		}
	}

	return 0
}

proc scanfile { fname } {

	global FList Depend Symbols Scanned NotFound ToCompile CFName Run

	dmp "SCANNING: $fname"

	if [info exists Scanned($fname)] {
		return
	}

	set Scanned($fname) ""

	if [catch { open $fname "r" } fd] {
		error "cannot open file '$fname': $fd"
	}

	set ifnest 0
	# assume that the entire file is encapsulated in a dummy if at level
	# zero, which is being totally ignored
	#
	# Flags:
	#
	#	0	- ignore, i.e., both parts should be scanned
	#	1	- accepting the current part
	#	2	- skipping the current part, waiting for else or endif
	#	3	- skipping both parts because the outer if is being
	#		  skipped
	#

	set ifstack($ifnest) "0"

	while 1 {

		if { [gets $fd line] < 0 } {
			if { $ifnest > 0 } {
				puts stdout "Warning: #endif missing in $fname"
			}
			break
		}

		if { $ifstack($ifnest) <= 1 && \
		    [regexp "^\[ \t\]*//\\+\\+\\+(.*)" $line jk ar] } {
			# needed files
			set ar [needlist $ar $fname]
			foreach nfn $ar {
				set dnn [file dirname $fname]
				set fn [llookup $nfn $dnn]
				if { $fn == "" &&
				    [file extension $nfn] == ".c" } {
					# try ".cc"
					set fn [llookup \
					  "[file rootname $nfn].cc" $dnn]
				}

				dmp "NEEDED: $nfn"
				if { $fn == "" } {
					dmp "NEEDED: $nfn not found"
					if ![islibrun] {
						# no warning if library mode
						lappend_unique NotFound $nfn
					}
				} else {
					dmp "NEEDED: $nfn added to compile"
					lappend_toc ToCompile $fn
				}
			}
			continue
		}

		if ![regexp "^\[ \t\]*#(\[a-z\]+)\[ \t\]*(.*)" $line jk cm ar] {
			continue
		}

		if { $cm == "if" || $cm == "ifdef" || $cm == "ifndef" } {
			dmp "IF: $ifnest, $ifstack($ifnest): '$line'"
			if { $ifstack($ifnest) > 1 } {
				# we are skipping an outer if, so we should
				# skip this one entirely
				incr ifnest
				set ifstack($ifnest) 3
				dmp "IF(S): $ifstack($ifnest)"
				continue
			}
			incr ifnest
			if { $cm == "ifdef" || $cm == "ifndef" } {
				if ![regexp -nocase "^\[a-z_0-9.\]+" $ar nam] {
					# illegal
					set ifstack($ifnest) 0
					continue
				}
				if [info exists Symbols($nam)] {
					dmp "SYMBOL: $nam, value $Symbols($nam)"
					if { $cm == "ifdef" } {
						set ifstack($ifnest) 1
					} else {
						set ifstack($ifnest) 2
					}
				} else {
					if { $cm == "ifdef" } {
						set ifstack($ifnest) 2
					} else {
						set ifstack($ifnest) 1
					}
				}
				dmp "IF\[N\]DEF: $ifstack($ifnest)"
				continue
			}
			# we only handle here extremely simple conditions
			set val [sexpr $ar]
			if { $val < 0 } {
		puts stdout "Warning: failed to evaluate: '$ar' in $fname"
				set val 0
			}
			if $val {
				set ifstack($ifnest) 1
			} else {
				set ifstack($ifnest) 2
			}
			dmp "IF (done) $ifstack($ifnest)"
			continue
		}

		if { $cm == "else" } {
			if { $ifnest < 1 } {
			    puts stdout "Warning: extraneous #else in $fname"
			    continue
			}
			if { $ifstack($ifnest) == 1 } {
				set ifstack($ifnest) 2
			} elseif { $ifstack($ifnest) == 2 } {
				set ifstack($ifnest) 1
			}
			dmp "ELSE: $ifstack($ifnest)"
			continue
		}

		if { $cm == "endif" } {
			if { $ifnest > 0 } {
				incr ifnest -1
			} else {
			    puts stdout "Warning: extraneous #endif in $fname"
			}
			dmp "ENDIF: $ifnest, $ifstack($ifnest)"
			continue
		}

		if { $ifstack($ifnest) > 1 } {
			continue
		}

		if { $cm == "define" } {
			set nam ""
			if ![regexp -nocase "^(\[a-z_0-9.\]+)(\[ \t\]+(.*))?" \
			    $ar jk kwd jk nam] {
				dmp "DEFINE: $ar (ignored)"
				continue
			}
			if { ![regexp -nocase "^\[a-z_0-9.\]+" $nam nam] &&
			     ![regexp -nocase "^\"\[a-z_0-9.\]+\"" $nam nam] } {
				set v0 "@@@"
			} else {
				if [catch { expr $nam } v0] {
					if [info exists Symbols($nam)] {
						set v0 $Symbols($nam)
					} else {
						set v0 $nam
					}
				}
			}
			set Symbols($kwd) $v0
			dmp "DEFINE: $kwd $v0"
			continue
		}

		if { $cm == "undef" } {
			if ![regexp -nocase "^\[a-z_0-9.\]+" $ar kwd] {
				dmp "UNDEF: $ar (ignored)"
				continue
			}
			if [info exists Symbols($kwd)] {
				unset Symbols($kwd)
			}
			dmp "UNDEF: $kwd"
			continue
		}

		if { $cm == "include" } {
			if ![regexp -nocase "\[\"<\](\[^\"><\]+)\[\">\]" $ar \
			    jk fn] {
				# the file name to include may be a symbol
				if ![regexp -nocase "^\[ \t\]*(\[a-z_0-9.\]+)" \
				    $ar jk fn] {
					# unrecognizable
					dmp "INCLUDE: $fn '$line' (UNREC)"
					continue
				}
				# try the symbol
				if ![info exists Symbols($fn)] {
					dmp "INCLUDE: $fn '$line' (NOSYMBOL)"
					continue
				}
				set fn [string trim $Symbols($fn) "\"<>"]
				dmp "INCLUDE: SYM $fn '$line'"
			}
			set fn [string trim $fn]
			if { $fn == "" } {
				continue
			}
			dmp "INCLUDE: $fn '$line'"
			set fn [llookup $fn [file dirname $fname]]
			if { $fn != "" } {
				scanfile $fn
				lappend_unique Depend($CFName) $fn
				dmp "SCANNING (BACK): $fname"
			} else {
				dmp "INCLUDE: $fn not found"
			}
		}
	}
	catch { close $fd }
}

proc bad_usage { } {

	puts stderr "Usage: mkmk \[boardname \[-m|-l|-p]]"
	puts stderr "       mkmk boardname \[-M|-P \[libdir]]"
	exit 1
}

proc getflag { fg } {

	global Flags

	set m "-$fg"
	set par ""
	foreach f $Flags {
		set f [string trim $f]
		if { $f == "" } {
			continue
		}
		if [regexp "^${m}(.*)" $f junk par] {
			set o 1
			break
		}
		if { $fg == "c" && [string index $f 0] != "-" } {
			set par $f
			break
		}
	}

	return [string trim $par]
}

proc ifnotcygwin { } {
#
# Checks if mspgcc operates in the cygwin environment, i.e., using cygwin DLLs.
# This tells us whether the compiler accepts UNIX-like file names or not.
#
	if [catch { exec which msp430-gcc } p] {
	    	puts stdout "Warning: cannot determine mspgcc installation\
			type, assuming DOS-type file paths"
		return 1
	}

	set p [file dirname $p]

	if [catch { exec ls $p } p] {
		puts stdout "Warning: cannot inspect mspgcc installation,\
			assuming DOS-type file paths"
		return 1
	}

	if { [lsearch -glob $p "cyg*"] >= 0 } {
		puts stdout "Detected cygwin environment for mspgcc"
		return 0
	}

	if { [lsearch $p "msp430-gcc.exe"] >= 0 } {
		puts stdout "Detected Windows native environment for mspgcc"
		return 1
	}

	puts stdout "Detected Linux environment for mspgcc"
	return 2
}

proc main { } {

	global argv ToCompile NotFound CWD Run Symbols Scanned CFName SrcLists
	global LIncludes

	set ll [llength $argv]

	set CWD [pwd]

	# locate the root directory prefix
	set deflist [rootpf]

	# make type: default = makefile
	set Run(type) "m"

	if { $ll == 0 || [string index [lindex $argv 0] 0] == "-" } {
		# no board name; figure out if there is a single board
		# if we return, things are OK: Run(board) has been set
		if [dboard TGT] {
			# forced library flag (LIBRARY present)
			if { $ll == 0 } {
				set ll 1
				set argv "-M"
			}
		}
	} else {
		# get the board
		set Run(board) [lindex $argv 0]
		# and move it out of the way
		set argv [lrange $argv 1 end]
		incr ll -1
		lboard TGT
	}

	if { $Run(mode) == "E" } {
		# this can only be on Windows
		set Run(DNM) 1
	} else {
		# DOS-name mode if not cygwin
		set Run(DNM) [ifnotcygwin]
	}

	set mcpu [getflag "c"]
	set RPREF [canon RPREF]
	set CWD [canon $CWD]
	set Run(bdir) [canon $Run(bdir)]

	if $ll {
		# mode flag
		set lf [lindex $argv 0]
		incr ll -1
		set argv [lrange $argv 1 end]

		# library, makefile, project
		if ![regexp "^-\[lmpMP\]" $lf] {
			bad_usage
		}

		if { $lf == "-M" || $lf == "-P" } {
			# generate a makefile or project with library
			if $ll {
				set Run(library) [lindex $argv 0]
				set argv [lrange $argv 1 end]
				incr ll -1
			} else {
				# look it up in the board directory
				set mf [file join $Run(bdir) LIBRARY]
				if ![file isdirectory [uxname $mf]] {
					errab "No LIBRARY found in $Run(bdir)"
				}
				set Run(library) $mf
			}
		}
		set Run(type) [string index $lf 1]
	}

	if $ll {
		bad_usage
	}

	# cleanup
	catch { exec rm -rf "*.cyp" "*.cyw" "*.lif" "Makefile" "KTMP" \
			"out" "temp" "internal.map" "cstartup.asm" "irq.asm" \
				"LIBRARY" ".gdbinit" "gdb.ini" }

	if { $Run(mode) == "E" } {
		catch { file mkdir "out" "temp" }
	} else {
		catch { file mkdir "KTMP" }
	}

	mkdlist $TGT

	set sufflist ""
	set empsuff 0
	set rootsuff ".c"
	set NotFound ""

	lappend deflist "BOARD_$Run(board)"
	lappend deflist "BOARD_TYPE=$Run(board)"

	if { $Run(type) == "l" } {
		# library run
		set iflist [getflag "l"]
		if { $iflist == "" } {
			errab "board defines no files for library run"
		}
		set ToCompile ""
		set LIncludes ""
		while 1 {
			set iflist [string trim $iflist]
			if ![regexp "^(\[^ \t\]+)" $iflist f] {
				break
			}

			set nf [lookup $f ""]
			if { $nf == "" } {
				# not found
				lappend_unique NotFound $f
			} elseif { [file extension $nf] == ".h" } {
				# extra includes
				lappend_toc LIncludes $nf
			} else {
				lappend_toc ToCompile $nf
			}
			set f [string length $f]
			set iflist [string range $iflist $f end]
		}

		if { $NotFound != "" } {
			puts "Library sources not found:"
			foreach fn $NotFound {
				puts -nonewline stdout "$fn "
			}
			puts stdout ""
			exit 1
		}

		if { $ToCompile == "" } {
			errab \
			    "no library files to compile, check board's params"
		}

		set suffix ""
		array unset Processed
		set ScrLists($suffix) ""

		while { $ToCompile != "" } {
			set CFName [lindex $ToCompile 0]
			set ToCompile [lrange $ToCompile 1 end]
			if [info exists Processed($CFName)] {
				continue
			}
			set Processed($CFName) ""
			lappend_toc SrcLists($suffix) $CFName
			# predefine symbols
			set Symbols(BOARD_$Run(board)) "@@@"
			if { $Run(mode) == "E" } {
				set Symbols(__ECOG__) "@@@"
			} else {
				set Symbols(__MSP430__) "@@@"
			}
			scanfile $CFName
			array unset Symbols
			array unset Scanned
		}

		array unset Processed
		array unset ToCompile

		dmp "TO COMPILE \[$suffix\]: '$SrcLists($suffix)'"

		catch { file mkdir "LIBRARY" }
		catch { file mkdir "LIBRARY/include" }

		if { $Run(mode) == "M" } {
			lappend deflist "__MSP430__"
			outmkf_lib $deflist $mcpu
		} else {
			lappend deflist "__ECOG__"
			outmkfc_lib $deflist
		}

	} else {
		# -m, -p, -M, -P
		# We expect to find app.c in the current directory
		set fn [canon [file join $CWD "app.c"]]
		if ![file isfile $fn] {
			dmp "app.c not found, trying app_xxx.cc"
			# try to locate all files that look like "app_xxx.cc",
			# where xxx has no _. This will mean that we have
			# possibly multiple VUEE-like setups.
			if [catch { exec ls $CWD } flist] {
				errab "cannot scan current directory: $flist"
			}
			foreach fn $flist {
	
				if { $fn == "app.cc" } {
					# there should be only one file like
					# this, i.e., no app_xxx.cc files, but
					# keep looking for consistency
					set empsuff 1
				} elseif [regexp "^app_(\[^_.\]+)\\.cc$" $fn \
				    jnk suff] {
					lappend sufflist $suff
				}
			}
	
			if { $empsuff && $sufflist != "" } {
				errab \
				   "app.cc cannot coexist with app_xxx.cc files"
			}
	
			if { $empsuff == 0 && $sufflist == "" } {
				errab "no app.c, app.cc or app_xxx.cc found in\
					current directory"
			}
			set rootsuff ".cc"
		} else {
			dmp "app.c found, traditional mode"
		}
	
		if { $sufflist == "" } {
			set sufflist [list ""]
		}


		foreach suffix $sufflist {

			dmp "doing suffix '$suffix'"

			set ToCompile ""

			if { $suffix == "" } {
				set suff ""
			} else {
				set suff "_$suffix"
			}

			lappend_toc ToCompile "app${suff}${rootsuff}"

			array unset Processed

			set SrcLists($suffix) ""

			while { $ToCompile != "" } {
				set CFName [lindex $ToCompile 0]
				set ToCompile [lrange $ToCompile 1 end]
				if [info exists Processed($CFName)] {
					continue
				}
				set Processed($CFName) ""
				lappend_toc SrcLists($suffix) $CFName
				# predefine symbols
				set Symbols(BOARD_$Run(board)) "@@@"
				if { $Run(mode) == "E" } {
					set Symbols(__ECOG__) "@@@"
				} else {
					set Symbols(__MSP430__) "@@@"
				}
				scanfile $CFName
				array unset Symbols
				array unset Scanned
			}

			array unset Processed
			array unset ToCompile
			dmp "TO COMPILE \[$suffix\]: '$SrcLists($suffix)'"
		}

		if { $Run(mode) == "M" } {
			# MSP430: no project
			lappend deflist "__MSP430__"
			outmkf $deflist $mcpu
		} else {
			# project file
			lappend deflist "__ECOG__"
			if { $Run(type) == "p" || $Run(type) == "P" } {
				outprf	$deflist $mcpu
			} else {
				outmkfc $deflist
			}
		}
	}

	if { $NotFound != "" } {
		puts -nonewline stdout "Warning: //+++ sources not found:"
		foreach fn $NotFound {
			puts -nonewline stdout "$fn "
		}
		puts stdout ""
	}
}

main
exit

if [catch { main } err] {

	puts stderr $err
}
