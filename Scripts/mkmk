#!/bin/sh
###################\
exec tclsh "$0" "$@"

set DEBUG 0

if $DEBUG {
	proc dmp { t } {
		puts $t
	}
} else {
	proc dmp { t } { }
}

###############################################################################
# Determine the system type ###################################################
###############################################################################
if [catch { exec uname } ST(SYS)] {
	set ST(SYS) "W"
} elseif [regexp -nocase "linux" $ST(SYS)] {
	set ST(SYS) "L"
} elseif [regexp -nocase "cygwin" $ST(SYS)] {
	set ST(SYS) "C"
} else {
	set ST(SYS) "W"
}
if { $ST(SYS) != "L" } {
	# sanitize arguments
	set u [string trimright [lindex $argv end]]
	if { $u == "" } {
		set argv [lreplace $argv end end]
	} else {
		set argv [lreplace $argv end end $u]
	}
	unset u
}

###############################################################################
# Determine the way devices are named; if running natively under Cygwin, use
# Linux style
###############################################################################

if [file isdirectory "/dev"] {
	set ST(DEV) "L"
} else {
	set ST(DEV) "W"
}

###############################################################################
###############################################################################

package provide xml 1.0
###############################################################################
# Mini XML parser. Copyright (C) 2008-12 Olsonet Communications Corporation.
###############################################################################

### Last modified PG111008A ###

namespace eval XML {

proc xstring { s } {
#
# Extract a possibly quoted string
#
	upvar $s str

	if { [xspace str] != "" } {
		error "illegal white space"
	}

	set c [string index $str 0]
	if { $c == "" } {
		error "empty string illegal"
	}

	if { $c != "\"" } {
		# no quote; this is formally illegal in XML, but let's be
		# pragmatic
		regexp "^\[^ \t\n\r\>\]+" $str val
		set str [string range $str [string length $val] end]
		return [xunesc $val]
	}

	# the tricky way
	if ![regexp "^.(\[^\"\]*)\"" $str match val] {
		error "missing \" in string"
	}
	set str [string range $str [string length $match] end]

	return [xunesc $val]
}

proc xunesc { str } {
#
# Remove escapes from text
#
	regsub -all "&amp;" $str "\\&" str
	regsub -all "&quot;" $str "\"" str
	regsub -all "&lt;" $str "<" str
	regsub -all "&gt;" $str ">" str
	regsub -all "&nbsp;" $str " " str

	return $str
}

proc xspace { s } {
#
# Skip white space
#
	upvar $s str

	if [regexp -indices "^\[ \t\r\n\]+" $str ix] {
		set ix [lindex $ix 1]
		set match [string range $str 0 $ix]
		set str [string range $str [expr $ix + 1] end]
		return $match
	}

	return ""
}

proc xcmnt { s } {
#
# Skip a comment
#
	upvar $s str

	set sav $str

	set str [string range $str 4 end]
	set cnt 1

	while 1 {
		set ix [string first "-->" $str]
		set iy [string first "<!--" $str]
		if { $ix < 0 } {
			error "unterminated comment: [string range $sav 0 15]"
		}
		if { $iy > 0 && $iy < $ix } {
			incr cnt
			set str [string range $str [expr $iy + 4] end]
		} else {
			set str [string range $str [expr $ix + 3] end]
			incr cnt -1
			if { $cnt == 0 } {
				return
			}
		}
	}
}

proc xftag { s } {
#
# Find and extract the first tag in the string
#
	upvar $s str

	set front ""

	while 1 {
		# locate the first tag
		set ix [string first "<" $str]
		if { $ix < 0 } {
			set str "$front$str"
			return ""
		}
		append front [string range $str 0 [expr $ix - 1]]
		set str [string range $str $ix end]
		# check for a comment
		if { [string range $str 0 3] == "<!--" } {
			# skip the comment
			xcmnt str
			continue
		}
		set et ""
		if [regexp -nocase "^<(/)?\[a-z:_\]" $str ix et] {
			# this is a tag
			break
		}
		# skip the thing and keep going
		append front "<"
		set str [string range $str 1 end]
	}

	if { $et != "" } {
		set tm 1
	} else {
		set tm 0
	}

	if { $et != "" } {
		# terminator, skip the '/', so the text is positioned at the
		# beginning of keyword
		set ix 2
	} else {
		set ix 1
	}

	# starting at the keyword
	set str [string range $str $ix end]

	if ![regexp -nocase "^(\[a-z0-9:_\]+)(.*)" $str ix kwd str] {
		# error
		error "illegal tag: [string range $str 0 15]"
	}

	set kwd [string tolower $kwd]

	# decode the attributes
	set attr ""
	array unset atts

	while 1 {
		xspace str
		if { $str == "" } {
			error "unterminated tag: <$et$kwd"
		}
		set c [string index $str 0]
		if { $c == "/" } {
			# self-terminating
			if { $tm != 0 || [string index $str 1] != ">" } {
				error "broken self-terminating tag:\
					<$et$kwd ... [string range $str 0 15]"
			}
			set str [string range $str 2 end]
			return [list 2 $front $kwd $attr]
		}
		if { $c == ">" } {
			# done
			set str [string range $str 1 end]
			# term preceding_text keyword attributes
			return [list $tm $front $kwd $attr]
		}
		# this must be a keyword
		if ![regexp -nocase "^(\[a-z\]\[a-z0-9_\]*)=" $str match atr] {
			error "illegal attribute: <$et$kwd ... [string range \
				$str 0 15]"
		}
		set atr [string tolower $atr]
		if [info exists atts($attr)] {
			error "duplicate attribute: <$et$kwd ... $atr"
		}
		set atts($atr) ""
		set str [string range $str [string length $match] end]
		if [catch { xstring str } val] {
			error "illegal attribute value: \
				<$et$kwd ... $atr=[string range $str 0 15]"
		}
		lappend attr [list $atr $val]
	}
}

proc xadv { s kwd } {
#
# Returns the text + the list of children for the current tag. A child looks
# like this:
#
#	text:		<"" the_text>
#	element:	<tag attributes children_list>
#
	upvar $s str

	set chd ""

	while 1 {
		# locate the nearest tag
		set tag [xftag str]
		if { $tag == "" } {
			# no more
			if { $kwd != "" } {
				error "unterminated tag: <$kwd ...>"
			}

			if { $str != "" } {
				# a tailing text item
				lappend chd [list "" $str]
				return $chd
			}
		}

		set md [lindex $tag 0]
		set fr [lindex $tag 1]
		set kw [lindex $tag 2]
		set at [lindex $tag 3]

		if { $fr != "" } {
			# append a text item
			lappend chd [list "" $fr]
		}

		if { $md == 0 } {
			# opening, not self-closing
			set cl [xadv str $kw]
			# inclusion ?
			set tc [list $kw $at $cl]
			if ![xincl str $tc] {
				lappend chd $tc
			}
		} elseif { $md == 2 } {
			# opening, self-closing
			set tc [list $kw $at ""]
			if ![xincl str $tc] {
				lappend chd $tc
			}
		} else {
			# closing
			if { $kw != $kwd } {
				error "mismatched tag: <$kwd ...> </$kw>"
			}
			# we are done with the tag
			return $chd
		}
	}
}

proc xincl { s tag } {
#
# Process an include tag
#
	set kw [lindex $tag 0]

	if { $kw != "include" && $kw != "xi:include" } {
		return 0
	}

	set fn [sxml_attr $tag "href"]

	if { $fn == "" } {
		error "href attribute of <$kw ...> is empty"
	}

	if [catch { open $fn "r" } fd] {
		error "cannot open include file $fn: $fd"
	}

	if [catch { read $fd } fi] {
		catch { close $fd }
		error "cannot read include file $fn: $fi"
	}

	# merge it
	upvar $s str

	set str $fi$str

	return 1
}

proc sxml_parse { s } {
#
# Builds the XML tree from the provided string
#
	upvar $s str

	set v [xadv str ""]

	return [list root "" $v]
}

proc sxml_name { s } {

	return [lindex $s 0]
}

proc sxml_txt { s } {

	set txt ""

	foreach t [lindex $s 2] {
		if { [lindex $t 0] == "" } {
			append txt [lindex $t 1]
		}
	}

	return $txt
}

proc sxml_snippet { s } {

	if { [lindex $s 0] != "" } {
		return ""
	}

	return [lindex $s 1]
}

proc sxml_attr { s n { e "" } } {

	if { $e != "" } {
		# flag to tell the difference between an empty attribute and
		# its complete lack
		upvar $e ef
		set ef 0
	}

	if { [lindex $s 0] == "" } {
		# this is a text
		return ""
	}

	set al [lindex $s 1]
	set n [string tolower $n]
	foreach a $al {
		if { [lindex $a 0] == $n } {
			if { $e != "" } {
				set ef 1
			}
			return [lindex $a 1]
		}
	}
	return ""
}

proc sxml_children { s { n "" } } {

	# this is automatically null for a text
	set cl [lindex $s 2]

	if { $n == "+" } {
		# all including text
		return $cl
	}

	set res ""

	if { $n == "" } {
		# tagged elements only
		foreach c $cl {
			if { [lindex $c 0] != "" } {
				lappend res $c
			}
		}
		return $res
	} else {
		# all with the given tag name
		foreach c $cl {
			if { [lindex $c 0] == $n } {
				lappend res $c
			}
		}
	}

	return $res
}

proc sxml_child { s n } {

	# null for a text
	set cl [lindex $s 2]

	foreach c $cl {
		if { [lindex $c 0] == $n } {
			return $c
		}
	}

	return ""
}

proc sxml_yes { item attr } {
#
# A useful shortcut
#
	if { [string tolower [string index [sxml_attr $item $attr] 0]] == \
		"y" } {
			return 1
	}
	return 0
}

namespace export sxml_*

### end of XML namespace ######################################################

}

namespace import ::XML::*

###############################################################################
###############################################################################
###############################################################################

proc errab { m } {

	puts stderr $m
	exit 1
}

proc lappend_unique { li i } {

	upvar $li l

	if { ![info exists l] || [lsearch -exact $l $i] < 0 } {
		lappend l $i
	}
}

proc bad_usage { { msg "" } } {
#
#
#
	if { $msg != "" } {

		puts stderr "Illegal argument: $msg"
		puts stderr ""
	}

	puts stderr "Usage: (1) mkmk boardname \[-a arch\] \[label\]"
	puts stderr "       (2) mkmk boardname \[-a arch\] -l \[label\]"
	puts stderr "       (3) mkmk"
	puts stderr "       (4) mkmk boardname \[-a arch\] -L"
	puts stderr "       (5) mkmk -V"
	puts stderr "--"
	puts stderr " 1 - create image for the given board/architecture/program"
	puts stderr " 2 - create image (as in 1) from a library"
	puts stderr " 3 - create library (must be executed in a board dir)"
	puts stderr " 4 - create library (invoked in a project dir)"
	puts stderr " 5 - print version number and exit"

	exit 1
}

proc process_args { } {

	global Run argv

	# to count "keyword" args (boardname, label)
	set nc 0

	set Run(arch) ""
	set Run(board) ""
	set Run(type) ""
	set Run(pgm) ""

	while { $argv != "" } {

		set arg [lindex $argv 0]
		set argv [lrange $argv 1 end]

		if { [string index $arg 0] == "-" } {
			set arg [string range $arg 1 end]
			if { $arg == "a" } {
				# architecture
				if [info exists a] {
					bad_usage "duplicate -a"
				}
				set a [lindex $argv 0]
				if { $a == "" || [string index $a 0] == "-" } {
					bad_usage "architecture expected after\
						-a"
				}
				set argv [lrange $argv 1 end]
				continue
			}
			if { $arg == "l" } {
				# library
				if [info exists l] {
					bad_usage "duplicate -l"
				}
				set l ""
				continue
			}
			if { $arg == "L" } {
				# library make, requires board/arch
				if [info exists L] {
					bad_usage "duplicate -L"
				}
				set L ""
				continue
			}
			if { $arg == "V" } {
				if [info exists V] {
					bad_usage "duplicate -V"
				}
				set V ""
				continue
			}
			bad_usage "-$arg unknown"
		}

		if $nc {
			# this can only be the program label
			if { $nc > 1 } {
				bad_usage "$arg unrecognizable"
			}
			set p $arg
		} else {
			set b $arg
		}

		incr nc
	}

	if [info exists V] {
		# nothing else expected
		if { [info exists a] || [info exists l] || [info exists L]
		    || $nc } {
			bad_usage "-V cannot be mixed with other arguments"
		}
		# will be replaced with the proper tag by deploy
		puts "ZZ000000A"
		exit 0
	}

	if { $nc == 0 } {
		if [info exists l] {
			bad_usage "-l illegal without board name"
		}
		# make library, force "L" which is the only available option
		set Run(type) "L"
	} else {
		set Run(board) $b
		if [info exists l] {
			# type l -> compiling from library
			set Run(type) "l"
		} elseif [info exists L] {
			set Run(type) "L"
		} else {
			set Run(type) "s"
		}
	}

	if [info exists a] {
		set Run(arch) $a
	}

	if { $nc > 1 } {
		if { $Run(type) == "L" } {
			bad_usage "program label illegal with -L"
		}
		set Run(pgm) $p
	}
}

proc arch_candidates { } {
#
# Returns the list of tail subdirectory names that appear to be valid
# target identifiers, i.e., being directories named with all capitals and
# digits
#
	global SDirs

	set dir [file join $SDirs(root) "PicOS"]

	set fl [glob -nocomplain -directory $dir -tails *]
	set res ""

	foreach f $fl {
		if ![regexp {^[A-Z0-9]+$} $f] {
			continue
		}
		if ![file isdirectory [file join $dir $f]] {
			continue
		}
		lappend res $f
	}

	return $res
}

proc fpath { fn { pr "" } } {
#
# Transform a file name to mkmk native format (so mkmk understands it)
#
	global ST Comp __fpcache

	if { $ST(SYS) == "L" } {
		# we are on Linux, things are completely trivial; we can
		# ignore the dos flags of processors even if they are set
		return $fn
	}

	if [info exists __fpcache($pr,$fn)] {
		return $__fpcache($pr,$fn)
	}

	if [info exists Comp($pr,dos)] {
		# this is a processor, honor its preference
		if $Comp($pr,dos) {
			# convert to Windows
			if [catch { exec cygpath -m $fn } res] {
				errab "Cannot convert file path $fn to Windows\
					native, $res"
			}
			set __fpcache($pr,$fn) $res
			return $res
		}
		# convert to UNIX
		if [catch { exec cygpath $fn } res] {
			errab "Cannot convert file path $fn to Cygwin\
				(Unix) format, $res"
		}
		set __fpcache($pr,$fn) $res
		return $res
	}

	if { $pr == "m" } {
		# make; assume make uses Linux paths; we will parameterize this
		# later, if needed
		if [catch { exec cygpath $fn } res] {
			errab "Cannot convert file path $fn to Cygwin\
				(Unix) format, $res"
		}
		set __fpcache($pr,$fn) $res
		return $res
	}

	# mkmk format

	if { $ST(DEV) == "W" } {
		# convert to Windows
		if [catch { exec cygpath -m $fn } res] {
			errab "Cannot convert file path $fn to Windows\
				native, $res"
		}
	} else {
		# convert to Unix
		if [catch { exec cygpath $fn } res] {
			errab "Cannot convert file path $fn to Cygwin\
				(Unix) format, $res"
		}
	}

	set __fpcache($pr,$fn) $res
	return $res
}

proc cmp_tags { a b } {
#
# Compares two release tags, returns "", -1, 0, 1
#

	set pat "(\[0-9\]\[0-9\]\[0-9\]\[0-9\]\[0-9\]\[0-9\])(\[A-Z\])?$"

	set leta "a"
	if ![regexp $pat $a jnk numa leta] {
		# failed
		return ""
	}
	set numa "1$numa"

	set letb "a"
	if ![regexp $pat $b jnk numb letb] {
		return ""
	}
	set numb "1$numb"

	if { $numa < $numb } {
		return -1
	}

	if { $numa > $numb } {
		return 1
	}

	# the tricky case, have to look at the letters

	set leta [string tolower $leta]
	set letb [string tolower $letb]

	if { $leta == $letb } {
		return 0
	}

	if { [lindex [lsort [list $leta $letb]] 0] == $leta } {
		return -1
	}

	return 1
}

proc locate_root { } {
#
# Locate the root directory of the package
#
	global SDirs Run

	# this is normalized
	set rpref [pwd]
	set SDirs(cwd) $rpref

	if { $Run(type) == "L" && $Run(board) == "" } {
		# this is only possible if mkmk is called in the board
		# directory
		set Run(board) [file tail $rpref]
		set root [file dirname $rpref]
		# this should be BOARDS
		if { [file tail $root] != "BOARDS" } {
			errab "For a library make with no explicit board\
				specified, mkmk must be invoked in the\
				board directory"
		}
		set root [file dirname $root]
		# this is the arch
		set arch [file tail $root]
		if { $Run(arch) != "" && $Run(arch) != $arch } {
			errab "Illegal explicit architecure, $Run(arch), the\
				board belongs to $arch"
		}
		set Run(arch) $arch
		set root [file dirname $root]
		# this should be PicOS
		if { [file tail $root] != "PicOS" } {
			errab "The board directory is not rooted at PicOS"
		}
		set root [file dirname $root]
	} else {
		# the second option regarding where exactly mkmk has been
		# invoked is an App directory; this is also applicable to -L
		# with the explicit board/arch
		while 1 {
			set root [file dirname $rpref]
			if { [file tail $rpref] == "Apps" } {
				# a candidate
				if [file isdirectory \
				    [file join $root "PicOS"]] {
					# done
					break
				}
			}
			if { $root == $rpref } {
				# we have hit the bottom
				errab "Path to current directory contains\
					no \"Apps\""
			}
			set rpref $root
		}
	}

	set SDirs(root) $root
}

proc do_rtags { } {
#
# Read RTAGS looking for the current version numbers
#
	global CCDefs SDirs

	# patterns for locating release/version tags
	set rt "X000000A"
	set maj 0
	set min 0
	set ptg "(\[0-9A-Z\]+):"
	set pve "\[0-9A-Z\]+:\[ \t\]*(\[0-9\]+)\[ \t\]+(\[0-9\]+)"

	set fl [exec ls $SDirs(root)]

	foreach f $fl {

		if ![regexp "^RTAGS" $f] {
			continue
		}

		if [catch { open [file join $SDirs(root) $f] "r" } fd] {
			errab "Cannot open $f: $fd"
		}

		if [catch { read $fd } rtf] {
			errab "Cannot read $f: $rtf"
		}

		catch { close $fd }

		# the last RTAG
		if { ![regexp -nocase ".*\n$ptg" $rtf fd rtag] &&
		     ![regexp -nocase "^$ptg" $rtf fd rtag] } {
			continue
		}
		set cmp [cmp_tags $rt $rtag]
		if { $cmp == "" } {
			errab "Illegal tag '$rtag' in $f"
		} elseif { $cmp < 0 } {
			set rt $rtag
		}

		# look for version

		if { ![regexp -nocase ".*\n$pve" $rtf fd ma mi] &&
		     ![regexp -nocase "^$pve" $rtf fd ma mi] } {
			continue
		}

		if { [catch { expr $ma } mar] || [catch { expr $mi } mir] } {
			errab "Illegal version numbers '$ma $mi' in $f"
		}

		if { $ma > $maj || ( $ma == $maj && $mi > $min ) } {
			set maj $ma
			set min $mi
		}
	}
		
	puts "PicOS version ${maj}.${min}, release $rt"

	# defines for the system version
	lappend CCDefs "SYSVER_U=$maj"
	lappend CCDefs "SYSVER_L=$min"
	lappend CCDefs "SYSVER_T=$rt"
}

proc locate_arch_n_board { } {
#
# Fixes the architecture argument. The argument can be absent or abbreviated,
# in which case the architecture is determined by board.
#
	global Run SDirs

	set res ""
	set arch [string toupper $Run(arch)]

	foreach a [arch_candidates] {
		if { $arch == "" || [string first $arch $a] == 0 } {
			# check if the board occurs there
			set bp [file join $SDirs(root) "PicOS" $a "BOARDS" \
				$Run(board)]
			if [file isdirectory $bp] {
				if { $res == "" } {
					set res $a
				} else {
					errab "More than one board matches the\
						arguments, please specify the\
						architecture"
				}
			}
		}
	}

	if { $res == "" } {
		errab "Board $Run(board) not found"
	}

	set Run(arch) $res
	set SDirs(board) [file join $SDirs(root) "PicOS" $Run(arch) "BOARDS" \
		$Run(board)]
}

proc get_compiler_data { } {
#
# Parses the compile file
#
	global SDirs Run Comp

	set pmf [file join $SDirs(root) "PicOS" $Run(arch) "compile.xml"]

	if [catch { open $pmf "r" } fd] {
		errab "Cannot open compile.xml for $Run(arch), $fd"
	}

	if [catch { read $fd } cdata] {
		errab "Cannot read compile.xml for $Run(arch), $cdata"
	}

	catch { close $fd }

	if [catch { sxml_parse cdata } cdata] {
		errab "Bad format of compile.xml for $Run(arch), $cdata"
	}

	set cdata [sxml_child $cdata "compile"]
	if { $cdata == "" } {
		errab "No <compile> tag in compile.xml for $Run(arch)"
	}

	# cc, ld, ar, ranlib
	# foreach: path, args, postargs, after

	foreach ta { "cc" "ld" "ar" "ranlib" } {
		set Comp($ta,path) ""
		set Comp($ta,args) ""
		set Comp($ta,postargs) ""
		set Comp($ta,after) ""
		set Comp($ta,dos) 0
		set el [sxml_child $cdata $ta]
		if { $el != "" } {
			if { [sxml_yes $el "dospaths"] ||
			     [sxml_yes $el "dospath"] } {
				set Comp($ta,dos) 1
			}
			# we have a problem with paths, because we don't quite
			# know where a path actually occurs; while we can
			# assume that the compiler "path" (below) is in fact
			# a path, the commands in "after" are a bit tricky; so
			# something is missing here
			set Comp($ta,path) [sxml_txt [sxml_child $el "path"]]
			set Comp($ta,args) [sxml_txt [sxml_child $el "args"]]
			set Comp($ta,postargs) [sxml_txt \
				[sxml_child $el "postargs"]]
			set Comp($ta,after) [sxml_txt [sxml_child $el "after"]]
		}
	}

	if { $Comp(cc,path) == "" || $Comp(ld,path) == "" } {
		errab "Inadequate contents of compile.xml for $Run(arch)"
	}

	# check for a gdb init file
	set el [sxml_child $cdata "gdb"]
	set Comp(gdb,ifname) ""
	set Comp(gdb,ifile) ""

	if { $el != "" } {
		set fi 0
		foreach gi [sxml_children $el "init"] {
			set cp [sxml_attr $gi "cpu"]
			if { $cp == "" || $cp == "all" || $cp == "any" } {
				set fi 1
				break
			}
			if { $cp == $Run(cpu) } {
				set fi 1
				break
			}
		}
		if $fi {
			set cp [sxml_attr $gi "file"]
			if { $cp == "" } {
				# the default name
				set cp ".gdbinit"
			}
			set Comp(gdb,ifname) $cp
			set Comp(gdb,ifile) ""
			foreach ln [split [sxml_txt $gi] "\n"] {
				set ln [string trim $ln]
				if { $ln != "" } {
					append Comp(gdb,ifile) "${ln}\n"
				}
			}
		}
	}
}

proc get_flags { } {

	global SDirs Flags Run

	set sp [file join $SDirs(board) "params.sys"]

	if [catch { open $sp "r" } fd] {
		errab "No params.sys in the board directory"
	}

	if [catch { read $fd } ps] {
		errab "Cannot read params.sys, $ps"
	}

	foreach ln [split $ps "\n"] {
		set ln [string trim $ln]
		if { $ln == "" } {
			continue
		}
		if [regexp {^-([a-z])[[:space:]]+(.*)} $ln jnk flag body] {
			set Flags($flag) $body
		} else {
			if [regexp {^[a-z0-9]+$} $ln] {
				set Flags(c) $ln
			} else {
				errab "Bad flag line, $ln, in params.sys"
			}
		}
	}

	if ![info exists Flags(c)] {
		errab "CPU tag missing from params.sys"
	}
	set Run(cpu) $Flags(c)
}
			
proc initialize { } {

	global CCDefs

	# locate the root directory
	locate_root

	# list of defines for the compiler
	set CCDefs ""

	# obtain version numbers from RTAGS
	do_rtags

	# fix the path to architecture
	locate_arch_n_board

	# compiler data
	get_compiler_data

	# get the CPU type
	get_flags
}

proc make_clean { } {

	global Run SDirs

	if { $Run(type) == "L" } {
		# cleanup within the board directory
		catch { exec rm -rf "libpicos.a" }
	}

	catch { exec rm -rf "Makefile" "KTMP" ".gdbinit" "gdb.ini" }

	if { $Run(pgm) == "" } {
		# remove program-specific stuff; otherwise (if we are
		# generating a single program-specific image, the stuff for
		# other programs is left intact
		catch { exec rm -rf "Makefile_*" "KTMP_*" }
		set suf ""
	} else {
		catch { exec rm -rf "KTMP_$Run(pgm)" }
		set suf "_$Run(pgm)"
	}

	catch { file mkdir "KTMP$suf" }
}

proc add_all_subdirs { dname } {
#
# A recursive helper for build_directory_list
#
	global __aas

	set sdl [glob -nocomplain -directory $dname -tails *]

	foreach f $sdl {

		set ff [file normalize [file join $dname $f]]
		if ![file isdirectory $ff] {
			continue
		}

		# directories to ignore
		set k 0
		foreach p \
		    { "^VUEE_TMP$" "^ktmp" "junk" "attic" "ossi" "\\~\\$" } {

			if [regexp -nocase $p $f] {
				set k 1
				break
			}
		}

		if $k {
			continue
		}

		if [info exists __aas($ff)] {
			# avod link loops
			continue
		}

		set __aas($ff) ""
		add_all_subdirs $ff
	}
}

proc build_directory_list { } {

	global Run SDirs PDirs LDirs EDirs __aas

	set EDirs ""

	#
	# Initial directories to be searched (in this order). This also
	# reflects the order of search. Local directories must be at the end,
	# following ".".
	#
	set roots {
			"PicOS/%arch%"
			"PicOS/%arch%/%cpu%"
			"PicOS/%arch%/BOARDS/%board%"
			"PicOS/kernel"
			"PicOS"
			"PicOS/Libs/*"
	}

	# if creating a library, ignore all local files, i.e., only look at
	# PicOS files; NOTE: we didn't have that before, so, for example, a
	# library built could be influenced by local options.sys; I don't
	# think that makes a lot of sense

	if { $Run(type) != "L" } {
		lappend roots "."
		lappend roots "./*"
	}

	# subdirectories of the praxis directory
	set LDirs ""

	# system subdirectories + LDirs, i.e, the works
	set PDirs ""

	foreach p $roots {
		regsub -all "%arch%" $p $Run(arch) p
		regsub -all "%board%" $p $Run(board) p
		regsub -all "%cpu%" $p $Run(cpu) p
		if [regexp {/\*$} $p] {
			# wildcard means all subdirectories (recursively)
			set p [string range $p 0 end-2]
			if { $p != "." } {
				# convert to the path format used by mkmk
				set p [file join $SDirs(root) [fpath $p]]
			}
			if ![file isdirectory $p] {
				# skip
				continue
			}
			add_all_subdirs $p
			set dl [lsort [array names __aas]]
			array unset __aas
			foreach p $dl {
				lappend_unique PDirs $p
			}
			if { $LDirs != "" } {
				# these are subdirs of ".", put them here as
				# well
				foreach p $dl {
					lappend_unique LDirs $p
				}
			}
			continue
		}
		# just this directory
		if { $p != "." } {
			set p [file normalize [file join $SDirs(root) \
				 [fpath $p]]]
			if ![file isdirectory $p] {
				continue
			}
			if { $LDirs != "" } {
				# local directories, i.e., subdirs of .
				lappend_unique LDirs $p
			}
		} else {
			set p [file normalize $p]
			# first one considered local
			lappend LDirs $p
		}
		lappend_unique PDirs $p
	}

	dmp "PDIRS: $PDirs"
	dmp "LDIRS: $LDirs"
}

proc get_options_file_defs { } {
#
# Determine if and which options.sys file should be included
#
	global Run CCDefs

	if { $Run(type) == "L" } {
		# no local options for a library build
		return
	}

	if { $Run(pgm) != "" } {
		set of "options_$Run(pgm).sys"
		if [file isfile $of] {
			lappend CCDefs "__OPTIONS_SYS__=\"<$of>\""
		}
	}
	set of "options.sys"
	if [file isfile $of] {
		lappend CCDefs "__OPTIONS_SYS__=\"<$of>\""
	}
}

proc add_extra_defines { } {

	global Run CCDefs ESymbols Comp SDirs

	lappend CCDefs "BOARD_$Run(board)"
	lappend CCDefs "BOARD_TYPE=$Run(board)"

	# get the compiler version number; not needed any more for MSP430
	# code (no need for the extra symbol, __COMP_VERSION__), but let us
	# do it just in case, so mkmk knows the version from this stage on

	# get the directory of the compiler; may be needed as an argument
	# for make expansions
	if [catch { exec which $Comp(cc,path) } cdi] {
		errab "Cannot locate the $Comp(cc,path) compiler, $cdi"
	}
	set SDirs(comp) [file dirname $cdi]

	# this should work without path conversions (assuming the comp path
	# is just the call name, and system $PATH is properly set); we will
	# fix it later (don't know how) if the simple idea doesn't work
	catch { exec $Comp(cc,path) -v } res
	if ![regexp "version (\[0-9\]+\)\\.\[0-9\]+\\.\[0-9\]+" $res jnk res] {
		errab "Cannot determine $Comp(cc,path) version number,\
			unrecognized response: $res"
	}
	puts "$Comp(cc,path) $jnk"
	set Comp(cc,version) $res
	# make sure the version symbol is internally recognized
	set ESymbols [list "__GNUC__" $res]
	# ... add more extra symbols as needed

	if { $Run(pgm) != "" } {
		lappend CCDefs "PGMLABEL_$Run(pgm)"
		lappend CCDefs "PGMLABEL=$Run(pgm)"
	}

	lappend CCDefs "__$Run(arch)__"
	lappend CCDefs "__$Run(cpu)__"

	get_options_file_defs
}

proc lookup_file { fn mode prefdir dirs } {
#
# Lookup the given file; modes are:
#
#	0 - include lookup, if a partial path precedes the file name, make sure
#	    to add the prefix to this path to include directories
#
#	1 - sourced (//+++) addition; this cannot be a header, but a source
#	    file; partial path processing still applies, but there is no need
#	    to add the prefix to include directories
#
# prefdir - preferred directory, i.e., the directory to be tried first (the one
#	    containing the includer)
#
# dirs    - the package directory list to search
#
# The argument paths are specified in the format of mkmk
#
	global SDirs EDirs

	if { $prefdir != "" } {
		# put the preferred directory in front
		set dirs [concat [list $prefdir] $dirs]
	}

	set dir [file dirname $fn]

	if { $dir != "." && $dir != "" } {
		# the file name has a (possibly partial) directory prefix
		set fil [file tail $fn]
		# full normalized prefix
		set dir [file normalize $dir]
		# this feature is restricted to subdirs of the App directory
		if { [string first $SDirs(cwd) $dir] != 0 } {
			errab "Illegal compound path for included file $fn"
		}
		set dir [string range $dir [string length $SDirs(cwd)] end]
		set dl [string length $dir]
		# now we are searching for a directory whose tail matches dir
		# and which contains $fn
		set ffn ""
		foreach d $dirs {
			# the last occurrence
			set pos [string last $dir $d]
			if { $pos < 0 } {
				continue
			}
			if { [expr $pos + $dl] != [string length $d] } {
				continue
			}
			# we have a match on directory name
			set ff [file normalize [file join $d $fil]]
			if [file isfile $ff] {
				# check for a duplicate
				if { $ffn != "" && $ffn != $ff } {
					puts "Warning: multiple occurrences of\
						file $fn (at $ffn and $ff)"
					break
				} else {
					set ffn $ff
					set ddn [string range $d 0 \
						[expr $pos - 1]]
				}
			}
		}

		if { $ffn == "" } {
			# this is an error
			errab "Cannot locate path-prefixed file $fn"
		}

		if { $mode == 0 } {
			# should add the prefix to the list of extra includes
			lappend_unique EDirs $ddn
		}
		return $ffn
	}

	# a regular file
	set ffn ""
	foreach d $dirs {
		set ff [file normalize [file join $d $fn]]
		if [file isfile $ff] {
			if { $ffn != "" && $ffn != $ff } {
				puts "Warning: multiple occurrences of file\
					$fn (at $ffn and $ff)"
				break
			} else {
				set ffn $ff
			}
		}
	}

	return $ffn
}

proc lookup_file_globally { fn } {

	global PDirs

	return [lookup_file $fn 1 "" $PDirs]
}

proc lookup_file_locally { fn mode prefdir } {

	global Run PDirs LDirs

	if { $Run(type) == "l" } {
		# compiling from library, local files only
		set pd $LDirs
		if { [lsearch $prefdir $LDirs] < 0 } {
			# only local prefdirs
			set prefdir ""
		}
	} else {
		# all files
		set pd $PDirs
	}

	return [lookup_file $fn $mode $prefdir $pd]
}

proc setsymbols { } {
#
# Preset symbols for parsing files
#
	global Symbols CCDefs ESymbols

	array unset Symbols

	foreach d $CCDefs {
		if ![regexp "^(\[^=\]+)=(.*)" $d jnk d v] {
			set v ""
		}
		set Symbols($d) $v
	}

	foreach d $ESymbols {
		set Symbols([lindex $d 0]) [lindex $d 1]
	}
}

proc needlist { ar } {
#
# Returns the list of files from "//+++". The argument is the piece of line
# past the +++ string.
#
	set fl ""
	while 1 {
		set ar [string trim $ar]
		if { $ar == "" } {
			break
		}

		set d0 [string index $ar 0]
		if { $d0 == "\"" } {
			set ind [regexp {^"([^"]+)"} $ar mat nfn]
		} elseif { $d0 == "<" } {
			set ind [regexp {^<([^>]+)>} $ar mat nfn]
		} else {
			set ind [regexp {^([^[:blank:]]+)} $ar mat nfn]
		}

		if !$ind {
			error "syntax error in '//+++' ($ar)"
		}

		set ar [string range $ar [string length $mat] end]

		lappend fl $nfn
	}

	return $fl
}

proc remcmnt { str } {
#
# Eliminate trailing comments from #if conditions and #defines
#
	set es [string first "//" $str]
	set ps [string first "/*" $str]
	set sl [string length $str]

	if { $es < 0 } {
		set es $sl
	}
	if { $ps < 0 } {
		set ps $sl
	}
	if { $es < $ps } {
		set ps $es
	}

	return [string trim [string range $str 0 [expr $ps - 1]]]
}

proc sexpr { str } {
#
# Evaluates #if conditions
#
	global Symbols

	if [info exists Symbols(mkmk_eval)] {
		# this symbol turns off expression evaluation for as long
		# as it is defined
		set es $Symbols(mkmk_eval)
		if { $es == "" } {
			set es 0
		}
		if [catch { expr $es } es] {
			set es 0
		}
		if { $es == 0 } {
			return 0
		}
		return 1
	}

	# remove trailing comments
	set str [remcmnt $str]

	if { $str == "" } {
		# illegal
		return -1
	}

	# eliminate "defined's"
	while {
		[regexp -indices -nocase \
		        {defined[[:blank:]]+([[:alpha:]_][[:alnum:]_.]*)} \
				$str mat sym] ||
		[regexp -indices -nocase \
{defined[[:blank:]]*\([[:blank:]]*([[:alpha:]_][[:alnum:]_.]*)[[:blank:]]*\)} \
				$str mat sym] } {

		set sym [string range $str [lindex $sym 0] [lindex $sym 1]]
		set nex [string range $str 0 [expr { [lindex $mat 0] - 1 }]]

		if [info exists Symbols($sym)] {
			append nex 1
		} else {
			append nex 0
		}

		append nex [string range $str [expr { [lindex $mat 1] + 1 }] \
			end]

		set str $nex
	}

	regsub -all {[[:blank:]]+} $str "" str

	# to prevent infinite evaluation
	set turn 0

	while {
		[regexp -indices {^[[:alpha:]_.][[:alnum:]_.]*} $str mat] ||
 [regexp -indices {[^[:alnum:]_.]([[:alpha:]_.][[:alnum:]_.]*)} $str jk mat] } {

		if { $turn > 32 } {
			break
		}

		# a bare keyword at the beginning or in the middle
		lassign $mat from upto

		set sym [string range $str $from $upto]

		if ![info exists Symbols($sym)] {
			break
		}

		# substitute for the definition and keep going
		set nex [string range $str 0 [expr { $from - 1 }]]
		append nex $Symbols($sym)
		append nex [string range $str [expr { $upto + 1 }] end]
		set str $nex
		incr turn
	}

	if [catch { eval expr $str } val] {
		return -1
	}

	if $val {
		return 1
	}

	return 0
}

proc scanfile { fname } {

	global Depend Symbols Scanned NFound FilesToCompile CFName Run PDirs

	if [info exists Scanned($fname)] {
		# once per file
		return
	}

	set Scanned($fname) ""

	if [catch { open $fname "r" } fd] {
		errab "Cannot open file '$fname': $fd"
	}

	set ifnest 0
	#
	# assume that the entire file is encapsulated in a dummy if at level
	# zero, which is being totally ignored
	#
	# Flags:
	#
	#	0	- ignore, i.e., both parts should be scanned
	#	1	- accepting the current part
	#	2	- skipping the current part, waiting for else or endif
	#	3	- skipping both parts because the outer if is being
	#		  skipped
	#

	set ifstack($ifnest) "0"

	# the directory of the scanned file
	set dnn [file dirname $fname]

	while 1 {

		if { [gets $fd line] < 0 } {
			if { $ifnest > 0 } {
				puts "Warning: #endif(s) missing in $fname"
			}
			break
		}

		if { $ifstack($ifnest) <= 1 && \
		    [regexp {^[[:blank:]]*//\+\+\+(.*)} $line jk ar] } {
			# "needed" files
			if [catch { needlist $ar } ar] {
				puts "Warning: $ar, file $fname, the entire\
					request ignored"
				set ar ""
			}
			foreach nfn $ar {
				set fn [lookup_file_locally $nfn 1 $dnn]
				if { $fn == "" &&
				    [file extension $nfn] == ".c" } {
					# try ".cc"
					set fn [lookup_file_locally \
					  "[file rootname $nfn].cc" 1 $dnn]
				}
				if { $fn == "" } {
					if { $Run(type) != "l" } {
						# no warning if compiling
						# against a library
						lappend_unique NFound $nfn
					}
				} else {
					# add to the compile set
					lappend_unique FilesToCompile $fn
				}
			}
			continue
		}

		# look for a preprocessor directive
		if ![regexp {^[[:blank:]]*#([[:alpha:]]+)[[:blank:]]*(.*)} \
		    $line jk cm ar] {
			# and ignore everything else
			continue
		}

		if { $cm == "if" || $cm == "ifdef" || $cm == "ifndef" } {
			if { $ifstack($ifnest) > 1 } {
				# we are skipping an outer if, so we should
				# skip this one entirely
				incr ifnest		
				set ifstack($ifnest) 3
				continue
			}
			incr ifnest
			if { $cm == "if" } {
				set val [sexpr $ar]
				if { $val < 0 } {
					puts "Warning: failed to evaluate:\
						'$ar' in $fname"
					set val 0
				}
				if $val {
					set ifstack($ifnest) 1
				} else {
					set ifstack($ifnest) 2
				}
				continue
			}
			# ifdef or ifndef
			if ![regexp {^[[:alnum:]_.]+} $ar nam] {
				# illegal identifier (symbol), ignore
				set ifstack($ifnest) 0
				continue
			}
			if [info exists Symbols($nam)] {
				if { $cm == "ifdef" } {
					set ifstack($ifnest) 1
				} else {
					set ifstack($ifnest) 2
				}
			} else {
				if { $cm == "ifdef" } {
					set ifstack($ifnest) 2
				} else {
					set ifstack($ifnest) 1
				}
			}
			continue
		}

		if { $cm == "elif" } {
			if { $ifnest < 1 } {
			    puts "Warning: extraneous #elif in $fname"
			    continue
			}
			if { $ifstack($ifnest) == 1 } {
				# following a successful #if, skip until #endif
				set ifstack($ifnest) 3
				continue
			}
			if { $ifstack($ifnest) == 3 } {
				continue
			}
			# 0 or 2, i.e., try it as well, or the if was skipped
			set val [sexpr $ar]
			if { $val < 0 } {
				puts "Warning: failed to evaluate: '$ar' in\
					$fname, assumed 0"
				set val 0
			}
			if $val {
				set ifstack($ifnest) 1
			} else {
				set ifstack($ifnest) 2
			}
			continue
		}
				
		if { $cm == "else" } {
			if { $ifnest < 1 } {
			    puts "Warning: extraneous #else in $fname"
			    continue
			}
			if { $ifstack($ifnest) == 1 } {
				set ifstack($ifnest) 2
			} elseif { $ifstack($ifnest) == 2 } {
				set ifstack($ifnest) 1
			}
			continue
		}

		if { $cm == "endif" } {
			if { $ifnest > 0 } {
				incr ifnest -1
			} else {
				puts "Warning: extraneous #endif in $fname"
			}
			continue
		}

		if { $ifstack($ifnest) > 1 } {
			# skipping, ignore anything else
			continue
		}

		if { $cm == "define" } {

			# remove comment
			set ar [remcmnt $ar]
			set nam ""
			if ![regexp {^([[:alnum:]_.]+)([[:blank:]]+(.*))?} \
			    $ar jk kwd jk nam] {
				puts "Warning: unrecognized #define in\
					$fname, $ar, ignored"
				continue
			}

			set Symbols($kwd) $nam
			continue
		}

		if { $cm == "undef" } {
			if ![regexp {^[[:alnum:]_.]+} $ar kwd] {
				puts "Warning: unrecognized #undef in\
					$fname, $ar, ignored"
				continue
			}
			if [info exists Symbols($kwd)] {
				unset Symbols($kwd)
			}
			continue
		}

		if { $cm == "include" } {
			if ![regexp {^["<]([^"><]+)[">]} $ar jk fn] {
				# not so easy, check if the file name to include
				# comes as a symbol
				if ![regexp {^[[:alnum:]_.]+} $ar fn] {
					# unrecognizable
					puts "Warning: unrecognizable\
						#include in $fname, $ar,\
						ignored"
					continue
				}
				# try the symbol
				if ![info exists Symbols($fn)] {
					puts "Warning: symbolic #include\
						symbol in $fname, $fn, is not\
						defined, statement ignored"
					continue
				}
				set fn [string trim $Symbols($fn) "\"<>"]
			}
			set fn [string trim $fn]
			if { $fn == "" } {
				puts "Warning: empty #include in $fname,\
					ignored"
				continue
			}
			# set fm [lookup_file_locally $fn 0 $dnn]
			set fm [lookup_file $fn 0 $dnn $PDirs]
			if { $fm != "" } {
				# recursive scan of the included file
				scanfile $fm
				# add to dependencies
				lappend_unique Depend($CFName) $fm
			} else {
				# not found, just ignore, because it may be
				# a system/compiler file which we don't care
				# about
				continue
			}
			continue
		}

		if { $cm == "error" } {
			set ar [string trim $ar " \t\""]
			if { [string first "S:" $ar] >= 0 } {
				puts stderr "#error $ar in $fname, stop"
				exit 1
			}
			# the non-stopping kind
			puts "Warning: #error $ar in $fname"
		}
	}
	catch { close $fd }
}

proc asubst { inp imf uu } {
#
# Substitute special sequence in compiler/linker arguments
#
	global SDirs Run

	regsub -all "%cpu%" $inp $Run(cpu) inp
	regsub -all "%image%" $inp $imf inp
	regsub -all "%ccdir%" $inp [fpath $SDirs(comp) $uu] inp
	regsub -all "%archdir%" $inp [fpath [file join $SDirs(root) "PicOS" \
		$Run(arch)] $uu] inp

	return $inp
}

proc incdirs { } {
#
# Build the string with include directories
#
	global PDirs EDirs Depend

	set res " -I ."

	foreach dep [array names Depend] {
		foreach fn $Depend($dep) {
			# identify all directories resulting from dependencies
			set dir [file dirname $fn]
			set ishort($dir) ""
		}
	}

	# add to the set the extra include directories forced by header files
	# specified with partial paths
	foreach dir $EDirs {
		set ishort($dir) ""
	}

	foreach dir [concat $PDirs $EDirs] {
		if [info exists ishort($dir)] {
			unset ishort($dir)
			append res " -I [fpath $dir cc]"
		}
	}

	return $res
}

proc make_makefile_image { } {

	global DShort IShort SFiles Depend NFound Run Comp CCDefs SDirs

	set mfn "Makefile"
	set kfn "KTMP"
	# target filename root
	set tfr "Image"

	if { $Run(pgm) != "" } {
		append mfn "_$Run(pgm)"
		append kfn "_$Run(pgm)"
	}

	# will create the makefile in memory and flush it in a single go
	set maf "#\n# Created by mkmk, DO NOT EDIT!!!\n#\n"

	# output processor definitions
	foreach pd { "cc" "ld" } {
		set ma [string toupper $pd]
		append maf "${ma}=$Comp($pd,path)\n"
	}

	# defines
	append maf "#\nDE="
	foreach de $CCDefs {
		append maf "-D$de "
	}
	
	# include directories
	append maf "\n#\nIN=[incdirs]\n"


	# target names
	set tnames [lsort [array names SFiles]]

	append maf "#\nall :\t"

	if { [llength $tnames] == 1 && [lindex $tnames 0] == "" } {
		# A single, simple target
		append maf "${tfr}\n"
	} else {
		foreach tar $tnames {
			if { $tar == "" } {
				# one of those impossible assertions
				errab "Illegal default target"
			}
			append maf "$tar "
		}
		append maf "\n"
		foreach tar $tnames {
			append maf "$tar :\t${tfr}_$tar\n"
		}
	}

	append maf "#\n"

	foreach tar $tnames {

		append maf "# target: \"$tar\"\n"
		if { $tar != "" } {
			set tn "_$tar"
		} else {
			set tn ""
		}

		# the target's object files: for make dependency
		set of_d ""
		# ... and for the processor
		set of_p ""
		foreach fn $SFiles($tar) {
			# the mkmk path variant
			set fp [file join $kfn \
				[file rootname [file tail $fn]].o]
			# make path variant
			lappend of_d [fpath $fp "m"]
			# processor (LD) path variant
			lappend of_p [fpath $fp "ld"]
		}

		set imfile "${tfr}$tn"

		append maf "$imfile :\t"

		# append object dependencies
		foreach fn $of_d {
			# don't we have to escape those paths? yes we do! but
			# make doesn't really support spaces (and weird chars)
			# in file names, sorry
			append maf "$fn "
		}

		if { $Run(type) == "l" } {
			# add the library file to dependencies
			set libfile [file join $SDirs(board) "libpicos.a"]
			append maf [fpath $libfile "m"]
		}

		append maf "\n\t\$(LD)"

		set ar [asubst $Comp(ld,args) $imfile "ld"]
		if { $ar != "" } {
			append maf " $ar"
		}

		append maf " -o $imfile"

		foreach fn $of_p {
			append maf " $fn"
		}

		if { $Run(type) == "l" } {
			# the library
			append maf " -L [fpath $SDirs(board) ld] -lpicos"
		}

		set ar [asubst $Comp(ld,postargs) $imfile "ld"]
		if { $ar != "" } {
			append maf " $ar"
		}

		append maf "\n"

		# any postprocessing after LD?
		set after \
	         [split [asubst [string trim $Comp(ld,after)] $imfile "m"] "\n"]

		foreach ar $after {
			set ar [string trim $ar]
			append maf "\t${ar}\n"
		}

		append maf "\n"

		# files to compile for the target
		foreach sf $SFiles($tar) mf $of_d {

			set rfn [file tail $sf]
			set suf [file extension $rfn]
			set rna [file rootname $rfn]

			if [info exists tgts($rna)] {
				# already taken care of
				continue
			}

			# CC output file
			set ofn [fpath [file join $kfn "${rna}.o"] "cc"]

			set tgts($rna) ""

			# complete make path to source
			set smf [fpath $sf "m"]

			# local target and source dependency
			append maf "$mf : $smf"

			# other dependencies
			if [info exists Depend($sf)] {
				foreach df $Depend($sf) {
					append maf " [fpath $df m]"
				}
			}

			append maf "\n"

			# the action
			append maf "\tmkdir -p $kfn\n"
			set ar [asubst $Comp(cc,args) $imfile "cc"]
			set pa [asubst $Comp(cc,postargs) $imfile "cc"]

			if { $suf == ".cc" } {
				# VUEE-compatible, preprocessed
				set rfn "${rna}.c"
				set rfm [file join $kfn "___pcs___$rfn"]
				set rfo [file join $kfn "___pct___$rfn"]
				set rfn [file join $kfn $rfn]

				# make paths
				set rmm [fpath $rfm "m"]
				set rmo [fpath $rfo "m"]
				set rmn [fpath $rfn "m"]

				# CC paths
				set rcm [fpath $rfm "cc"]
				set rcn [fpath $rfn "cc"]

				# copy src to _pcs
				append maf "\tcp $smf $rmm\n"
				append maf \
			       "\t\$(CC) $ar \$(DE) \$(IN) -E $rcm $pa > $rmo\n"
				append maf "\tpicomp -p < $rmo > $rmn\n"
				# remove the temporary files
				append maf "\trm $rmm $rmo\n"
				append maf "\t\$(CC) $ar \$(DE) \$(IN) -c $rcn"
			} else {
				set scf [fpath $smf "cc"]
				append maf "\t\$(CC) $ar \$(DE) \$(IN) -c $scf"
			}

			append maf " -o $ofn $pa\n\n"
		}

		append maf "\n"

	}

	# clean

	append maf "clean :\n\trm -rf $kfn\n"

	# gdb init file to be generated differently!!!

	if [catch { exec cat > $mfn << $maf } err] {
		errab "Cannot write to $mfn, $err"
	}
}

proc make_makefile_lib { } {

	global Comp Run SDirs SFiles CCDefs Depend

	set lfn "libpicos.a"

	set maf "#\n# Created by mkmk, DO NOT EDIT!!!\n#\n"

	# output processor definitions
	foreach pd { "cc" "ar" "ranlib" } {
		set ma [string toupper $pd]
		append maf "${ma}=$Comp($pd,path)\n"
	}

	if { $Comp(ar,path) == "" } {
		errab "No definition for the ar processor in compile.xml for\
			$Run(arch)"
	}

	set mfn "Makefile"
	set kfn "KTMP"

	# defines
	append maf "#\nDE="
	foreach de $CCDefs {
		append maf "-D$de "
	}
	
	# include directories
	append maf "\n#\nIN=[incdirs]\n"

	set lfm [fpath $lfn "m"]

	append maf "#\nall :\t$lfm\n\n"

	# the actual target
	append maf "$lfm :\t"

	foreach fn $SFiles() {
		# the mkmk path variant
		set fp [file join $kfn [file rootname [file tail $fn]].o]
		# make path variant
		lappend of_d [fpath $fp "m"]
		# processor (AR) path variant
		lappend of_p [fpath $fp "ar"]
	}

	append maf [join $of_d]
	append maf "\n"
	append maf "\trm -rf $lfm\n"
	append maf "\t\$(AR)"

	set ar [asubst $Comp(ar,args) "" "ar"]
	if { $ar != "" } {
		append maf " $ar"
	}

	append maf " q [fpath $lfn "ar"] [join $of_p]"

	set ar [asubst $Comp(ar,postargs) "" "ar"]
	if { $ar != "" } {
		append maf " $ar"
	}

	# cleanup, so only Makefile and libpicos.a are left
	append maf "\n\trm -rf $kfn\n"

	append maf "\n"

	if { $Comp(ranlib,path) != "" } {
		append maf "\t\$(RANLIB)"
		set ar [asubst $Comp(ranlib,args) "" "ranlib"]
		if { $ar != "" } {
			append maf " $ar"
		}
		append maf " "
		append maf [fpath $lfn "ranlib"]
		set ar [asubst $Comp(ranlib,postargs) "" "ranlib"]
		if { $ar != "" } {
			append maf " $ar"
		}
		append maf "\n"
	}

	append maf "\n#\n"

	# files to compile
	foreach sf $SFiles() mf $of_d {

		set rfn [file tail $sf]
		set suf [file extension $rfn]
		set rna [file rootname $rfn]

		if [info exists tgts($rna)] {
			# already taken care of
			continue
		}

		# CC output file
		set ofn [fpath [file join $kfn "${rna}.o"] "cc"]

		set tgts($rna) ""

		# complete make path to source
		set smf [fpath $sf "m"]

		# local target and source dependency
		append maf "$mf : $smf"

		# other dependencies
		if [info exists Depend($sf)] {
			foreach df $Depend($sf) {
				append maf " [fpath $df m]"
			}
		}

		append maf "\n"

		# the action
		append maf "\tmkdir -p $kfn\n"
		set ar [asubst $Comp(cc,args) "" "cc"]
		set pa [asubst $Comp(cc,postargs) "" "cc"]

		if { $suf == ".cc" } {
			# VUEE-compatible, preprocessed
			set rfn "${rna}.c"
			set rfm [file join $kfn "___pcs___$rfn"]
			set rfo [file join $kfn "___pct___$rfn"]
			set rfn [file join $kfn $rfn]

			# make paths
			set rmm [fpath $rfm "m"]
			set rmo [fpath $rfo "m"]
			set rmn [fpath $rfn "m"]

			# CC paths
			set rcm [fpath $rfm "cc"]
			set rcn [fpath $rfn "cc"]

			# copy src to _pcs
			append maf "\tcp $smf $rmm\n"
			append maf \
		            "\t\$(CC) $ar \$(DE) \$(IN) -E $rcm $pa > $rmo\n"
			append maf "\tpicomp -p < $rmo > $rmn\n"
			# remove the temporary files
			append maf "\trm $rmm $rmo\n"
			append maf "\t\$(CC) $ar \$(DE) \$(IN) -c $rcn"
		} else {
			set scf [fpath $smf "cc"]
			append maf "\t\$(CC) $ar \$(DE) \$(IN) -c $scf"
		}

		append maf " -o $ofn $pa\n\n"
	}

	append maf "\n"

	# clean

	append maf "clean :\n\trm -rf $kfn\n"

	if [catch { exec cat > $mfn << $maf } err] {
		errab "Cannot write to $mfn, $err"
	}
}

proc make_gdb_init_file { } {
#
# Put the gdb init file into the project's directory
#
	global Comp

	if { $Comp(gdb,ifname) != "" } {
	    if [catch { exec cat > $Comp(gdb,ifname) << $Comp(gdb,ifile) } er] {
		puts "Warning: cannot insert $Comp(gdb,ifname) into project\
			directory, $er"
	    }
	}
}

proc create_library { } {

	global Flags Run FilesToCompile CFName Scanned Symbols NFound SFiles

	if { ![info exists Flags(l)] || $Flags(l) == "" } {
		errab "Board $Run(board) specifies no files for a library build"
	}

	set FilesToCompile ""
	# the list of system files to be compiled into the BOARD library
	set iflist $Flags(l)

	while 1 {
		set iflist [string trim $iflist]
		# this assumes no spaces in file names; probably OK for
		# sanity, especially that we only use root names
		if ![regexp {^([^[:space:]]+)(.*)} $iflist jnk f iflist] {
			# no more files
			break
		}

		# look up the file within PicOS directories; the local part
		# of PDirs is switched off
		set nf [lookup_file_globally $f]
		if { $nf == "" } {
			lappend_unique NFound $f
		} elseif { [file extension $nf] != ".h" } {
			lappend_unique FilesToCompile $nf
		}
	}

	if { $NFound != "" } {
		puts stderr "Files not found (cannot compile library):"
		foreach fn $NFound {
			puts -nonewline stderr "$fn "
		}
		exit 1
	}

	if { $FilesToCompile == "" } {
		errab "No library files to compile, check board's params.sys"
	}

	# no pgm prefix, library files are global
	set SFiles() ""

	while { $FilesToCompile != "" } {
		# current file name
		set CFName [lindex $FilesToCompile 0]
		set FilesToCompile [lrange $FilesToCompile 1 end]
		if [info exists processed($CFName)] {
			# done already
			continue
		}
		set processed($CFName) ""
		lappend_unique SFiles() $CFName
		setsymbols
		scanfile $CFName
		array unset Scanned
	}

	array unset processed
	array unset Symbols
	unset FilesToCompile

	make_makefile_lib
}

proc create_image { } {

	global SDirs Run FilesToCompile SFiles Scanned Symbols CFName

	# scan CD for eligible app files
	set flist [glob -nocomplain -directory $SDirs(cwd) -tails *]
	set pgmlist ""
	set nopgm 0
	foreach fn $flist {
		if { $fn == "app.c" } {
			# a legacy single app file
			set rootsuff ".c"
			incr nopgm
			continue
		}
		if { $fn == "app.cc" } {
			set rootsuff ".cc"
			incr nopgm
			continue
		}

		if [regexp {^app_([[:alnum:]]+)\.cc$} $fn jnk suff] {
			# only non-legacy projects can employ ".cc" files
			lappend pgmlist $suff
			set rootsuff ".cc"
			continue
		}
	}

	if { $nopgm > 1 } {
		errab "app.c cannot coexist with app.cc within the same project"
	}

	if { $nopgm && $pgmlist != "" } {
		errab "app.cc/app.c cannot coexists with app_xxx.cc within the\
			same project"
	}

	if { $nopgm == 0 && $pgmlist == "" } {
		errab "No app.cc, app.c, or app_xxx.cc found in the project's\
			directory"
	}

	if { $Run(pgm) != "" } {
		# a request to create a single-program makefile
		if { [lsearch -exact $pgmlist $Run(pgm)] < 0 } {
			errab "No app_$Run(pgm).cc file found in the project's\
				directory"
		}
		set pgmlist [list $Run(pgm)]
		# options file already taken care of
	} else {
		if { $pgmlist == "" } {
			# turn it into a single-null-pgm list
			set pgmlist [list ""]
		}
	}

	foreach pgm $pgmlist {

		set FilesToCompile ""

		# suffix to "app"
		if { $pgm == "" } {
			set suff ""
		} else {
			set suff "_$pgm"
		}

		lappend_unique FilesToCompile "app${suff}${rootsuff}"

		set SFiles($pgm) ""

		while { $FilesToCompile != "" } {
			set CFName [lindex $FilesToCompile 0]
			set FilesToCompile [lrange $FilesToCompile 1 end]
			if [info exists processed($CFName)] {
				continue
			}
			lappend_unique SFiles($pgm) $CFName
			set processed($CFName) ""
			setsymbols
			scanfile $CFName
			array unset Scanned
		}

		array unset processed
		array unset Symbols
		unset FilesToCompile
	}

	make_makefile_image
	make_gdb_init_file
}

proc main { } {

	global Run SDirs NFound

	# this is probably no longer needed
	# cygfix

	# Run(type): "s" - normal (source) project run
	#	     "l" - compile from library
	#	     "L" - create library

	# this fills in the Run array
	process_args

	# initialize things
	initialize

	if { $Run(type) == "L" } {
		# do the make in the board directory
		if [catch { cd $SDirs(board) } err] {
			# just in case, shouldn't happen
			errabt "Cannot change to $SDirs(board), $err"
		}
	}

	# cleanup before build
	make_clean

	# build the list of directories to search
	build_directory_list

	# add extra defines
	add_extra_defines

	set NFound ""

	if { $Run(type) == "L" } {
		create_library
	} else {
		create_image
	}

	if { $NFound != "" } {
		puts -nonewline stdout "Warning: //+++ sources not found:"
		foreach fn $NFound {
			puts -nonewline stdout "  $fn "
		}
		puts ""
	}
}

main
