#!/bin/sh
###################\
exec tclsh "$0" "$@"
#
# Creates a standalone VUEE model from a compiled VUEE project; should be
# called under Cygwin in the project directory
#
###############################################################################

set CYGDLLS { "cyggcc_s-1.dll" "cygstdc++-6.dll" "cygwin1.dll" }

proc abt { m } {
	puts stderr $m
	exit 99
}

proc bad_args { } {

	global argv0

	abt "Usage: $argv0 \[target_directory_name\]"
}

proc parse_args { } {

	global argv TDIR

	set na [llength $argv]
	if { $na == 0 } {
		set TDIR [file join [pwd] "VUEEPACK"]
	} elseif { $na == 1 } {
		set TDIR [lindex $argv 0]
	} else {
		bad_args
	}
}

proc make_target_directory { } {

	global TDIR

	catch { file delete -force -- $TDIR }

	if [catch { file mkdir $TDIR } err] {
		abt "Cannot create $TDIR, $err"
	}
}

proc copy_cygwin_dlls { } {

	global TDIR CYGDLLS

	foreach f $CYGDLLS {
		if [catch { file copy [file join "/bin" $f] $TDIR } err] {
			abt "Cannot copy $f from /bin to $TDIR, $err"
		}
	}
}

proc copy_applib { } {

	global TDIR PP

	if [catch { exec sh picospath } PP] {
		abt "Cannot get PICOS path (picospath failure), $PP"
	}

	set pp [file join $PP "Apps" "DataLib"]

	set fl [glob -nocomplain -path "${pp}/" "*"]

	foreach f $fl {

		if [file isdirectory $f] {
			if [catch { file copy $f $TDIR } err] {
				abt "Cannot copy $f to $TDIR, $err"
			}
		}
	}
}

proc copy_data { } {

	global TDIR

	set fl [concat [glob -nocomplain "*.xml"] [glob -nocomplain "*.gif"]]

	foreach f $fl {
		if [catch { file copy $f $TDIR } err] {
			abt "Cannot copy $f to $TDIR, $err"
		}
	}
}

proc copy_side { } {

	global TDIR

	if ![file exists "side.exe"] {
		abt "Project not compiled for VUEE, no side.exe file"
	}

	if [catch { file copy "side.exe" $TDIR } err] {
		abt "Cannot copy side.exe to $TDIR, $err"
	}
}

proc wrap_script { pn } {

	global TDIR PP

	set tpn "${pn}.tcl"

	if { [catch { exec which $pn } ud] || ![file exists $ud] } {
		abt "Cannot locate $pn"
	}

	if [catch { exec cp $ud [file join $TDIR $tpn] } err] {
		abt "Cannot copy $pn to $TDIR, $err"
	}

	set CD [pwd]
	if [catch { cd $TDIR } err] {
		abt "Cannot cd to $TDIR, $err"
	}

	if [catch { exec fullwrap $tpn } err] {
		abt "Cannot wrap $pn, $err"
	}

	file delete -force $tpn

	cd $CD
}

proc read_config { } {

	global CONF

	set CONF ""

	if [catch { open "config.prj" "r" } fd] {
		puts "Warning: cannot open config.prj"
		return
	}

	if [catch { read $fd } CONF] {
		abt "Cannot read config.prj, $CONF"
	}
}

proc copy_supplementary_data { } {

	global CONF PP TDIR

	# get the list of boards

	set BL ""
	foreach { k v } $CONF {
		if { $k == "BO" } {
			set BL $v
			break
		}
	}

	if { $BL == "" } {
		puts "Warning: no boards assigned in project"
		return
	}

	# get the list of program types (app suffixes)
	set SU ""
	set fl [glob -nocomplain "app_*.cc"]
	if { $fl == "" } {
		if ![file isfile "app.cc"] {
			puts "Warning: no app... files in the directory"
			return
		}
	} else {
		foreach f $fl {
			regexp "^app_(.*).cc" $f jk su
			lappend SU $su
		}
		set SU [lsort $SU]
	}

	if { $SU == "" && [llength $BL] != 1 || $SU != "" && [llength $SU] != 
	     [llength $BL] } {
		puts "Warning: inconsistent board assignment"
		return
	}

	if { $SU == "" } {
		set SU [list ""]
	}

	set bd [file join $PP PicOS MSP430 BOARDS]

	foreach b $BL s $SU {
		set sd [file join $bd $b "node.xml"]
		if [file isfile $sd] {
			if { $s != "" } {
				set s "_$s"
			}
			set td [file join $TDIR "supp_node$s.xml"]
			if [catch { file copy $sd $td } err] {
				abt "Cannot copy $sd to $td, $err"
			}
		}
	}
}

proc copy_udaemon_plug { } {

	global CONF PP TDIR

	# get the list of boards

	set BL ""
	foreach { k v } $CONF {
		if { $k == "UDPL" } {
			set BL $v
			break
		}
	}

	if { $BL == "" } {
		return
	}

	if ![file isfile $BL] {
		puts "Warning: the udaemon plugin file $BL is missing"
		return
	}

	set td [file join $TDIR "shared_plug.tcl"]
	if [catch { file copy $BL $td } err] {
		abt "Cannot copy $BL to $td, $err"
	}
}

proc copy_piter_config { } {

	global TDIR

	if [file exists "config.pit"] {
		set td [file join $TDIR ".piterrc"]
		if [catch { file copy "config.pit" $td } err] {
			abt "Cannot copy config.pit to $td, $err"
		}
	}
}

proc check_reverse_y { } {

	global CONF

	if { [string first "YCDN 1" $CONF] >= 0 } {
		return 1
	}

	return 0
}

proc fix_runmodel { } {

	global TDIR

	if [catch { open "runmodel.tcl" "r" } fd] {
		abt "Cannot open runmodel.tcl in $TDIR"
	}

	if [catch { read $fd } rf] {
		abt "Cannot read runmodel.tcl in $TDIR"
	}

	catch { close $fd }

	regsub "\"-T\"" $rf "\"-T\" \"-R\"" rf

	if [catch { open "runmodel.tcl" "w" } fd] {
		abt "Cannot write runmodel.tcl in $TDIR"
	}

	puts -nonewline $fd $rf

	catch { close $fd }
}

proc wrap_runmodel { } {

	global TDIR PP

	if [catch { file copy [file join $PP "Scripts" "runmodel.tcl"] $TDIR } \
	    err] {
		abt "Cannot copy runmodel.tcl to $TDIR, $err"
	}

	set yr [check_reverse_y]

	set CD [pwd]
	if [catch { cd $TDIR } err] {
		abt "Cannot cd to $TDIR, $err"
	}

	if $yr {
		fix_runmodel
	}

	if [catch { exec fullwrap "runmodel.tcl" } err] {
		abt "Cannot wrap runmodel.tcl, $err"
	}

	file delete -force "runmodel.tcl"

	cd $CD
}

parse_args

read_config

puts "target directory: $TDIR"
make_target_directory

puts "copying side.exe ..."
copy_side

puts "copying Cygwin DLLs ..."
copy_cygwin_dlls

puts "copying AppLib files ..."
copy_applib

puts "copying data files ..."
copy_data
copy_supplementary_data
copy_udaemon_plug

puts "wrapping udaemon ..."
wrap_script "udaemon"

puts "wrapping piter ..."
wrap_script "piter"
copy_piter_config

puts "wrapping runmodel ..."
wrap_runmodel
