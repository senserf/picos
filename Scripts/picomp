#!/bin/sh
###################\
exec tclsh "$0" "$@"

###############################################################################
#
# Two in one:
#
#	1. PicOS to C compiler
#	2. PicOS to VUEE compiler
#
# Copyright (C) Olsonet Communications Corporation, 2010
#
###############################################################################

set Version 0.23

###############################################################################
###############################################################################

proc errab { m } {

	puts stderr $m
	exit 99
}

proc lappend_unique { li i } {

	upvar $li l

	if { ![info exists l] || [lsearch -exact $l $i] < 0 } {
		lappend l $i
	}
}

###############################################################################
###############################################################################

proc isalpha { c } {
#
# Applied to single characters only
#
	return [regexp -nocase "\[a-z_$\]" $c]
}

proc isnum { c } {
	return [regexp -nocase "\[0-9\]" $c]
}

proc ishex { c } {
	return [regexp -nocase "\[0-9a-f\]" $c]
}

proc isoct { c } {
	return [regexp -nocase "\[0-7\]" $c]
}

proc isalphanum { c } {
	return [regexp -nocase "\[a-z0-9_$\]" $c]
}

proc isspace { c } {
	return [regexp "\[ \t\n\r\]" $c]
}

proc iskwd { s } {
	return [regexp -nocase "^\[a-z_$\]\[a-z0-9_$\]*$" $s]
}

proc newlines { n } {
	set res ""
	while { $n } {
		append res "\n"
		incr n -1
	}
	return $res
}

###############################################################################
###############################################################################

proc o_initialize { } {
#
# Initializes for handling "structures", i.e., lists with name-tagged
# attributes
#
	global ot_

	foreach t [array names ot_] {
		# define the index constants
		global oa_$t
		set ix 0
		foreach a $ot_($t) {
			set oa_${t}($a) $ix
			incr ix
		}
		# build the access functions
		set pr ""
		# get
		append pr "proc g_$t \{ v a \} \{ \n"
		append pr "  global oa_$t\n"
		append pr "  return \[lindex \$v \$oa_${t}(\$a)\]\n"
		append pr "\}\n"
		# set
		append pr "proc s_$t \{ w a n \} \{ \n"
		append pr "  global oa_$t\n"
		append pr "  upvar \$w v\n"
		append pr "  while \{ \[llength \$v\] <= \$oa_${t}(\$a) \} \{ "
		append pr "lappend v \"\" \}\n"
		append pr "  set v \[lreplace \$v \$oa_${t}(\$a) "
		append pr "\$oa_${t}(\$a) \$n\]\n"
		append pr "\}\n"

		uplevel #0 $pr
	}
}

proc o_dump { v typ } {

	global ot_

	if ![info exists ot_($typ)] {
		errab "attempt to dump nonexistent structure type $typ"
	}

	dbg "DUMP <$typ>:"

	foreach at $ot_($typ) {
		dbg "$at: [g_$typ $v $at]"
	}

	dbg "END"
}

###############################################################################
# Special (reserved) words and their attributes ###############################
###############################################################################

#
# The meaning of bit flags (from left):
#
# 	- declaration (legal in declarations)
#	- legal in outer (zero-level) declarations
#	- legal in inner (auto) declarations
#	- legal in function arguments declarations
#	- type (specifies the type)
#	- the next word forcibly belongs to type (struct, union, enum),
#	  i.e., it cannot be a variable
#

set C_WORDS(auto)		{ 1 0 1 0 0 1 }
set C_WORDS(const)		{ 1 1 1 1 0 1 }
set C_WORDS(double)		{ 1 1 1 1 1 0 }
set C_WORDS(float)		{ 1 1 1 1 1 0 }
set C_WORDS(int)		{ 1 1 1 1 1 0 }
set C_WORDS(short)		{ 1 1 1 1 1 0 }
set C_WORDS(struct)		{ 1 1 1 1 0 1 }
set C_WORDS(unsigned)		{ 1 1 1 1 1 0 }
set C_WORDS(break)		{ 0 }
set C_WORDS(continue)		{ 0 }
set C_WORDS(else)		{ 0 }
set C_WORDS(for)		{ 0 }
set C_WORDS(long)		{ 1 1 1 1 1 0 }
set C_WORDS(signed)		{ 1 1 1 1 1 0 }
set C_WORDS(switch)		{ 0 }
set C_WORDS(void)		{ 1 1 1 1 1 0 }
set C_WORDS(case)		{ 0 }
set C_WORDS(default)		{ 0 }
set C_WORDS(enum)		{ 1 1 1 1 0 1 }
set C_WORDS(goto)		{ 0 }
set C_WORDS(register)		{ 1 1 1 1 0 1 }
set C_WORDS(sizeof)		{ 0 }
set C_WORDS(typedef)		{ 1 1 0 0 0 1 }
set C_WORDS(volatile)		{ 1 1 1 1 0 1 }
set C_WORDS(char)		{ 1 1 1 1 1 0 }
set C_WORDS(do)			{ 0 }
set C_WORDS(extern)		{ 1 1 0 0 0 1 }
set C_WORDS(if)			{ 0 }
set C_WORDS(return)		{ 0 }
set C_WORDS(static)		{ 1 1 1 0 0 1 }
set C_WORDS(union)		{ 1 1 1 1 0 1 }
set C_WORDS(while)		{ 0 }
## Our keywords
set C_WORDS(shared)		{ 1 0 1 0 0 1 }
set C_WORDS(idiosyncratic)	{ 1 1 0 0 0 1 }
set C_WORDS(trueconst)		{ 1 1 0 0 0 1 }
## C++ keywords (booked to avoid VUEE conflicts)
set C_WORDS(asm)		{ 0 }
set C_WORDS(dynamic_cast)	{ 0 }
set C_WORDS(namespace)		{ 0 }
set C_WORDS(reinterpret_cast)	{ 0 }
set C_WORDS(try)		{ 0 }
set C_WORDS(bool)		{ 0 }
set C_WORDS(explicit)		{ 0 }
set C_WORDS(new)		{ 0 }
set C_WORDS(static_cast)	{ 0 }
set C_WORDS(typeid)		{ 0 }
set C_WORDS(catch)		{ 0 }
set C_WORDS(false)		{ 0 }
set C_WORDS(operator)		{ 0 }
set C_WORDS(template)		{ 0 }
set C_WORDS(typename)		{ 0 }
set C_WORDS(class)		{ 0 }
set C_WORDS(friend)		{ 0 }
set C_WORDS(private)		{ 0 }
set C_WORDS(this)		{ 0 }
set C_WORDS(using)		{ 0 }
set C_WORDS(const_cast)		{ 0 }
set C_WORDS(inline)		{ 0 }
set C_WORDS(public)		{ 0 }
set C_WORDS(throw)		{ 0 }
set C_WORDS(virtual)		{ 0 }
set C_WORDS(delete)		{ 0 }
set C_WORDS(mutable)		{ 0 }
set C_WORDS(protected)		{ 0 }
set C_WORDS(true)		{ 0 }
set C_WORDS(wchar_t)		{ 0 }

proc catt { k } {

	global C_WORDS

	if ![info exists C_WORDS($k)] {
		return ""
	}

	return $C_WORDS($k)
}

###############################################################################
###############################################################################

proc xerror { msg { lnu "" } } {
#
# An error message (with line number)
#
	global PS ErrCnt RepErr FG

	if { $lnu == "" } {
		set ln $PS(LIN)
		set lf $PS(LIF)
	} else {
		set ln [lindex $lnu 0]
		set lf [lindex $lnu 1]
	}

	set erc "$lf:$ln"
	if [info exists RepErr($erc)] {
		# do not report more than one error per line per file
		return
	}
	set RepErr($erc) ""

	set msg "$erc: $msg"
	puts stderr $msg
	append_status $msg

	if $FG(D) { dbg "$msg" }

	if $FG(A) {
		# abort on first error
		if ![all_warnings $msg] {
			set msg "aborting on first error"
			puts stderr $msg
			append_status $msg
			append_status_end
			exit 99
		}
	}

	# parser error count
	incr PS(ERC)

	# global error count
	incr ErrCnt

	if { $ErrCnt > 15 } {
		set msg "$erc: too many errors"
		puts stderr $msg
		append_status $msg
		append_status_end
		exit 99
	}
}

proc xsterr { { bra "" } } {
#
# Unexpected EOF error
#
	if { $bra != "" } {
		set t "unmatched "
		if { $bra == 1 } {
			append t "one \{"
		} else {
			append t "$bra \{'s"
		}
		xerror "$t at the end of file"
	} else {
		xerror "unterminated construct causing premature EOF"
	}
	exit 99
}

proc initialize_parser { src { lnu "" } } {

	global PS

	# the input
	set PS(SRC) $src

	# bracket level
	set PS(BRL) 0

	# beginning of line flag
	set PS(BOP) 1
	set PS(BOL) 1

	# index into source
	set PS(INX) 0

	# line count/file
	if { $lnu != "" } {
		set PS(LIN) [lindex $lnu 0]
		set PS(LIF) [lindex $lnu 1]
	} else {
		set PS(LIN) -1
		set PS(LIF) "none"
	}

	# output
	set PS(TAR) ""

	set PS(LON) 0
	set PS(LOF) ""

	# output BOL flag
	set PS(BQL) 1

	# error count
	set PS(ERC) 0
}

proc close_parser { } {

	array unset PS
}

proc output { } {

	global PS

	return $PS(TAR)
}

proc getC { } {
#
# Read next character from the parser's input
#
	global PS

	set c [string index $PS(SRC) $PS(INX)]

	if { $c != "" } {
		incr PS(INX)
	}

	if $PS(BOP) {
		set PS(BOL) 1
		incr PS(LIN)
	} else {
		set PS(BOL) 0
	}

	if { $c == "\n" } {
		set PS(BOP) 1
	} else {
		set PS(BOP) 0
	}

	return $c
}

proc peekC { } {
#
# Peek at next character
#
	global PS
	return [string index $PS(SRC) $PS(INX)]
}

proc putC { c } {
#
# Single character write to the parser's output
#
	global PS

	if { $PS(BQL) && $c != "#" } {
		# synchronize line numbers
		catchup
	}

	append PS(TAR) $c

	if { $c == "\n" } {
		incr PS(LON)
		set PS(BQL) 1
	} else {
		set PS(BQL) 0
	}
}

proc putS { s } {
#
# Append a string at the end of the parser's output
#
	global PS

	append PS(TAR) $s
	incr PS(LON) [regexp -all "\n" $s]
	set PS(BQL) [regexp "\n$" $s]
}

proc catchup { { lnu "" } } {
#
# Catch up with line numbers, i.e., make sure that the effective line number
# at the current place in the parser's output is the same as on input; if the
# argument is missing, we mean the parser's input
#
	global PS FG

	if { $lnu == "" } {
		set lin $PS(LIN)
		set lif $PS(LIF)
	} else {
		set lin [lindex $lnu 0]
		set lif [lindex $lnu 1]
	}

	while 1 {

		if { $lif != $PS(LOF) } {
			# different files, need an explicit reset
			if $FG(D) {
				dbg "catchup: different files\
					$lif != $PS(LOF)"
			}
			break
		}

		set dif [expr $lin - $PS(LON)]

		if { $dif == 0 } {
			# in perfect sync
			return
		}

		if $FG(D) { dbg "catchup: diff = $dif, $lin, $PS(LON)" }

		# here is a simple optimizer for the number of line
		# resequencing inserts

		if { $dif < 0 } {
			# first try to remove empty lines from the output tail,
			# but never remove the last one
			set tl [string length $PS(TAR)]
			set ll -1
			set nc 0
			while { $tl > 0 } {
				incr tl -1
				set c [string index $PS(TAR) $tl]
				if ![isspace $c] {
					# sorry
					if $FG(D) {
					    dbg "catchup: optA $dif, $nc, $ll"
					}
					if { $ll >= 0 } {
						# the last one must be skipped
						if { $nc < 0 } {
							incr nc
						}
						# it has helped a bit, we have
						# reduced the difference
						set PS(TAR) [string range \
							$PS(TAR) 0 $ll]
						set PS(LON) \
							[expr $PS(LON) + $nc]
						set PS(BQL) 1
						set dif [expr $dif - $nc]
					}
					break
				}
				if { $c == "\n" } {
					if { $nc == $dif } {
						# we are fine, this one stays
						set PS(TAR) [string range \
							$PS(TAR) 0 $tl]
						set PS(LON) $lin
						set PS(BQL) 1
						if $FG(D) {
							dbg "catchup: optA OK"
						}
						return
					}
					# remember location of the last one
					set ll $tl
					incr nc -1
				}
			}
		}

		if { $dif < 0 && $lnu == "" } {
			# second stage optimization: look at the input and
			# skip any empty lines from its front; note that we
			# are invoked at token boundaries, so we should be
			# safe
			set tl $PS(INX)
			while 1 {
				set c [string index $PS(SRC) $tl]
				if ![isspace $c] {
					if $FG(D) {
						dbg "catchup: optB $dif, $c"
					}
					break
				}
				incr tl
				if { $c == "\n" } {
					incr dif
					if { $dif == 0 } {
						# done, make it look advanced
						# past the EOL
						set PS(BOP) 0
						set PS(BOL) 1
						set PS(LIN) $PS(LON)
						set PS(INX) $tl
						if $FG(D) {
						 dbg "catchup: optB OK $PS(LIN)"
						}
						return
					}
				}
			}
		}
					
		if { $dif > 16 || $dif < 0 } {
			# difference too big or negative, must be forced by an
			# explicit line number sequence
			break
		}

		# just insert eols
		append PS(TAR) [newlines $dif]
		set PS(LON) $lin
		return
	}

	setlnum [list $lin $lif]
}

proc lnumseq { lnu } {
#
# Convert a line number (number, file name) into a sequence to be inserted into
# file
#
	global FG

	if $FG(D) { dbg "lnumseq: [lindex $lnu 0]" }
	return  "#$FG(EC) [lindex $lnu 0] \"[lindex $lnu 1]\"\n"
}

proc setlnum { lnu } {
#
# Set the line number at the current point of the parser's output to an
# explicit value
#
	global PS

	set PS(LON) [lindex $lnu 0]
	set PS(LOF) [lindex $lnu 1]

	if !$PS(BQL) {
		append PS(TAR) "\n"
		set PS(BQL) 1
	}

	append PS(TAR) [lnumseq $lnu]
}

proc parse_lnum { } {
#
# Parse a line number sequence in the parser's input
#
	global PS FG

	set cmd ""

	set S $PS(SRC)
	set I $PS(INX)

	while 1 {

		set c [string index $S $I]
		if { $c == "" } {
			break
		}

		incr I

		if { $c == "\n" } {
			break
		}

		append cmd $c
	}

	if [regexp "^(line)? *(\[0-9\]+) +\"(.*)\"" $cmd jnk FG(EC) ln fi] {

		# will be bumped on BOP
		set PS(LIN) [expr $ln - 1]

		if { [string first "___pcs___" $fi] >= 0 } {
			# clean up the name for error reports
			regsub ".*___pcs___" $fi "" fi
			regsub "\\.c$" $fi ".cc" fi
		}

		set PS(LIF) $fi
		set PS(INX) $I
		set PS(BOP) 1

		return 1
	}

	return 0
}

proc brcnt { } {
#
# Return current bracket level on input
#
	global PS
	return $PS(BRL)
}

proc endfile { } {
#
# Returns 1, if we are at the end of the parser's input
#
	global PAR_IT

	if { $PAR_IT == "e" || $PAR_IT == "f" } {
		return 1
	}
	return 0
}

proc getmark { } {
#
# Produce a "mark" representing the parser's state, e.g., to be reverted to
#
	global PS

	return [list [string length $PS(TAR)] $PS(LON) $PS(LOF) \
		$PS(BQL) $PS(BRL) $PS(BOP) $PS(BOL) $PS(INX) $PS(LIN) \
		$PS(LIF) ]
}

proc getmarq { } {
#
# Same as getmark, except that the input is backspaced one character (needed
# by ntoken, which grabs the mark after swallowing the first character of the
# token)
#
	global PS

	set ix [expr $PS(INX) - 1]
	return [list [string length $PS(TAR)] $PS(LON) $PS(LOF) \
		$PS(BQL) $PS(BRL) $PS(BOP) $PS(BOL) $ix $PS(LIN) \
		$PS(LIF) ]
}

proc truncate { mark } {
#
# Truncate the output to the mark, i.e., restore the output side of the parser
# state as it was when the mark was taken
#
	global PS

	set sl [lindex $mark 0]
	set li [lindex $mark 1]
	set lf [lindex $mark 2]
	set bq [lindex $mark 3]

	set PS(TAR) [string range $PS(TAR) 0 [expr $sl - 1]]
	set PS(LON) $li
	set PS(LOF) $lf
	set PS(BQL) $bq
}

proc backtrack { mk } {
#
# Restore the input to the mark
#
	global PS

	set PS(BRL) [lindex $mk 4]
	set PS(BOP) [lindex $mk 5]
	set PS(BOL) [lindex $mk 6]
	set PS(INX) [lindex $mk 7]
	set PS(LIN) [lindex $mk 8]
	set PS(LIF) [lindex $mk 9]
}

proc restore { mk } {
#
# Restore the complete parser state (both sides) to the mark
#
	global PS

	truncate $mk
	backtrack $mk
}

proc ilinenum { mk } {
#
# Extract the input line number from the mark
#
	global PS

	return [lrange $mk 8 9]
}

proc olinenum { mk } {
#
# Extract the output line number from the mark
#
	global PS

	return [lrange $mk 1 2]
}

proc insert { mk ins } {
#
# Insert text into output at the mark; anything following the mark will appear
# after the insert
#
	global PS FG

	set sl [lindex $mk 0]
	set txt [string range $PS(TAR) 0 [expr $sl - 1]]
	append txt $ins
	append txt "\n"
	append txt [lnumseq [olinenum $mk]]
	append txt [string range $PS(TAR) $sl end]
	set PS(TAR) $txt
}

proc ntoken { } {
#
# Returns the next token from the parser's input; the token is swallowed;
# PAR_IT tells the type, which can be: "k" (keyword), "n" (numeric, i.e., like
# a keyword starting from a digit), "d" (delimiter), "s" (string or a comment),
# "e" (end of file), "f" (failed end of file, i.e., EOF within a string).
#
# Note that strings and comments are treated similarly, except that comments
# are always returned as empty tokens, i.e., PAR_IT is "s", but the returned
# value is "". This cannot happen for a string, even if it is empty, because
# it includes the delimiters ("..." or ','). The idea is that the program can
# be recombined by simply concatenating the tokens successively returned by
# ntoken, as long as you make sure to insert one space between two conecutive
# keywords/numwords.
#
# The function atomatically outputs the scanned characters to the parser's
# output. If you want to replace something there, use marks, inserts, etc.
#
# PAR_MARK is automatically set to the position immediately in front of the
# token being returned.
#
	global PAR_IT PAR_MARK PS

	set ws ""

	while 1 {

		set c [getC]

		if { $ws != "" } {
			# within a string or comment
			if { $c == "" } {
				# premature end
				break
			}
			if { $c == "\\" } {
				# collect the string token
				append as $c
				putC $c
				set c [getC]
				if { $c == "" } {
					# premature end
					break
				}
				append as $c
				putC $c
				continue
			}

			if { $c == "\n" && $ws == "/" } {
				# exit comment; we do not return them as tokens
				unset as
				set ws ""
				putC $c
				continue
			}

			append as $c
			putC $c
			if { $c == $ws } {
				if { $c == "*" } {
					# closing comment
					set c [getC]
					if { $c == "" } {
						break
					}
					append as $c
					putC $c
					if { $c != "/" } {
						# sorry
						continue
					}
					# end of comment
					unset as
					set ws ""
				} elseif { $c != "/" } {
					# terminate string
					set PAR_IT "s"
					set ws ""
					return $as
				}
			}
			continue
		}

		if [isspace $c] {
			putC $c
			continue
		}

		if { $c == "" } {
			set PAR_IT "e"
			return ""
		}

		set PAR_MARK [getmarq]

		if [isalphanum $c] {

			putC $c

			# handle a keyword
			if [isalpha $c] {
				# item type == keyword
				set PAR_IT "k"
			} else {
				# looks like a number?
				set PAR_IT "n"
			}

			set as $c

			while 1 {

				set c [peekC]

				if ![isalphanum $c] {
					return $as
				}

				append as $c
				putC $c
				getC
			}
		}

		set PAR_IT "d"

		switch -- $c {

			"#" {
				if $PS(BOL) {
					if [parse_lnum] {
						continue
					}
				}

				# treat as a token
				putC $c
				return $c
			}

			"'" -
			"\"" {
				putC $c
				# start string
				set as $c
				set ws $c
				continue
			}

			"/" {
				putC $c
				set c [peekC]
				if { $c == "/" || $c == "*" } {
					set as "/$c"
					set ws $c
					putC $c
					getC
					continue
				}
				return "/"
			}

			"\}" {
				putC $c
				incr PS(BRL) -1
				return "\}"
			}

			"\{" {
				putC $c
				incr PS(BRL)
				return "\{"
			}

		  	default {

				putC $c
				return $c
			}
		}
	}

	set PAR_IT "f"
	return ""
}

###############################################################################

proc legcs { c } {
#
# Legitimate delimiters in structures
#
	return [regexp "\[;,\{\}\\\[\\\]:\\\*\\\(\\\)\]" $c]
}

###############################################################################
# Parser for declarations #####################################################
###############################################################################
#
# Attributes (atts) referring to a variable or type name
#
set ot_(atts)	[list typ ptr fpt arg arr bif ini]
#
# typ	- type: v (variable), f (function), a (function announcement),
#		p (function pointer)
# ptr	- pointer count (the number of asterisks)
# fpt	- pointer count for a function pointer
# arg	- function arguments, if a function or function pointer
# arr	- array dimensions
# bif	- bit field
# ini	- initializer
#

#
# Variable declaration: <name atts>; sometimes there is a third item: old name
#
set ot_(vdec)	[list nam att old]

#
# Variable declaration list: <type, lineseq, prefix, varlist>
#
# Type = V (variables only), A (function announcements only), M (mixed),
#	 F (function declaration)
#
set ot_(vdl)	[list typ lnu pfx vrs]

#
# Type declaration
#
# lnu	- line sequencer
# tna	- type name
# bod	- declaration body
# var	- attribute variable
# mod	- mode
#
set ot_(tdec)	[list lnu tna bod var mod]

###############################################################################

proc parse_decl { { af 1 } { xp 0 } { bf 0 } } {
#
# af -> context: 1 - outer level, 2 - inner level, 3 - arguments (of fsm);
#       3 means that a comma terminates the declaration, as opposed to
#	separating variables of the same type; also the variable can be empty
#	(like in an announcement) - the last bit doesn't work yet
#
# xp -> expected, meaning the thing must be a declaration; otherwise, we have
#	an error
#
# bf -> bit fields legal (parsing attribute list in a structure or union)
#
#
# Called after the first token (which must be a symbol) has been already read
#
####
#
# On exit:
#
# PAR_MARK is set to the beginning of the declaration.
#
# If the function returns not null, it is a variable or function declaration.
# A type declaration is returned via PAR_TDEC. If both values are null, it is
# either an error or a non-declaration construct.
#
# After parsing an argument item, the delimiter is left in TK/PAR_IT.
#
	global TK PAR_MARK PAR_IT PAR_TDEC FG C_WORDS

	if { $PAR_IT != "k" } {
		if { $PAR_IT == "d" && $TK == "(" && $xp } {
			# can be an implicitly void function pointer
			xerror "illegal declaration, if this is a pointer to\
			    void function, use explicit (void) type in front"
		}
		return ""
	}

	set pfx [list $TK]
	# variable list
	set vrs ""

	# remember where it starts
	set dec_mark $PAR_MARK
	# line of the declaration
	set vli [ilinenum $dec_mark]

	if $FG(D) { dbg "parse_decl: line $vli" }

	# to be reset on a per-variable basis:

	set typ "v"	;# simple variable
	set nam ""	;# variable name
	set ptr 0	;# outer pointer level
	set fpt 0	;# inner pointer (for function pointers)
	set arg ""	;# arguments (for function or function pointer)
	set arr ""	;# array dimensions
	set bif ""	;# bit field (textual, never verified)
	set ini ""	;# initializer

	set fpf 0	;# function pointer processing stages

	###

	# extern flag
	set exn 0

	# number of variables
	set nva 0
	# number of function announcements
	set nfa 0
	# function declaration flag, can only be zero or one
	set nfd 0
	#######################################################################

	set PAR_TDEC ""

	# type body
	set bod ""
	# type name (not null means that we do have a type declaration)
	set tna ""

	#
	# type completeness status:
	#	0 - no type yet
	#	1 - symbol expected to continue type declaration; if that
	#	    symbol is not a special keyword, the type will become
	#	    complete, unless we have a type declaration of the
	#	    struct (union, enum) kind
	#	2 - sufficient for type, the next keyword is a variable,
	#	    unless it is a type keyword, like in long int
	#	3 - complete type, the next keyword must be a variable
	#

	# default assuming user symbol; a non-special symbol opening a
	# declaration must be a user (typedef-ed) type name
	set tcs 3

	# type only declaration OK, set for opening struct, union, enum, but
	# not for typedef, which is handled like a variable declaration
	set tp_only_ok 0

	# brace level
	set blev [brcnt]

	set more 1

	if $FG(D) { dbg "parse_decl: token 0 = $TK" }

	set kat [catt $TK]

	if { $kat != "" } {
		if { [lindex $kat 0] == 0 } {
			if $xp {
				xerror "illegal keyword $TK in declaration"
			}
			return ""
		}

		if { [lindex $kat $af] == 0 } {
			if $xp {
				xerror "qualifier $TK illegal in this context"
			}
			return ""
		}

		if [lindex $kat 5] {
			# type continuation expected
			set tcs 1
		}
		if [lindex $kat 4] {
			# defines a type
			set tcs 2
		} else {
			set tcs 0
		}

		if { $TK == "struct" || $TK == "union" || $TK == "enum" } {
			# this can be a type declaration, because it starts with
			# struct/union, but it doesn't have to
			set dstate "S"
			# start this tentatively; if there's no name to the
			# thing, this will be cancelled
			set tna $TK
			# type-only declaration legal; meaning that a variable
			# at the end is not needed, but legit; does not apply
			# to typedef, which is handled separately at the end;
			# at this stage, typedef is viewed as an honorary
			# variable declaration and processed as such to the
			# very end
			set tp_only_ok 1
		} else {
			if { $TK == "extern" } {
				# the extern flag is presently used for
				# admitting unsized arrays in extern
				# declarations; such arrays cannot appear in
				# variable declarations, unless there is an
				# initializer providing the size
				set exn 1
			}
			set dstate "P"
		}
	} else {
		# user symbol opens the declaration; this is a complete type,
		# so we should proceed at the "variable" state
		set dstate "M"
	}

	while { $more } {

	    set TK [ntoken]
	    set rep 1

	    while { $rep } {

		set rep 0

	  	if [endfile] {
			xerror "incomplete declaration, premature end of file"
			return ""
		}

		if $FG(D) { dbg "parse_decl: <$dstate> $PAR_IT $TK" }

		switch $dstate {

P {
###############################################################################
# collecting type prefix ######################################################
###############################################################################
	if { $PAR_IT == "k" } {

		set kat [catt $TK]

		if { $kat == "" } {
			if { $tcs >= 2 } {
				# assume this is a variable
				set rep 1
				set dstate "M"
				continue
			}
			# completes the type part
			lappend pfx $TK
			set tcs 3
			# so the next one is a variable
			set dstate "M"
			continue
		}

		# a standard keyword
		if { $tcs == 3 || [lindex $kat 0] == 0 } {
			# type complete or a non-declaration keyword
			if $xp {
				xerror "illegal keyword $TK in declaration"
			}
			return ""
		}

		if { [lindex $kat $af] == 0 } {
			if $xp {
				xerror "keyword $TK illegal in this context"
			}
			return ""
		}

		# goes into the type part for sure
		lappend pfx $TK

		if { $TK == "typedef" } {
			# a special case: the prefix must be empty for that
			# (when we are here, what we are seeing is not the
			# first symbol)
			if $xp {
				xerror "typedef preceded by garbage"
			}
		} elseif { [lindex $kat 5] != 0 } {
			# continuation expected, covers struct, union, enum
			if { $TK == "union" || $TK == "struct" ||
			   $TK == "enum" } {
				if $tcs {
					if $xp {
						xerror "illegal prefix for $TK"
					}
					return ""
				}
				# type name
				set tna $TK
				set dstate "S"
			}
			set tcs 1
		} elseif { [lindex $kat 4] != 0 } {
			# sufficient for a complete type
			set tcs 2
		} elseif { $TK == "extern" } {
			if $tcs {
				if $xp {
					xerror "misplaced extern"
				}
				return ""
			}
			set exn 1
		}
		continue
	}

	if { $PAR_IT != "d" } {
		if $xp {
			xerror "illegal declaration syntax, name or\
				delimiter expected"
		}
		return ""
	}

	if { $tcs < 2 } {
		if $xp {
			xerror "illegal delimiter $TK in this context"
		}
		return ""
	}

	set tcs 3

	# delimiter: this is where we want to go whatever happens next, unless
	# there is an error
	set dstate "M"

	if { $TK == "*" } {
		# makes it a pointer, the variable name must be behind, proceed
		# at "M"
		set rep 1
		continue
	}

	if { $TK == "(" } {
		# this can be a function pointer or a function (announcement
		# or declaration)
		set tol [ntoken]
		if { $PAR_IT == "d" && $tol == "*" } {
			# a function pointer, variable name is behind; fpf is
			# set to 1 which indicates an "open" function pointer
			# expecting a closing )
			set fpf 1
			set typ "p"
			# start counting asterisks
			set fpt 1
			# proceed at "M"
			continue
		}
		# fall through
	}

	# something wrong
	if $xp {
		xerror "illegal delimiter $TK in declaration"
	}

	return ""
}

M {
###############################################################################
# expecting a variable or its prefix ##########################################
###############################################################################

	if { $PAR_IT == "k" } {
		# the variable name
		set nam $TK
		# check if not one of the reserved keywords
		if { [catt $nam] != "" } {
			if $xp {
				xerror "illegal variable name $nam"
			}
			return ""
		}
		set dstate "N"
		continue
	}

	if { $PAR_IT != "d" } {
		if $xp {
			xerror "illegal declaration syntax, expected name\
				or delimiter"
		}
		return ""
	}

	if { $TK == "*" } {
		if $fpf {
			# these count to the function pointer
			incr fpt
		} else {
			# the outer pointer
			incr ptr
		}
		continue
	}

	if { $TK == "(" } {
		# a function pointer; note that for a function announcement
		# or declaration a symbol (name) must show up first (so that
		# would be handled at "N")
		if $fpf {
			if $xp {
				# be careful with jumping to conclusions
				xerror "illegal function pointer declaration"
			}
			return ""
		}
		# function pointer declaration opened
		set fpf 1
		set typ "p"
		continue
	}

	if $xp {
		xerror "illegal token '$TK' in declaration"
	}
	return ""
}

N {
###############################################################################
# handling whatever follows variable name #####################################
###############################################################################

	if { $PAR_IT != "d" } {
		# it must be a delimiter, nothing else
		if $xp {
			xerror "illegal declaration syntax, delimiter expected"
		}
		return ""
	}

	if { $TK == "\[" } {
		# array
		if { $arr != "" || $fpf > 1 || $bif != "" } {
			# only legal if not already defined; for a function
			# pointer, it must immediately follow the variable
			# name, so it is only legal in the "open" state
			if $xp {
				xerror "illegal array dimension"
			}
			return ""
		}
		set arr [get_array]
		if { $arr == "" } {
			# get_array doesn't diagnose
			if $xp {
				xerror "illegal syntax of array dimension"
			}
			return ""
		}
		# get_array swallows the token (so we are looking at the
		# delimiter past last closing \]), but leaves PAR_IT fine
		set rep 1
		continue
	}

	if { $TK == ":" } {
		# bit field? checking is very superficial at this time
		if { !$bf || $arr != "" || $fpf || $ptr } {
			xerror "bit fields are not legal in this context"
			return ""
		}
		set bif [ntoken]
		if { $PAR_IP != "n" } {
			xerror "illegal bit field"
			return ""
		}
	}

	if { $TK == "(" } {
		# may be a function declaration
		if { $fpf == 1 } {
			# open function pointer, illegal
			xerror "illegal function pointer declaration"
			return ""
		}
		if { $arg != "" } {
			# we don't want this any more
			xerror "illegal ( in declaration"
			return
		}
		if { $fpf == 2 } {
			# closed function pointer -> arguments expected
			set arg "([get_args])"
			if { $TK != ")" } {
				# get_args does diagnose
				return ""
			}
			set fpf 3
			continue
		}

		# not a function pointer

		if { $arr != "" } {
			xerror "illegal array looking like a function"
			return ""
		}

		# sanity check
		if $fpf {
			xerror "confusing function pointer declaration"
			return ""
		}

		# function announcement
		set typ "a"
		set arg "([get_args])"
		if { $TK != ")" } {
			return ""
		}
		if $FG(D) { dbg "parse_decl: <args> = $arg" }
		set dstate "U"
		continue
	}

	if { $TK == ")" } {
		if { $fpf == 1 } {
			# the only situation when we expect one at this stage
			set fpf 2
			continue
		}
		# or as a closing delimiter, if we are parsing arguments
		if { $af == 3 } {
			xerror "illegal ) in declaration"
			return ""
		}
	} elseif { $TK == "=" } {
		# an initializer
		set ini [get_init]
		if { $ini == "" } {
			# diagnosed
			return ""
		}
		if { $TK != "," && $TK != ";" } {
			xerror "illegal delimiter after initializer"
			return ""
		}
		set PAR_IT "d"
		# fall through
	}

	if { $fpf > 0 && $fpf != 3 } {
		# this means we have closed, but still haven't seen the args
		xerror "missing args in function pointer declaration"
		return ""
	}

	if { $TK != "," && $TK != ";" && $TK != ")" } {
		# the last case is for parsing arguments, note that it can
		# only happen here, if its legitimacy has been verified (see
		# above)
		xerror "illegal $TK in declaration"
		return ""
	}

	# completed one variable (possibly typedef name)

	if { !$exn && $arr != "" } {
		# validate the size and possibly fix the dimension; do not
		# do this for externs, only for storage-reserving declarations
		set dim [get_dimensions $arr]
		if $FG(D) {
			dbg "parse_decl: dimensions $arr -> $dim"
		}
		if { $dim == "" } {
			# diagnosed
			return ""
		}
		if { [lindex $dim 0] == "" } {
			if { [lindex $pfx 0] == "typedef" } {
				xerror "picomp prohibits empty size in array\
					typedefs"
				return ""
			}
			# only allowed if initialized
			if { $ini == "" } {
				xerror "empty size only allowed with an\
					initializer"
				return ""
			}
			set len [lindex $ini 1]
			# this is the length
			if { $len == 0 } {
				xerror "illegal initializer for an array"
				return ""
			}
			set arr "\[$len\]"
			set dim [lrange $dim 1 end]
			foreach d $dim {
				append arr "\[$d\]"
			}
			if $FG(D) {
				dbg "parse_decl: fixed dim: $arr"
			}
		}
	}

	set a ""
	s_atts a typ $typ
	s_atts a ptr $ptr
	s_atts a fpt $fpt
	s_atts a arg $arg
	s_atts a arr $arr
	s_atts a bif $bif
	s_atts a ini $ini

	set v ""
	s_vdec v nam $nam
	s_vdec v att $a

	if $FG(D) {
		dbg "parse_decl: <var dcl>"
		o_dump $v vdec
	}

	lappend vrs $v

	incr nva

	if { $TK == ";" || $TK == ")" || $af == 3 } {
		# with af == 2 (parsing arguments), we stop on any legit
		# delimiter, which can be either , or )
		set more 0
	}

	set dstate "X"
}

X {
###############################################################################
# cleanup after handling a variable ###########################################
###############################################################################

	set typ "v"
	set nam ""
	set ptr 0
	set fpt 0
	set arg ""
	set arr ""
	set bif ""
	set ini ""
	set fpf 0

	set dstate "M"
	set rep 1
}

U {
###############################################################################
# function declaration or announcement ########################################
###############################################################################

	if { $PAR_IT != "d" } {
		xerror "illegal function declaration"
		return ""
	}

	if { $TK == "\{" } {
		# this is an actual function declaration, as
		# opposed to an announcement
		if { $vrs != "" } {
			# must be alone
			xerror "illegal declaration"
			return ""
		}

		set typ "f"

		incr nfd
		set more 0
	} else {
		# set extern flag for this
		set exn 1
	}

	set a ""
	s_atts a typ $typ
	s_atts a ptr $ptr
	s_atts a fpt $fpt
	s_atts a arg $arg
	s_atts a arr $arr
	# bif must be null, anyway
	s_atts a ini $ini

	set v ""
	s_vdec v nam $nam
	s_vdec v att $a

	if $FG(D) {
		dbg "parse_decl: <fun dcl> = $v"
		o_dump $v vdec
	}

	lappend vrs $v

	if $more {
		# not a function declaration, expect a comma or semi
		if { $TK != "," && $TK != ";" } {
			xerror "illegal declaration, ; or , expected"
			return ""
		}
		if { $TK == ";" } {
			set more 0
		}
		incr nfa
	}

	set dstate "X"
}
		
S {
###############################################################################
# struct or union #############################################################
###############################################################################

	set dstate "W"

	if { $PAR_IT == "k" } {
		# this may look like a type declaration
		set struct_named 1
		# this gives us the complete type name
		if { [catt $TK] != "" } {
			if $xp {
				xerror "illegal name of struct, union, or enum:\
					$TK"
			}
			return ""
		}
		append tna " $TK"
		lappend pfx $TK
	} else {
		set struct_named 0
		# cannot be type-only, because it cannot be type
		set tp_only_ok 0
		# not a type declaration (unless typedef, which is a different
		# story)
		set tna ""
		# do not read next token, have got it already
		set rep 1
	}
}
		
W {
###############################################################################
# struct or union body ########################################################
###############################################################################

	if { $PAR_IT != "d" || $TK != "\{" } {
		# doesn't provide the body
		if !$struct_named {
			# illegal because there's no structure name reference
			xerror "illegal reference to struct or union,\
				name required"
			# should we try to skip to a semi or something?
			return ""
		}
		set tp_only_ok 0
		# type reference rather than type declaration
		set bod $tna
		# this says we don't have a type declaration
		set tna ""
		# this must be a variable prefix or the variable itself
		set rep 1
		set dstate "M"
		continue
	}

	# note that tna has been determined at "S"
	set bod [get_tbody]
	if { $bod == "" } {
		# error (diagnosed)
		return ""
	}
	if $FG(D) { dbg "parse_decl: <body> = $bod" }
	# should be easy to find
	if { $tna == "" } {
		# no need to include the body when tna is set, as it will be
		# declared separately
		lappend pfx $bod
	}
	# now, check if this can be a sole type declaration
	set TK [ntoken]
	if { $PAR_IT == "d" && $TK == ";" } {
		# this looks like a type declaration
		if !$tp_only_ok {
			xerror "variable name expected before ;"
			return ""
		}
		# exit the parse loop
		set more 0
		continue
	}
	# not a semi, can only be a variable list
	set rep 1
	set dstate "M"
}
		  default {

			xerror "illegal state $dstate in parse_decl,\
				internal error"
			exit 99
		  }
		}
	    }
	}

	set PAR_MARK $dec_mark

	# type list to return, there may be more than one, like in:
	# typedef struct a \{ ... \} muka;

	if { $tna != "" } {
		# we have one attribute-less type; note that it has been
		# declared as a side effect of declaring the main object;
		# thus, its body has been removed from the main object
		# and replaced by reference, say:
		# typedef struct A \{ ... \} B; becomes:
		# struct A \{ ... \};
		# typedef struct A B;
		set v ""
		s_tdec v lnu $vli
		s_tdec v tna $tna
		s_tdec v bod $bod
		s_tdec v var ""
		s_tdec v mod 0
		if $FG(D) {
			dbg "parse_decl: <type>"
			o_dump $v tdec
		}
		lappend PAR_TDEC $v
	}

	# check for typedef; if the first pfx symbol is typedef, there must be
	# a single "variable" (no initializer) which is the name of the defined
	# type

	if { [lindex $pfx 0] == "typedef" } {
		if { [llength $vrs] != 1 } {
			xerror "typedef syntax error, looks like multiple type\
				names"
			return ""
		}
		# convert it to a type declaration
		set vrs [lindex $vrs 0]

		set nam [g_vdec $vrs nam]
		set att [g_vdec $vrs att]

		set typ [g_atts $att typ]
		set ini [g_atts $att ini]

		if { $typ == "a" || $typ == "f" || $ini != "" } {
			xerror "typedef syntax error, illegal type attributes"
			return ""
		}

		set v ""
		s_tdec v lnu $vli
		s_tdec v tna $nam
		s_tdec v bod $pfx
		s_tdec v var $vrs
		s_tdec v mod 1

		if $FG(D) {
			dbg "parse_decl: <typedef>"
			o_dump $v tdec
		}
		lappend PAR_TDEC $v
		return ""
	}

	if { $vrs == "" } {
		# type only
		return ""
	}

	if $nfd {
		# function declaration (body)
		set typ "F"
	} elseif { $nva && !$nfa } {
		# variables only
		set typ "V"
	} elseif { $nfa && !$nva } {
		# function announcements only
		set typ "A"
	} else {
		# mixed
		set typ "M"
	}

	set v ""
	s_vdl v typ $typ
	s_vdl v lnu $vli
	s_vdl v pfx $pfx
	s_vdl v vrs $vrs
	if $FG(D) {
		dbg "parse_decl: <declaration>"
		o_dump $v vdl
	}
	return $v
}

proc isfundec { v } {
#
# Returns 1 if the declared item is a function announcement
#
	if { [g_atts [g_vdec $v att] typ] == "a" } {
		return 1
	}
	return 0
}

###############################################################################
# functions for handling initializers #########################################
###############################################################################

proc get_strlen { str } {
#
# Calculates the length of a unix string, excluding the sentinel
#
	# ignore the opening \" (we assume the token is correct)
	set ix 1
	set mx [string length $str]
	# and the closing \" as well
	incr mx -1
	set ln 0

	while 1 {

		if { $ix >= $mx } {
			return $ln
		}

		set c [string index $str $ix]
		incr ln
		if { $c == "\\" } {
			# look at the next one
			incr ix
			if { $ix >= $mx } {
				incr ln
				continue
			}
			set c [string index $str $ix]
			if { $c == "x" } {
				# get hex digits
				incr ix
				while { $ix < $mx } {
					set c [string index $str $ix]
					# skip hex digit
					if ![ishex $c] {
						break
					}
					incr ix
				}
				continue
			} elseif [isoct $c] {
				# octal digits
				while 1 {
					incr ix
					if { $ix >= $mx } {
						break
					}
					set c [string index $str $ix]
					if ![isoct $c] {
						break
					}
				}
				continue
			}
		}
		incr ix
	}
}
					
proc get_init_simple { { brok 0 } } {
#
# Parses a simple initializer stopping at a delimiter
#
	global TK PAR_IT

	set res ""

	set pr 0
	while 1 {
		set TK [ntoken]
		if { $PAR_IT == "d" } {
			if { $TK == "(" } {
				incr pr
			} elseif { $TK == ")" } {
				incr pr -1
				if { $pr < 0 } {
					return ""
				}
			} elseif { ($TK == "," || $TK == ";") && $pr == 0 } {
				return $res
			}
			if { $TK == "\{" || $TK == "\}" } {
				if $brok {
					return $res
				}
				return ""
			}
			append res $TK
		} elseif [endfile] {
			return ""
		} else {
			# add a space after anything other than delimiter
			append res "$TK "
		}
	}
}

proc get_init_compound { cnt } {
#
# Parses a compound initializer
#
	global TK PAR_IT FG
	upvar $cnt acnt

	set res "\{"

	# brace level (we have to look at them, so we can as well calculate
	# by hand
	set blev 0

	# argument count at level 0
	set acnt 0

	set istate "O"

	while 1 {

	    set it [get_init_simple 1]
	    if { $PAR_IT != "d" } {
		# must end with a delimiter, whatever it is
		return ""
	    }

	    append res "$it$TK"

	    set rep 1

	    while { $rep } {

		set rep 0

		if $FG(D) {
			dbg "get_init_compound: <$istate> $PAR_IT $TK $res"
		}

		switch $istate {

		  O {
		  # after opening brace
			if { $TK == "\{" } {
				if { $it != "" } {
					# item cannot be terminated by this
					return ""
				}
				# argument is counted at its end
				incr blev
				# stay at the same state
				continue
			}
			if { $TK == "," } {
				if { $it == "" } {
					# must be nonempty
					return ""
				}
				if !$blev {
					incr acnt
				}
				# expect item or closing brace
				set istate "C"
				continue
			}

			if { $TK == "\}" } {
				if { $it == "" } {
					return ""
				}
				if { $blev == 0 } {
					incr acnt
					set TK [ntoken]
					return $res
				}
				incr blev -1
				set istate "B"
				continue
			}
			return ""
		  }

		  C {
		  # after a comma
			if { $TK == "\{" || $TK == "," } {
				# this is the normal thing
				set rep 1
				set istate "O"
				continue
			}
			if { $TK == "\}" } {
				set istate "B"
				if { $it != "" } {
					set rep 1
					set istate "O"
					continue
				}
				# spurious, ignore
				if { $blev == 0 } {
					set TK [ntoken]
					return $res
				}
				incr blev -1
				continue
			}
			return ""
		  }

		  B {
		  # after a closing brace
			if { $it != "" || $TK == "\{" } {
				return
			}
			if { $TK == "," } {
				set istate "C"
				if { $blev == 0 } {
					incr acnt
				}
				continue
			}
			if { $TK == "\}" } {
				if { $blev == 0 } {
					incr acnt
					set TK [ntoken]
					return $res
				}
				incr blev -1
				continue
			}
			return ""
		  }
		  default {
			xerror "internal error, get_init_compound,\
				illegal state $istate"
			exit 99
		  }
		}
	    }
	}
}

proc get_init { } {
#
# Detects the initializer type:
#
#	s - character string
#	c - compound, as in "\{...\}"
#	i - simple (i.e., can be handled directly)
#
# In case c, calculates the number of zero-level entries, so we can determine
# the array size, if there's no length on first dimension.
#
# In case s, calculates the string length (for the same purpose).
#
# Returns <t l b>: type length body
#
	global TK PAR_IT PAR_MARK FG

	set TK [ntoken]

	if [endfile] {
		xerror "illegal initializer at end of input"
		return ""
	}

	if { $PAR_IT == "s" } {
		# the string case
		if { [string index $TK 0] != "\"" } {
			# this is (probably) a character constant; treat it as
			# a simple initializer
			if $FG(D) {
				dbg "get_init: char cnst $TK"
			}
			restore $PAR_MARK
			set bod [get_init_simple]
			if { $bod == "" } {
				xerror "unrecognizable initializer"
				return ""
			}
			if $FG(D) {
				dbg "get_init: simple = $bod"
			}
			return [list "i" 0 $bod]
		}
		# collect the strings first
		set sl [list $TK]
		# keep going for multiple segments
		while 1 {
			set TK [ntoken]
			if { $PAR_IT != "s" } {
				if { $PAR_IT != "d" } {
					xerror "delimiter expected after string\
						constant"
					return ""
				}
				# leave it for the caller
				break
			}
			if { [string index $TK 0] != "\"" } {
				xerror "illegal string constant in initializer"
				return ""
			}
			lappend sl $TK
		}
		# calculate the length (start with the sentinel included)
		set len 1
		set bod ""
		foreach s $sl {
			append bod $s
			incr len [get_strlen $s]
		}
		if $FG(D) {
			dbg "get_init: string len = $len, bod = $bod"
		}

		return [list "s" $len $bod]
	}

	if { $PAR_IT == "d" && $TK == "\{" } {

		set bod [get_init_compound len]

		if { $bod == "" } {
			xerror "unrecognizable compound initializer"
			return ""
		}

		return [list "c" $len $bod]
	}

	restore $PAR_MARK

	set bod [get_init_simple]

	if { $bod == "" } {
		xerror "unrecognizable initializer"
		return ""
	}

	return [list "i" 0 $bod]
}

###############################################################################

proc get_dimensions { ast } {
#
# Transforms the dimensions string into a list of values
#
	set dlist ""

	for { set ic 0 } { 1 } { incr ic } {

		if ![regexp "\\\[(\[^\\\]\]*)\\\]" $ast mat dim] {
			break
		}

		set ix [string first $mat $ast]
		if { $ix < 0 } {
			# impossible
			return ""
		}

		set dim [string trim $dim]
		if { $dim == "" } {
			if $ic {
				xerror "empty size only legal for first\
					dimension"
				return ""
			}
		}
		lappend dlist $dim
		set ast "[string range $ast 0 [expr $ix - 1]][string range $ast\
			 [expr $ix + [string length $mat]] end]"
	}

	return $dlist
}

###############################################################################

proc parse_type { } {
#
# Extract a type declaration from an fsm declaration, extremely heuristically:
# grabs a sequence of keywords possibly with interspersed sequences of
# asterisks; there is no need for a better accuracy here
#
	global PAR_IT TK

	set res ""

	while 1 {

		set TK [ntoken]

		if { $PAR_IT == "k" } {

			append res "$TK "

		} elseif { $TK == "*" } {

			append res "* "

		} else {

			return [string trim $res]
		}
	}
}

proc outpref { pf } {
#
# Outputs a type prefix
#
	set res ""

	foreach w $pf {
		append res "$w "
	}

	return $res
}

proc outvar { v { init 0 } } {
#
# Outputs a single variable from a declaration list
#
	set res ""

	set vnm [g_vdec $v nam]
	set v   [g_vdec $v att]

	set ptr [g_atts $v ptr]
	set typ [g_atts $v typ]
	set arr [g_atts $v arr]

	while { $ptr } {
		append res "*"
		incr ptr -1
	}

	if { $typ != "v" } {

		set arg [g_atts $v arg]

		if { $typ == "a" || $typ == "f" } {
			# function announcement or declaration
			append res "$vnm $arg"
		} elseif { $typ == "p" } {
			# function pointer
			append res "("
			set fpt [g_atts $v fpt]
			while { $fpt } { 
				append res "*"
				incr fpt -1
			}
			append res $vnm
			append res $arr
			append res ")$arg"
		} else {
			xerror "internal error, illegal variable class"
			exit 99
		}
	} else {
		append res $vnm
		append res [g_atts $v bif]
		append res $arr
	}

	if $init {
		set ini [g_atts $v ini]
		if { $ini != "" } {
			append res "=[lindex $ini 2]"
		}
	}

	return $res
}
	
proc outdecl { dec { init 1 } } {
#
# Converts a variable declaration list (returned by parse_decl) back into a
# program string; init -> include the initializer. The string is terminated by
# a semicolon.
#
	set pf [g_vdl $dec pfx]
	set vl [g_vdl $dec vrs]

	set res [outpref $pf]

	set ll [llength $vl]

	foreach v $vl {

		incr ll -1
		append res [outvar $v $init]
		if $ll {
			append res ","
		}
	}

	return "$res;\n"
}

proc outtype { dec } {
#
# Outputs a type declaration
#
	set nm [g_tdec $dec tna]
	set pf [g_tdec $dec bod]
	set st [g_tdec $dec var]
	set pm [g_tdec $dec mod]

	if $pm {
		return "[outpref $pf][outvar $st 0];"
	} else {
		return "$nm $pf;"
	}
}

proc get_args { } {
#
# Parses stuff in parentheses (past the opening "("), typically corresponding
# to function arguments
#
	global TK PAR_IT

	set cnt 0
	set arg ""

	while 1 {
		set TK [ntoken]
		if { $PAR_IT == "d" } {
			if { $TK == "(" } {
				incr cnt
			} elseif { $TK == ")" } {
				incr cnt -1
				if { $cnt < 0 } {
					break
				}
			} elseif { $TK == "\{" || $TK == "\}" ||
				   $TK == ";" } {
				xerror "runaway argument"
				return ""
			}
		} elseif [endfile] {
			xerror "runaway argument"
			return ""
		}
		append arg "$TK "
	}
	return $arg
}

proc fix_args { arg } {
#
# Removes nested parentheses around an argument
#
	while 1 {
		set arg [string trim $arg]
		if ![regexp "^\\((.*)\\)$" $arg jnk arg] {
			return $arg
		}
	}
}

proc get_array { } {
#
# Parses array dimension sequence, called after the opening \[, swallows the
# token behind;
# FIXME: combine this with get_dimensions!!!
#
	global TK PAR_IT

	set res "\["

	while 1 {
		set TK [ntoken]
		append res $TK
		if { $PAR_IT == "d" } {
			if { $TK == "\[" || $TK == "," || $TK == ";" ||
			     $TK == "\{" || $TK == "\}" } {
				return ""
			}
			if { $TK == "\]" } {
				set TK [ntoken]
				if { $TK != "\[" } {
					return $res
				}
				append res $TK
			}
		} elseif [endfile] {
			return ""
		}
	}
}

proc get_tbody { } {
#
# Gets the body of a struct/union/enum
#
	global TK PAR_IT

	set res "\{"
	set br [brcnt]

	while 1 {

		set TK [ntoken]
		append res $TK

		if { $PAR_IT == "d" } {
			if { $TK == "\}" && [brcnt] < $br } {
				# closing brace
				return $res
			}
			if ![legcs $TK] {
				xerror "illegal token $TK in enum, union, or\
					struct"
				return ""
			}
		} else {
			if [endfile] {
				xerror "incomplete declaration at end of file"
				return ""
			}
			append res " "
		}
	}
}

###############################################################################
###############################################################################

proc parse_picos { str } {

	global PAR_IT TK PAR_MARK PAR_TDEC

	initialize_parser $str

	#
	# fg_fsm == -1 = no fsm expected
	#            0 = fsm expected
	#	     1 = within fsm + declarations expected
	#	     2 = within fsm + no more declarations
	#
	set fg_fsm 0
	# the state of the global automaton
	set fstate "K"

	#######################################################################
	while 1 {

		set TK [ntoken]
		set bra [brcnt]
		set rep 1
		
	  	# this is the "outer" loop in which we acquire the next token;
	  	# the inner loop is needed for an idle turn, i.e., to get to a
	  	# different state without reading the next token

	  	if { $bra < 0 } {
			xerror "too many closing braces"
			break
	  	}

	  	if { $PAR_IT == "f" } {
			xsterr
	  	}

	  	if { $PAR_IT == "e" } {
			if $bra {
				xsterr $bra
			}
			break
	  	} 

	  	while { $rep } {

	    		# the inner loop; set rep to redo
	    		set rep 0

	    		switch $fstate {
K {
###############################################################################
# keyword distributor #########################################################
###############################################################################
	if { $PAR_IT == "k" } {

		if { $bra == 0 && $fg_fsm == 0 && $TK == "fsm" } {
			# a legit fsm
			set fg_fsm 1
			set fsm_mark $PAR_MARK
			set fstate "F"
			continue
		}

		if { $bra > 0 && $TK == "runfsm" } {

			# this can happen inside and outside of fsm, but not at
			# level 0

			set run_mark $PAR_MARK

			set TK [ntoken]
			if { $PAR_IT != "k" } {
				xerror "fsm name expected after runfsm"
				continue
			}

			set fsm_sname $TK

			set TK [ntoken]
			if { $PAR_IT != "d" } {
				xerror "runfsm syntax error"
				continue
			}

			set ins "__pi_fork ($fsm_sname, "
			if { $TK != "(" } {
				# no arguments
				append ins "0)$TK"
			} else {
				append ins "(address)("
				set arg [get_args]
				if { $TK != ")" } {
					# error
					continue
				}
				append ins "$arg))"
			}

			truncate $run_mark
			putS $ins

			continue
		}

		if { $fg_fsm == 1 } {

			# declaration inside fsm is still legit

			if { $bra != $fsm_blev || $TK == "state" ||
			     $TK == "entry" || $TK == "initial" } {
				# not any more; any of these
				# renders declarations illegal
				set fg_fsm 2
				# have to redo the keyword
				set rep 1
				continue
			}

			# try the declaration
			if { $TK == "shared" } {
				# force the "expected" status if it looks like
				# our keyword
				set d 1
			} else {
				set d 0
			}
			set d [parse_decl 2 $d]

			if { $d == "" } {
				# no more declarations; note that the first
				# keyword has been swallowed
				if { $PAR_TDEC == "" } {
					set fg_fsm 2
				}
				continue
			}

			# a declaration inside an fsm
			if { [g_vdl $d typ] != "V" } {
				xerror "illegal declaration inside an fsm,\
					only variables can be declared there"
				continue
			}

			set pfx [g_vdl $d pfx]

			set ins [lsearch -exact $pfx "shared"]
			if { $ins < 0 } {
				# we leave it alone
				continue
			}

			# a shared declaration
			set pfx [lreplace $pfx $ins $ins]
			if { [llength $pfx] == 0 } {
				xerror "type missing in shared declaration"
				continue
			}

			# variable list
			set vrs [g_vdl $d vrs]
			set ors ""
			# copy the variable list renaming the variables
			foreach v $vrs {
				set vnm [g_vdec $v nam]
				set nnm "__fsm_${fsm_name}_shared_$vnm"
				# defines
				lappend dflist [list $vnm $nnm]
				s_vdec v nam $nnm
				lappend ors $v
			}
			s_vdl d pfx $pfx
			s_vdl d vrs $ors
			lappend sdlist $d
			# remove the original declaration
			truncate $PAR_MARK
			# keep this continue even though it is superfluous
			continue
		}

		if { $fg_fsm > 0 } {

			# looking for stuff that can only be legitimately
			# found inside as fsm

			if { $bra == $fsm_blev && ($TK == "state" ||
			     $TK == "entry" || $TK == "initial") } {
				# state, including "initial"
				set fsm_smark $PAR_MARK
				if { $TK == "initial" } {
					set fstate "I"
					set fsm_ins 1
				} else {
					set fstate "S"
					set fsm_ins 0
				}
				continue
			}

			if { $stappd && $TK == "proceed" } {
				# the proceed kwd is copied to output
				set fstate "P"
				continue
			}

		} else {
			# outside fsm; fsm is never legit after a keyword
			set fg_fsm -1
		}

		continue
	}

	# not a keyword
	if { $PAR_IT != "d" } {
		# and not a delimiter
		continue
	}

	if { $fg_fsm > 0 } {

		# within fsm; looking for the closing brace
		if { $TK != "\}" || $bra >= $fsm_blev } {
			# nothing special, keep going
			continue
		}

		# close the fsm; first remove the closing brace of switch
		truncate $PAR_MARK
		
		foreach st $pslist {
			# verify proceed states
			if { [lsearch -exact $stlist $st] < 0 } {
				xerror "state $st used in proceed not\
					defined in fsm"
			}
		}

		if { $stinit != "" } {
			# an explicit initial state, must get number zero
			set st [lsearch -exact $stlist $stinit]
			if { $st < 0 } {
				# impossible
				set st 0
			}
			# move it to front
			set stlist [linsert [lreplace $stlist $st $st] 0 \
				$stinit]
		}

		set ins 0
		foreach d $stlist {
			# define the state constants
			lappend dflist [list $d $ins]
			incr ins
		}

		# prepare the insert to replace the fsm function header
		set ins "\n[lnumseq [olinenum $fsm_mark]]"

		# "shared" declarations
		foreach d $sdlist {
			append ins "\n[lnumseq [g_vdl $d lnu]]"
			append ins "static [outdecl $d]"
		}

		# defines
		foreach d $dflist {
			append ins "\n#define [lindex $d 0] [lindex $d 1]"
		}

		append ins "\n"

		# now goes the new function header
		append ins "int $fsm_name (word __pi_st, address __pi_"

		if { $fsm_type != "" } {
			append ins "da) \{ $fsm_type *data = "
			append ins "(${fsm_type}*) __pi_da; "
		} else {
			append ins "dummy) \{ "
		}

		append ins "switch (__pi_st) \{ "

		insert $fsm_mark $ins

		# the old "default" sequence (FIXME: it should go!!!)
		putS "break; default: if (__pi_st == 0xffff) return ("
		if { $fsm_type == "" } {
			# thread (one copy allowed)
			putS "1"
		} else {
			# strand (no limit)
			putS "0"
		}
		putS "); __pi_badstate (); \} return 1; \}\n"
		
		# followed by undefines
		foreach d $dflist {
			putS "#undef [lindex $d 0]\n"
		}
		catchup
		set fg_fsm 0

		continue
	}

	if { $bra == 0 && ($TK == "\}" || $TK == ";") } {

		if { $fg_fsm == -1 } {
			# fsm becomes legit
			set fg_fsm 0
		}

	} elseif { $fg_fsm == 0 } {

		set fg_fsm -1
	}
}

F {
###############################################################################
# after fsm ###################################################################
###############################################################################

	# this is unconditional; "F" is only used to extract the header
	set fstate "K"

	if { $PAR_IT != "k" } {
		xerror "fsm name expected"
		set fg_fsm -1
		continue
	}

	set fsm_name $TK

	set TK [ntoken]

	if { $PAR_IT != "d" || ( $TK != "\{" && $TK != "(" && $TK != ";" &&
	     $TK != ",") } {
		xerror "fsm declaration syntax error, (, \{, or ; expected"
		set fg_fsm -1
		continue
	}

	if { $TK == "," || $TK == ";" } {
		set ins "extern int"
		while 1 {
			append ins " $fsm_name (word, address)"
			if { $TK == ";" } {
				break
			}
			if { $TK != "," } {
				xerror "fsm announcement syntax error, comma or\
					; expected"
				break
			}
			append ins ", "
			set fsm_name [ntoken]
			if { $PAR_IT != "k" } {
				xerror "fsm announcement syntax error,\
					fsm name expected"
				break
			}
			set TK [ntoken]
		}
		append ins ";"
		truncate $fsm_mark
		putS $ins
		catchup
		set fstate "K"
		set fg_fsm 0
		continue
	}

	if { $TK == "(" } {
		# we have a strand, expect type followed by )
		set fsm_type [parse_type]
		if { $fsm_type == "" || $TK != ")" } {
			xerror "strand fsm declaration syntax error,\
				invalid data type"
			set fg_fsm -1
			continue
		}
		set TK [ntoken]
		if { $PAR_IT != "d" || $TK != "\{" } {
			xerror "strand fsm declaration syntax error,\
				\} expected"
			set fg_fsm -1
			continue
		}
	} else {
		set fsm_type ""
	}

	# truncate the output to remove the fsm header (which has to be
	# fixed; we are now positioned past the opening brace of the thread's
	# function
	truncate $fsm_mark

	# initialize collectors for the fsm
	set sdlist ""	;# shared declarations
	set dflist ""	;# defines (states + shared declaration renames)
	set stlist ""	;# states
	set pslist ""	;# proceed states (for verification)
	set stinit ""	;# initial state
	set stappd 0 	;# flag == state command has appeared

	# just in case, the level must be 1 at this point
	set fsm_blev [brcnt]

	continue
}

I {
###############################################################################
# initial (within fsm) ########################################################
###############################################################################
	if { $PAR_IT != "k" || ($TK != "state" && $TK != "entry") } {
		# expecting a state
		xerror "initial state declaration error"
		set fstate "K"
	} else {
		set fstate "S"
	}
	continue
}

S {
###############################################################################
# state #######################################################################
###############################################################################
	if { $PAR_IT != "k" } {
		xerror "state name expected"
		set fstate "K"
		continue
	}
			
	if { [lsearch -exact $stlist $TK] >= 0 } {
		xerror "duplicate state name $TK"
		set fstate "K"
		continue
	}

	# we have a new state
	lappend stlist $TK

	if $fsm_ins {
		# initial
		if { $stinit != "" } {
			xerror "initial state already defined as $stinit"
			set fstate "K"
			continue
		}
		set stinit $TK
	}

	set fsm_sname $TK
	set fstate "T"

	continue
}

T {
###############################################################################
# state name delimiter ########################################################
###############################################################################
	set fstate "K"
	if { $PAR_IT != "d" || $TK != ":" } {
		xerror ": expected after state name"
	} else {
		truncate $fsm_smark
		catchup
		putS "case $fsm_sname :"
		set stappd 1
	}
	continue
}
				
P {
###############################################################################
# after proceed ###############################################################
###############################################################################
	set fsm_smark $PAR_MARK

	if { $PAR_IT == "k" } {
		# followed directly by state name, expect ;
		set fsm_ins 0
		set rep 1
		set fstate "Q"
		continue
	}

	if { $PAR_IT == "d" && $TK == "(" } {
		set fsm_ins 1
		# expect state name
		set fstate "Q"
		continue
	}

	xerror "proceed syntax error"
	set fstate "K"

	continue
}
				
Q {
###############################################################################
# after proceed (expecting state name) ########################################
###############################################################################
	set fstate "K"

	if { $PAR_IT != "k" } {
		xerror "state name expected"
		continue
	}

	set fsm_sname $TK
	set TK [ntoken]
	if { $PAR_IT != "d" } {
		xerror "delimiter expected after state name"
		continue
	}

	if $fsm_ins {
		# this must be a parenthesis (followed by a ;)
		if { $TK != ")" } {
			xerror ") expected after state name"
			continue
		}
		set TK [ntoken]
		if { $PAR_IT != "d" || $TK != ";" } {
			xerror "; expected after )"
			continue
		}
	} else {
		# just the semi
		if { $TK != ";" } {
			xerror "; expected after state name"
			continue
		}
	}

	truncate $fsm_smark
	putS "($fsm_sname);"

	continue
}
				default {
					errab \
					    "parse_picos: illegal state $fstate"
				}
	    		}
	  	}
	}
}
	
###############################################################################
###############################################################################

proc mkdrec { dname } {
#
# List all subdirectories of the indicated directory recursively in
# alphabetical order
#
	global MKRECV

	if [catch { exec ls $dname } sdl] {
		# doesn't exist
		return
	}

	set MKRECV($dname) ""
	
	foreach f $sdl {
		if [regexp -nocase "attic|junk" $f] {
			# ignore
			continue
		}
		if { $f == "CVS" || $f == "VUEE_TMP" || $f == "KTMP" } {
			# ignore as well
			continue
		}
		if [regexp "\\~\\$" $f] {
			# ignore exotic filenames (cause problems on Windows)
			continue
		}
		set f [file normalize [file join $dname $f]]
		if { $f == "" } {
			continue
		}
		if [info exists MKRECV($f)] {
			# avoid link loops
			continue
		}
		if [file isdirectory $f] {
			set MKRECV($f) ""
			mkdrec $f
		}
	}
}

proc finddir { name tail } {
#
# Try to find one of the extra include directories, either from an evironment
# variable, or by searching upward
#
	global env

	set envar "${name}PATH"

	set dir ""
	if [info exists env($envar)] {
		set dir $env($envar)
		# check if present
		if { $dir != "" || ![file isdirectory $dir] } {
			puts "warning: environment variable $envar\
				is defined, but it does not point to a valid\
				directory"
			set dir ""
		}
	}

	if { $dir != "" } {
		return [file normalize [file join $dir $tail]]
	}

	# try searching from here up stopping at the first directory named
	# that contains name/tail

	set ftail [file join $name $tail]

	set tdi [pwd]
	set lst ""

	for { set i 0 } { $i < 32 } { incr i } {

		set tdi [file normalize "$tdi/.."]

		if { $tdi == $lst } {
			# at root
			break
		}

		set dir [file join $tdi $ftail]

		if [file isdirectory $dir] {
			return [file normalize $dir]
		}

		set lst $tdi
	}

	errab "cannot locate $name directory\
		(set ${name}PATH in the environment)"
}

proc findexec { name } {
#
# Find an executable
#
	global env

	if ![info exists env(PATH)] {
		set dirs { "/bin" "/usr/bin" "/usr/local/bin" }
	} else {
		set dirs [split $env(PATH) ":"]
	}

	foreach d $dirs {
		set p [file normalize [file join $d $name]]
		if [file executable $p] {
			return $p
		}
		append p ".exe"
		if [file executable $p] {
			return $p
		}
	}

	return ""
}

proc mkdlist { } {
#
# Create the list of local subdirectories to search for include files
#
	global MKRECV CWD DirList EDirList env

	mkdrec $CWD

	set DirList [lsort [array names MKRECV]]

	array unset MKRECV

	set vuee [finddir "VUEE" "PICOS"]
	set side [finddir "SIDE" "Examples/IncLib"]

	# check if the VUEE directory looks sane
	foreach fn { "board.cc" "tarp.h" "pins.h" } {
		set fn [file join $vuee $fn]
		if ![file isfile $fn] {
			errab "directory $vuee does not look complete; perhaps\
				mklinks is needed?"
		}
	}
	set EDirList [list $vuee $side]
}
	
proc fprerr { } {
	errab "app.c/app.cc cannot coexist with app_... files in the same\
		directory"
}

proc find_pgms { } {
#
# Find all programs in the current directory
#
	global CWD PG PgmList

	set PgmList ""

	if [catch { exec ls $CWD } flist] {
		errab "cannot scan current directory: $flist"
	}

	set empsuff 0

	foreach fn $flist {

		if { $fn == "app.c" || $fn == "app.cc" } {
			if { $PgmList != "" } {
				fprerr
			}
			set empsuff 1
			set pn ""
			lappend PgmList $pn
			set PG($pn,RF) $fn
			set PG($pn,NT) "Node"
			continue
		}

		if [regexp "^app_(\[a-zA-Z0-9\]+)\\.cc$" $fn jnk pn] {
			if $empsuff {
				fprerr
			}
			lappend PgmList $pn
			set PG($pn,RF) $fn
			set PG($pn,NT) "Node_$pn"
		}
	}

	if { $PgmList == "" } {
		errab\
		    "no app\[_...\] program file(s) found in current directory"
	}
}

proc verify_externals { } {
#
# Checks if externals (transformed to node attributes) are satisfied
#
	global PG Pgm

	foreach ex $PG($Pgm,EA) {

		if { [lsearch -exact $PG($Pgm,AN) [lindex $ex 0]] < 0 } {
			xerror \
			    "external symbol [lindex $ex 1] is never defined" \
				[lindex $ex 2]
		}
	}
}

proc vuee_out { str } {

	if ![regexp "^(.Compiling)\[ \t\]+(.*)" $str jnk cmp name] {
		return $str
	}

	if [regexp "^P_(.+)_pcm_?(.*)_\[0-9\]*.cc" $name jnk froot prog] {
		set name ${froot}.cc
		if { $prog != "" } {
			append name " of $prog"
		}
	} elseif [regexp "^__vueehdr_?(.*).h$" $name jnk prog] {
		set name "vuee header"
		if { $prog != "" } {
			append name " for $prog"
		}
	} elseif [regexp "^__vueeini_?(.*).cc$" $name jnk prog] {
		set name "vuee initializer"
		if { $prog != "" } {
			append name " for $prog"
		}
	} elseif [regexp "^__vuee_root.cc" $name] {
		set name "vuee root"
	}

	return "$cmp $name"
}

proc compile_vuee { } {
#
# Run the VUEE compiler on preprocessed target
#
	global TDIR FG EXEC

	set cwd [pwd]

	if [catch { cd $TDIR } err] {
		cd $cwd
		return "cd'ing to $TDIR: $err"
	}

	puts "running vuee [join $FG(VA)]"

	set ef "__vuee_errors"

	catch { file delete -force $ef }

	set vnam "|[join [concat [list $EXEC(vuee)] $FG(VA)]] 2> $ef"
	if [catch { open $vnam "r" } vfd] {
		catch { file delete -force $ef }
		cd $cwd
		return "pipe: $vfd"
	}

	while 1 {
		if [catch { gets $vfd line } err] {
			catch { close $vfd }
			catch { file delete -force $ef }
			return "pipe: $err"
		}
		if { $err < 0 } {
			break
		}
		puts [vuee_out $line]
	}

	set efd ""
	if { ![catch { open $ef "r" } efd] && ![catch { read $efd } err] } {
		# errors?
		if { $err != "" } {
			puts stderr $err
		}
	}

	catch { close $efd }
	catch { file delete -force $ef }

	if [file exists "side"] {
		set ef "side"
	} elseif [file exists "side.exe"] {
		set ef "side.exe"
	} else {
		cd $cwd
		return "side image not created"
	}

	if [catch { file rename -force $ef [file join $cwd $ef] } err] {
		cd $cwd
		return $err
	}
	cd $cwd

	return ""
}

proc which_endian { } {
#
# We will learn this from vuee; Tcl8.4 doesn't know; Tcl8.5 is smarter, but
# cygwin is not there yet
#
	global FG EXEC

	if [catch { exec $EXEC(vuee) -Q } res] {
		errab "cannot execute vuee: $res"
	}

	if { [string first "Lit" $res] >= 0 } {
		# little
		set FG(EN) 0
	} elseif { [string first "Big" $res] >= 0 } {
		# big
		set FG(EN) 1
	} else {
		puts "warning: cannot get endianness from vuee,\
			assumming 'little'"
		set FG(EN) 0
	}
}

proc parse_vuee { } {
#
# Compile all programs in current directory into VUEE
#
	global DirList Pgm PgmList CWD TDIR SFList FG EXEC ErrCnt

	# find the requisite executables
	foreach p { "vuee" "vue2" "vue" } {
		set e [findexec $p]
		if { $e != "" } {
			break
		}
	}

	if { $e == "" } {
		errab "cannot find vuee execuable (also tried vue2 and vue)"
	}
	set EXEC(vuee) $e

	set e [findexec "cpp"]
	if { $e == "" } {
		errab "cannot find cpp executable"
	}
	set EXEC(cpp) $e

	# determine machine endianness from vuee; we need this to set the
	# only (AFAIK) system-dependent symbol required by VUEE

	unset e

	which_endian

	set CWD [file normalize [pwd]]

	find_pgms

	mkdlist

	set TDIR [file join $CWD "VUEE_TMP"]

	if $FG(E) {
		# we have been called to execute vuee on existing VUEE_TMP
		if ![file isdirectory $TDIR] {
			puts "VUEE_TMP doesn't exist"
			exit 0
		}
		set p [comp_status out]
		if { $p > 2 } {
			puts "VUEE_TMP is incomplete, previous picomp\
				run didn't terminate properly"
			exit 0
		}
		if { $p > 1 } {
			# errors
			puts -nonewline $out
			exit 0
		}
		if !$FG(C) {
			# we don't want to compile
			if $p {
				puts -nonewline $out
			} else {
				puts "OK, no errors, no warnings"
			}
			exit 0
		}
		
		set err [compile_vuee]
		if { $err != "" } {
			errab $err
		}

		exit 0
	}

	# actual compilation

	file delete -force $TDIR

	if [catch { file mkdir $TDIR } err] {
		errab "cannot create tmp directory $TDIR, $err"
	}

	if ![file exists "options.sys"] {
		errab "vuee requires a global options.sys file in the praxis\
			directory"
	}

	if [catch { file copy -force "options.sys" $TDIR } err] {
		errab "cannot copy options.sys to $TDIR, $err"
	}

	foreach p $PgmList {

		set Pgm $p

		compile_pgm
		verify_externals
		emit_vhdr
		emit_vini
	}

	emit_glue

	append_status_end

	if $FG(C) {
		# vuee compilation required
		set err [comp_status]
		if { $err > 1 } {
			if { $err == 3 } {
				errab "cannot read status file, internal error"
			}
			return
		}
		set err [compile_vuee]
		if { $err != "" } {
			errab $err
		}
	}
}

proc setsymbols { dl } {
#
# Preset symbols for parsing files
#
	global Symbols

	array unset Symbols

	foreach d $dl {
		set v ""
		regexp "^(\[^=\]+)=(.*)" $d jnk d v
		set Symbols($d) $v
	}
}

proc append_status { out } {
#
# Appends the specified text (a sequence of lines) to the status file
# (__status__) in VUEE_TMP. These are basically errors and warnings saved
# for the user. This file can be used to assess whether the directory contains
# something that can be compiled with vuee, as opposed to garbage.
#
	global FG

	if $FG(V) {
		set out "[string trimright $out]\n"
		wtfile "__status__" $out "a"
	}
}

proc append_status_end { } {

	append_status "###END###"
}

proc all_warnings { out } {
#
# Checks if all the diagnostic lines in out are warnings, as opposed to
# non-warnings interpreted as (fatal) errors
#
	foreach ln [split $out "\n"] {
		set ln [string trim $ln]
		if { $ln == "" } {
			continue
		}
		if { [string first " warning: " $ln] < 0 } {
			return 0
		}
	}

	return 1
}

proc comp_status { { r "" } } {
#
# Examines the status of VUEE_TMP:
#
#	0 - complete, no errors, no warnings
#	1 - complete, warnings, no errors
#	2 - complete, errors
#	3 - incomplete
#
# If r is not "", it is the name of an upvar variable to receive the printable
# list of errors/warnings
#
	if { $r != "" } {
		upvar $r res
		set res ""
	}

	if [catch { rtfile "__status__" } out] {
		return 3
	}

	set out [string trimright $out]

	if ![regexp "(.*)###END###$" $out jnk out] {
		return 3
	}

	if { $r != "" } {
		set res $out
	}

	if { [string trim $out] == "" } {
		return 0
	}

	if [all_warnings $out] {
		return 1
	}

	return 2
}

proc compile_pgm { } {
#
# Compile one program
#
	global PG Pgm SFList ToCompile Processed NotFound TDIR EXEC FG

	# list of handled files
	set SFList ""

	# current program tag
	set pg $Pgm

	# queue of files to compile
	set ToCompile [file normalize [list $PG($pg,RF)]]

	# not found files that were explicitly requested to compile
	set NotFound ""

	# scratch file for cpp
	set SCF [file join $TDIR "__cpp_tmp.c"]

	if { $pg != "" } {
		set px $pg
	} else {
		set px "the praxis"
	}

	puts "@Compiling $px"

	while { $ToCompile != "" } {
		set cfn [lindex $ToCompile 0]
		set ToCompile [lrange $ToCompile 1 end]
		if [info exists Processed($cfn)] {
			# already handled
			continue
		}
		set Processed($cfn) ""

		set exp { __SMURPH__ LITTLE_ENDIAN=0 BIG_ENDIAN=1 }

		if { $FG(EN) == 0 } {
			lappend exp "BYTE_ORDER=0"
		} else {
			lappend exp "BYTE_ORDER=1"
		}

		setsymbols $exp

		# note that the last line of prelude is empty, as it
		# should be
		set exp [scanfile $cfn 1 [split [emit_thrname] "\n"]]

		if { $exp != "" } {

			# we have to use a scratch file as cpp produces output
			# together with errors
			if [catch { exec $EXEC(cpp) << $exp > $SCF } res] {

				# check if all lines are warnings; in that
				# case assume that everything went fine
				# after all

				if ![all_warnings $res] {
					catch { file delete -force $SCF }
					unset exp
					puts stderr $res
					append_status $res
					append_status_end
					errab "compilation aborted"
				}

				puts $res
				append_status $res
			}

			unset exp

			if [catch {
				set exp [open $SCF "r"]
				set res [read $exp]
			} err] {
				errab "cannot read scratch file $SCF: $err"
				catch { close $exp }
				catch { file delete -force $SCF }
			}

			catch { close $exp }
			catch { file delete -force $SCF }
		}

		if { $res != "" } {
			# note: the target file names can be arbitrarily
			# changed, provided the line number sequencing works
			lappend SFList [list $cfn $res]
		}
	}

	if { $NotFound != "" } {
		if { [llength $NotFound] > 1 } {
			set NotFound [join $NotFound ", "]
			pwarn "files not found: $NotFound"
		} else {
			pwarn "file not found: [lindex $NotFound 0]"
		}
	}

	array unset Processed

	set res ""

	# attribute list (declarations), must be global
	set PG($pg,AL) ""
	# attribute names (for easy detection of duplicates)
	set PG($pg,AN) ""
	# extern attribute list (for detecting the unsatisfied ones)
	set PG($pg,EA) ""
	# idiosyncratic functions
	set PG($pg,ID) ""
	# process list
	set PG($pg,PL) ""
	# process name list
	set PG($pg,PN) ""
	# type declarations
	set PG($pg,TD) ""
	# type name list (to prevent duplicates)
	set PG($pg,TN) ""

	set cnt 0
	foreach cfn $SFList {
		set froot [file rootname [file tail [lindex $cfn 0]]]
		parse_pfile $cnt [lindex $cfn 1]
		# write the file
		wtfile "P_${froot}_pcm[pnfx]_${cnt}.cc" [output]
		close_parser
		incr cnt
	}
}

proc wtfile { fn out { ap "" } } {
#
# Write a file to VUEE_TMP
#
	global TDIR

	if { $ap == "" } {
		set ap "w"
	}
	set tf [file join $TDIR $fn]
	if [catch { open $tf $ap } fd] {
		errab "cannot open output file $tf, $fd"
	}
	if [catch { puts -nonewline $fd $out } err] {
		errab "cannot write to output file $tf, $err"
	}

	catch { close $fd }
}

proc rtfile { fn } {
#
# Read a file form VUEE_TMP
#
	global TDIR

	set tf [file join $TDIR $fn]
	if [catch { open $tf "r" } fd] {
		error "cannot open file $tf, $fd"
	}
	if [catch { read $fd } res] {
		catch { close $fd }
		error "cannot read file $tf, $res"
	}
	catch { close $fd }
	return $res
}

proc swarn { m } {

	global FLine CFName

	puts "$CFName:$FLine (warning): $m"
}

proc pwarn { m } {

	global Pgm

	if { $Pgm != "" } {
		set m "program $Pgm, $m"
	}

	puts "warning: $m"
}

proc flook { fn prefdir dirs } {
#
# Lookup a given file:
#
# prefdir - preferred directory, i.e., the directory to be tried first (the one
#	    containing the includer)
#
# dirs    - the package directory list to search
#
	global CWD

	if { $prefdir != "" } {
		set dirs [concat [list $prefdir] $dirs]
	}

	set dir [file dirname $fn]

	if { $dir != "." && $dir != "" } {
		# the file name has a directory prefix
		set fil [file tail $fn]
		set dir [file normalize $dir]
		if { [string first $CWD $dir] != 0 } {
			# something wrong (this cannot happen)
			errab "cannot determine path for file $fn"
		}
		set cwdl [string length $CWD]
		# this is the normalized tail
		set dir [string range $dir $cwdl end]
		set dl [string length $dir]
		# now we are searching for a directory whose tail matches dir
		# and which contains $fn
		set ffn ""
		foreach d $dirs {
			set pos [string last $dir $d]
			if { $pos < 0 } {
				continue
			}
			if { [expr $pos + $dl] != [string length $d] } {
				continue
			}
			# we have a match on directory name
			set ff [file normalize [file join $d $fil]]
			if [file isfile $ff] {
				# check for a duplicate
				if { $ffn != "" && $ffn != $ff } {
					swarn "multiple occurrences of file $fn\
						 (at\ $ffn and $ff)"
					break
				} else {
					set ffn $ff
					set ddn [string range $d 0 \
						[expr $pos - 1]]
				}
			}
		}

		if { $ffn == "" } {
			# this is an error
			errab "cannot locate path-prefixed file $fn"
		}
		return $ffn
	}

	# a regular file
	set ffn ""
	foreach d $dirs {
		if { $dir == "" } {
			continue
		}
		set ff [file normalize [file join $d $fn]]
		if [file isfile $ff] {
			if { $ffn != "" && $ffn != $ff } {
				swarn "multiple occurrences of\
					file $fn (at $ffn and $ff)"
				break
			} else {
				set ffn $ff
			}
		}
	}

	return $ffn
}

proc needlist { ar fname } {
#
# Returns the list of files from "//+++". The argument is the piece of line
# past the +++ string.
#
	global DirList ToCompile NotFound

	set fl ""
	while 1 {
		set ar [string trim $ar]
		if { $ar == "" } {
			break
		}

		set d0 [string index $ar 0]
		if { $d0 == "\"" } {
			set d1 $d0
		} elseif { $d0 == "<" } {
			set d1 ">"
		} else {
			set d0 ""
			set d1 ""
		}

		set pat "$d0\[ \t\]*(\[^ \t$d1]+\\.(cc?|asm?))\[ \t\]*$d1"

		if ![regexp $pat $ar jk nfn] {
			# we don't understand this
			swarn "'//+++' syntax error: '$ar'"
			break
		}

		set cm [string first $jk $ar]

		if { $cm < 0 } {
			# impossible
			set ar ""
		} else {
			set ar [string range $ar [expr $cm + \
				[string length $jk]] end]
		}

		lappend fl $nfn
	}

	# add the files

	foreach nfn $fl {
		set dnn [file dirname $fname]
		set fn [flook $nfn $dnn $DirList]
		if { $fn == "" && [file extension $nfn] == ".c" } {
			# try ".cc"
			set fn [flook "[file rootname $nfn].cc" $dnn $DirList]
		}
		if { $fn == "" } {
			lappend_unique NotFound $nfn
		} else {
			lappend_unique ToCompile $fn
		}
	}
}

proc slineseq { } {
#
# Generate a line sequencing string for the currently expanded source file
# (before it becomes a parser source)
#
	global CFName FLine

	return [lnumseq [list $FLine $CFName]]
}

proc remcmnt { str } {
#
# Eliminate trailing comments from #if conditions and #defines
#
	set es [string first "//" $str]
	set ps [string first "/*" $str]
	set sl [string length $str]

	if { $es < 0 } {
		set es $sl
	}
	if { $ps < 0 } {
		set ps $sl
	}
	if { $es < $ps } {
		set ps $es
	}

	return [string trim [string range $str 0 [expr $ps - 1]]]
}

proc sexpr { str } {
#
# Evaluates IF conditions (not so naive any more, in fact extremely powerful,
# especially for its simplicity)
#
	global Symbols

	# remove trailing comments
	set str [remcmnt $str]

	if { $str == "" } {
		return -1
	}

	regsub -all "\[ \t\]+" $str "" str

	set turn 0

	while { [regexp -nocase "^\[a-z_.\]\[a-z_0-9.\]*" $str mat] ||
		     [regexp -nocase "\[^a-z_0-9.\](\[a-z_.\]\[a-z_0-9.\]*)" \
			$str jk mat] } {

		# we have something looking like a bare keyword
		if ![info exists Symbols($mat)] {
			break
		}

		# substitute the definition and keep going
		set frm [string first $mat $str]
		set len [string length $mat]
		set nex [string range $str 0 [expr $frm - 1]]
		append nex $Symbols($mat)
		append nex [string range $str [expr $frm + $len] end]
		set str $nex
		incr turn
		if { $turn > 32 } {
			break
		}
	}

	if [catch { eval expr $str } val] {
		return -1
	}

	if $val {
		return 1
	}

	return 0
}

proc scanfile { fname inner { prelude "" } } {
#
# Expands a source file explicitly including whatever possible. If inner is 0,
# it means that the file is external, i.e., it belongs to VUEE (comes from
# VUEE/PICOS). In that case, we do not actually include the file contents, only
# go through its #ifs/#ifdefs, but also include #defines. Then, the entire file
# is run through cpp to expand the macros and eliminate the defines.
#
# The last argument is an optional prelude to be inserted at the beginning of
# the output file. If specified, it must be a list of lines (no terminating
# "\n") ending with an empty item (i.e., an empty line).
#
	global CFName FLine Symbols DirList EDirList FG

	set CFName $fname

	# line count
	set FLine 1

	if [catch { open $fname "r" } fd] {
		errab "cannot open file '$fname': $fd"
	}

	#
	# Note: this is different from mkmk in these respects:
	#
	# - we do not scan just for dependencies, but for contents (or partial
	#   contents, for the external files)
	# - multiple legitimate inclusions are OK
	# - we put line number sequences whenever an inclusion exits
	#

	set ifnest 0

	# assume that the entire file is encapsulated in a dummy if at level
	# zero, which is being totally ignored
	#
	# Flags:
	#
	#	0	- ignore, i.e., both parts should be scanned
	#	1	- accepting the current part
	#	2	- skipping the current part, waiting for else or endif
	#	3	- skipping both parts because the outer if is being
	#		  skipped
	#

	set ifstack($ifnest) "0"

	# the output
	set res [lnumseq [list 1 $CFName]]

	while 1 {

		if { $prelude == "" } {
			if { [gets $fd line] < 0 } {
				if { $ifnest > 0 } {
					swarn "#endif missing"
				}
				break
			}
			incr FLine
		} else {
			# prelude lines are never escaped, so this doesn't
			# interfere with subsequent gets; also, the prelude
			# stays at line 0
			set line [lindex $prelude 0]
			if { $line == "" } {
				# a prelude ends with an empty line
				set prelude ""
				set FLine 1
				append res "[slineseq]"
				continue
			}
			set prelude [lrange $prelude 1 end]
		}

		# handle //+++ requests, but only in internal files; such
		# requests will add files to be compiled in the program's set
		if { $ifstack($ifnest) <= 1 && $inner && \
		    [regexp "^\[ \t\]*//\\+\\+\\+(.*)" $line jk ar] } {
			# needed files
			needlist $ar $fname
			# output an empty line to maintain correct count
			append res "\n"
			continue
		}

		if ![regexp "^\[ \t\]*#" $line] {
			# nothing special, keep going, output if necessary
			if { $inner && $ifstack($ifnest) <= 1 } {
				append res "$line\n"
			}
			continue
		}

		# if we have multiple lines terminated with \, we have to merge
		# them together before interpreting the content
		set lc 1
		while { [regexp "(.*)\[\\\\\]\[ \t\]*$" $line jk newl] } {
			# check if the new line has even number of \'s at the
			# end
			if { [regexp "\[\\\\\]+$" $newl bc] &&
			     [expr [string length $bc] & 1] } {
				# this isn't an escape
				break;
			}
			# remove the escape sequence
			set line $newl
			if { [gets $fd newl] < 0 } {
				swarn "continuation line missing at file end"
				break
			}
			incr lc
			incr FLine
			append line $newl
		}

		if ![regexp "^\[ \t\]*#\[ \t\]*(\[a-z\]+)\[ \t\]*(.*)" \
		    $line jk cm ar] {
			# unrecognizable
			swarn "unrecognized cpp sequence $line, ignored"
			if { $inner && $ifstack($ifnest) <= 1 } {
				append res [newlines $lc]
			}
			continue
		}

		if { $cm == "if" || $cm == "ifdef" || $cm == "ifndef" } {
			if { $ifstack($ifnest) > 1 } {
				# we are skipping an outer if, so we should
				# skip this one entirely
				incr ifnest
				set ifstack($ifnest) 3
				continue
			}
			# we have to evaluate this if
			incr ifnest
			if { $cm == "ifdef" || $cm == "ifndef" } {
				if ![regexp -nocase "^\[a-z_0-9.\]+" $ar nam] {
					# illegal
					swarn "illegal argument of #$cm,\
						assuming undefined"
					# treat as a undefined symbol
					if { $cm == "ifdef" } {
						set ifstack($ifnest) 2
					} else {
						set ifstack($ifnest) 1
					}
				} elseif [info exists Symbols($nam)] {
					if { $cm == "ifdef" } {
						set ifstack($ifnest) 1
					} else {
						set ifstack($ifnest) 2
					}
				} else {
					if { $cm == "ifdef" } {
						set ifstack($ifnest) 2
					} else {
						set ifstack($ifnest) 1
					}
				}
				continue
			}
			# if
			set val [sexpr $ar]
			if { $val < 0 } {
				swarn "cannot evaluate #if condition,\
						assuming zero"
				set val 0
			}
			if $val {
				set ifstack($ifnest) 1
				if $inner {
					append res [newlines $lc]
				}
			} else {
				set ifstack($ifnest) 2
			}
			continue
		}

		if { $cm == "else" } {

			if { $ifnest < 1 } {
			    swarn "extraneous #else, ignored"
			    continue
			}

			if { $ifstack($ifnest) == 1 } {
				# start skipping, including the #else
				set ifstack($ifnest) 2
			} elseif { $ifstack($ifnest) == 2 } {
				# start accepting, but without the else; issue
				# line sequence (note that the else is already					# included in the count
				append res "[slineseq]"
				set ifstack($ifnest) 1
			} elseif { $ifstack($ifnest) == 0 } {
				# impossible
				swarn "stray #else"
			}
				
			continue
		}

		if { $cm == "endif" } {
			if { $ifnest > 0 } {
				set s $ifstack($ifnest)
				incr ifnest -1
				if { $s == 0 } {
					# impossible
					swarn "stray #endif"
				} elseif { $s == 1 } {
					# ignore #endif, but maintain correct
					# line count
					if $inner {
						append res [newlines $lc]
					}
				} else {
					# skipping (this part or both)
					if { $ifstack($ifnest) <= 1 } {
						append res "[slineseq]"
					}
				}
			} else {
			    	swarn "extraneous #endif, ignored"
				continue
			}
			continue
		}

		if { $ifstack($ifnest) > 1 } {
			continue
		}

		if { $cm == "define" } {
			append res "$line\n"
			if $inner {
				incr lc -1
				append res [newlines $lc]
			}

			set ar [remcmnt $ar]

			set nam ""
			if ![regexp -nocase "^(\[a-z_0-9.\]+)(\[ \t\]+(.*))?" \
			    $ar jk kwd jk nam] {
				swarn "#define syntax error"
				continue
			}

			set Symbols($kwd) $nam
			continue
		}

		if { $cm == "undef" } {

			if ![regexp -nocase "^\[a-z_0-9.\]+" $ar kwd] {
				swarn "#undef syntax error, ignored"
				append res [newlines $lc]
				continue
			}

			append res "$line\n"
			if $inner {
				incr lc -1
				append res [newlines $lc]
			}

			if [info exists Symbols($kwd)] {
				unset Symbols($kwd)
			}
			continue
		}

		if { $cm == "include" } {
			if ![regexp -nocase "\[\"<\](\[^\"><\]+)\[\">\]" $ar \
			    jk fn] {
				# the file name to include may be a symbol
				if ![regexp -nocase "^\[ \t\]*(\[a-z_0-9.\]+)" \
				    $ar jk fn] {
					# unrecognizable
					swarn "unrecognizable #include\
						argument, ignored"
					append res [newlines $lc]
					continue
				}
				# try the symbol
				if ![info exists Symbols($fn)] {
					append res "$line\n"
					swarn "unrecognizable #include syntax"
					append res [newlines $lc]
					continue
				}
				set fn [string trim $Symbols($fn) "\"<>"]
			}
			set fn [string trim $fn]
			if { $fn == "" } {
				continue
			}
			# look it up locally
			set fm [flook $fn "" $DirList]
			if { $fm == "" } {
				set fm [flook $fn "" $EDirList]
				if { $fm == "" } {
					swarn "included file $fn not found"
					if $inner {
						append res [newlines $lc]
					}
					continue
				}
				set fn 0
			} else {
				set fn 1
			}
			set jk $CFName
			set ar $FLine
			append res [scanfile $fm $fn]
			set CFName $jk
			set FLine $ar
			append res "[slineseq]"
			continue
		}
	}
	catch { close $fd }
	return $res
}

proc pnfx { } {
#
# Pgm name pre/suffix
#
	global Pgm

	if { $Pgm == "" } {
		return ""
	}

	return "_$Pgm"
}

proc emit_create { pname { arg "" } } {
#
# Generates a sequence for creating a SMURPH process
#
	set ins "(TheNode->tally_in_pcs()?(create $pname"
	if { $arg != "" } {
		append ins "($arg)"
	}
	append ins ")->_pp_apid_():0)"

	return $ins
}

proc emit_thrname { } {
#
# Generates the THREADNAME macro
#
	global Pgm

	set res "#ifndef THREADNAME\n#define THREADNAME(a) a"
	if { $Pgm != "" } {
		append res " ## [pnfx]"
	}
	append res "\n#endif\n"
	return $res
}

proc emit_glue { } {
#
# Creates the "glue" file (SMURPH Root) for the praxis - one for the whole set
#
	global PG PgmList Pgm

	set fn "__vuee_root.cc"

	set res "#include \"sysio.h\"\n"
	append res "#include \"board.h\"\n"
	append res "#include \"board.cc\"\n"

	foreach Pgm $PgmList {
		append res "void __build_[pnfx]node (data_no_t*);\n"
	}

	append res "process Root : BoardRoot \{\n"
	append res "void buildNode (const char *tp, data_no_t *nddata) \{\n"

	set np [llength $PgmList]

	for { set ix 0 } { $ix < $np } { incr ix } {
		set Pgm [lindex $PgmList $ix]
		if { $ix > 0 } {
			append res "else "
		}
		if { $ix != [expr $np - 1] } {
			append res "if (strcmp (tp, \"$Pgm\") == 0) "
		}
		append res "__build_[pnfx]node (nddata); "
	}

	append res "\n\};\n\}\;\n"

	wtfile $fn $res
}
	
proc emit_vini { } {
#
# Creates __vueeini...h
#
	global PG Pgm FG

	set fn "__vueeini[pnfx].cc"
	set fh "__vueehdr[pnfx].h"

	set res "#include \"$fh\"\n"

	# here will go the static initializer objects

	# and this is the node declaration
	set rem "void __NT[pnfx]::init () \{\n"

	# code to pre-zero-out attributes
	append rem "memset (__attr_init_origin, 0, "
	append rem "__attr_init_end - __attr_init_origin);\n"

	# and the proper initializers
	foreach d $PG($Pgm,AL) {

		# list of variables
		set vrs [g_vdl $d vrs]
		# line number
		set lnu [g_vdl $d lnu]
		# type
		set typ [g_vdl $d typ]
		# current set
		set lis ""
		set lim ""

		foreach v $vrs {

			# current (mangled) name
			set nnm [g_vdec $v nam]
			# attributes
			set att [g_vdec $v att]
			# the initializer
			set ini [g_atts $att ini]

			if { $ini == "" } {
				# no initializer
				continue
			}

			set itp [lindex $ini 0]
			set bod [lindex $ini 2]

			if { $lim == "" } {
				set lim [lnumseq $lnu]
			}

			if { $itp == "i" } {
				# simple
				append lim "$nnm=$bod;"
				continue
			}

			# compound, need a static object
			set pfx ""
			lappend pfx "static"
			lappend pfx "const"
			set pfx [concat $pfx [g_vdl $d pfx]]

			if $FG(D) {
				dbg "emit_vini: new pfx = $pfx"
			}

			# clone the variable; FIXME: this can be optimized a
			# a bit, but I am not sure if we care
			set w $v
			set inm "__si_$nnm"
			# new static name
			s_vdec w nam $inm
			# new declaration
			set e ""
			s_vdl e typ $typ
			s_vdl e pfx $pfx
			s_vdl e vrs [list $w]
			s_vdl e lnu $lnu
			# may not be needed (for the record)

			if $FG(D) {
				dbg "emit_vini: <new stat decl>"
				o_dump $e vdl
			}

			append lis [lnumseq $lnu]
			append lis [outdecl $e]

			# now, code to copy the thing
			append lim "memcpy (&$nnm, &$inm, sizeof ($inm)); "
		}

		if { $lis != "" } {
			append res $lis
		}

		if { $lim != "" } {
			append rem $lim
			append rem "\n"
		}
	}

	append res $rem
			
	append res "__praxis_starter ();\n\}\n"

	append res "void __build_[pnfx]node (data_no_t *nddata) \{ "
	append res "create __NT[pnfx] (nddata); \}\n"

	wtfile $fn $res
}

proc emit_vhdr { } {
#
# Creates __vueehdr...h
#
	global PG Pgm

	set fn "__vueehdr[pnfx].h"
	set ta "__vueehdr[pnfx]_h"

	set res "#ifndef $ta\n[emit_thrname]#include \"board.h\"\n"

	foreach d $PG($Pgm,TD) {
		# type declarations
		append res "[lnumseq [g_tdec $d lnu]][outtype $d]\n"
	}

	append res "\station __NT[pnfx] : PicOSNode \{ \n"

	# attributes

	append res "char __attr_init_origin \[0\];\n"

	foreach d $PG($Pgm,AL) {

		append res "[lnumseq [g_vdl $d lnu]][outdecl $d 0]\n"
	}

	append res "char __attr_init_end \[0\];\n"

	append res "void __praxis_starter ();\n"
	append res "void reset () \{ PicOSNode::reset (); \};\n"
	append res "void init (); \n\};\n"

	append res "#include \"stdattr.h\"\n"

	# fsm's

	foreach d $PG($Pgm,PL) {

		set nam [lindex $d 0]
		set stl [lindex $d 1]
		set dty [lindex $d 2]

		append res "process $nam : _PP_ (__NT[pnfx]) \{\n"
		append res "states \{ "
		append res [join $stl ","]
		append res " \};\n"

		if { $dty != "" } {
			append res "$dty *data;\nvoid setup ($dty *d) \{ "
			append res "data = d; \};\n"
		}

		append res "perform;\n\};\n"
	}

	append res "#endif\n"

	wtfile $fn $res
}

proc parse_pfile { cnt src } {
#
# Compiles one source file into a VUEE-compilable format
#
	global FG TK PG Pgm PAR_IT PAR_MARK PAR_TDEC

	initialize_parser $src

	putS "#include \"__vueehdr[pnfx].h\"\n"

	set fstate "K"
	set fg_fsm 0
	set rootp 0

	while 1 {

		set TK [ntoken]
		set bra [brcnt]
		set rep 1

		if { $bra < 0 } {
			xerror "too many closing brackets"
			break
		}

		if { $PAR_IT == "f" } {
			xsterr
		}

	  	if { $PAR_IT == "e" } {
			if $bra {
				xsterr $bra
			}
			break
	  	} 

	  	while { $rep } {

	    		# the inner loop; set rep to redo
	    		set rep 0

	    		switch $fstate {
K {
###############################################################################
# keyword distributor #########################################################
###############################################################################
  if { $PAR_IT == "k" } {

    if $FG(D) { dbg "pfile: fs = $fstate, kw = $TK, bl = $bra, fs = $fg_fsm" }

    if { $bra == 0 } {

      # level 0, be on a lookout for:
      # - fsm's
      # - declarations

      if { $fg_fsm == 0 && $TK == "fsm" } {
        if $FG(D) { dbg "fg_fsm: $fg_fsm -> 1 (f)" }
	set fg_fsm 1
	set fsm_mark $PAR_MARK
	set fstate "F"
	continue
      }

      # try a declaration
      set d [parse_decl 1 1]

      # check for a type declaration
      if { $PAR_TDEC != "" } {
	while { $PAR_TDEC != "" } {
	  # there can be at most two
	  set td [lindex $PAR_TDEC 0]
	  set PAR_TDEC [lrange $PAR_TDEC 1 end]
	  # name ID
	  set ins [g_tdec $td tna]
	  if $FG(D) { dbg "pfile: tdec = $ins" }
	  if { [lsearch -exact $PG($Pgm,TN) $ins] < 0 } {
	    lappend PG($Pgm,TD) $td
	    lappend PG($Pgm,TN) $ins
	  }
	}
	if { $d == "" } {
	  # have to remove it
	  truncate $PAR_MARK
	  catchup
	}
	continue
      }

      if { $d == "" } {
	continue
      }

      # variable declaration
      set pfx [g_vdl $d pfx]
      set dtp [g_vdl $d typ]

      if { [lsearch -exact $pfx "shared"] >= 0 } {
	xerror "shared illegal in global scope"
	continue
      }

      # more sanity checks?

      set ins [lsearch -exact $pfx "idiosyncratic"]

      #########################################################################
      # handle a function declaration or announcement #########################
      #########################################################################
      if { $dtp == "A" || $dtp == "F" } {

	if { $ins >= 0 } {

	  # remove the original declaration
	  truncate $PAR_MARK
	  # will be appending stuff
          putS "\n"
      	  catchup [ilinenum $PAR_MARK]

	  if { $dtp == "A" } {

	    # function announcement

	    set vrs [g_vdl $d vrs]
	    set lnu [g_vdl $d lnu]

	    set ins ""

	    foreach v $vrs {

	      # original name
	      set vnm [g_vdec $v nam]
	      # mangled (method) name
	      set nnm "_na_$vnm"

	      append ins "#ifndef $vnm\n#define $vnm (((__NT[pnfx]*)"
	      append ins "TheStation)->$nnm)\n#endif\n"

	      # FIXME: this is not used at present; I guess we can use it for
	      # verification
	      lappend_unique PG($Pgm,ID) [list $nnm $vnm $lnu]
	    }

	  } else {

	    # function declaration
	    set pfx [lreplace $pfx $ins $ins]

	    set ins " [outpref $pfx]"

	    # there is just a single "variable"
	    set vrs [lindex [g_vdl $d vrs] 0]

	    set vnm [g_vdec $vrs nam]
	    set nnm "_na_$vnm"

	    # updated variable description
	    s_vdec vrs nam $nnm

	    # include original name as "old"
	    s_vdec vrs old $vnm

	    s_vdl d pfx $pfx
	    s_vdl d vrs [list $vrs]
	
	    append ins "__NT[pnfx]::[outvar $vrs] \{"

	    if { [lsearch -exact $PG($Pgm,AN) $nnm] >= 0 } {
	      xerror "idiosyncratic function $vnm declared more than once"
	    } else {
	      lappend PG($Pgm,AN) $nnm
	      lappend PG($Pgm,AL) $d
	    }
	  }

	  putS $ins
	  catchup
	  continue
	}

	# not idiosyncratic, stays put
	continue
      }

      if { $ins >= 0 } {
	xerror "only functions can be idiosyncratic"
	continue
      }

      # the declaration will be removed (at least ignored)
      truncate $PAR_MARK

      #########################################################################
      # trueconst #############################################################
      #########################################################################
      set ins [lsearch -exact $pfx "trueconst"]
      if { $ins >= 0 } {
	# this is left alone, with truconst replaced by const
	set pfx [lreplace $pfx $ins $ins "const"]
	s_vdl d pfx $pfx
	putS [outdecl $d]
	catchup
	continue
      }

      #########################################################################
      # handle externs ########################################################
      #########################################################################
      set ins [lsearch -exact $pfx "extern"]
      if { $ins >= 0 } {
	# externs are transformed into macros and saved for verification

	set ins [lsearch -exact $pfx "static"]
	if { $ins >= 0 } {
	  xerror "extern cannot be static"
	  continue
	}

	set vrs [g_vdl $d vrs]
	set lnu [g_vdl $d lnu]
	set ins "\n"
	foreach v $vrs {
	  if [isfundec $v] {
	    # ignore function announcements altogether
	    continue
	  }
	  set vnm [g_vdec $v nam]
	  set nnm "__vattr_$vnm"
	  append ins "#ifndef $vnm\n#define $vnm (((__NT[pnfx]*)"
	  append ins "TheStation)->$nnm)\n#endif\n"
	  lappend_unique PG($Pgm,EA) [list $nnm $vnm $lnu]
	}

	putS $ins
	catchup
	continue
      }

      #########################################################################
      # handle regular declarations ###########################################
      #########################################################################
      set ins [lsearch -exact $pfx "const"]
      if { $ins >= 0 } {
	# turn const to var for now; we may want to do something about them
	# later
	set pfx [lreplace $pfx $ins $ins]
      }

      set suf "__vattr_"

      set ins [lsearch -exact $pfx "static"]
      if { $ins >= 0 } {
	# static is additionally mangled with the file-specific counter
	append suf "${cnt}_"
	set pfx [lreplace $pfx $ins $ins]
      }

      if { [llength $pfx] == 0 } {
	# check the prefix after all this trimming
	xerror "missing type in declaration"
	continue
      }

      set vrs [g_vdl $d vrs]
      set ors ""
      set ins ""

      # append a newline to make sure that the #define will start correctly
      putS "\n"
      # make sure the line numbers tally up
      catchup [ilinenum $PAR_MARK]

      # rename the variables
      foreach v $vrs {

	if [isfundec $v] {
	  # ignore function announcements
	  continue
	}

	set vnm [g_vdec $v nam]
	if { $vnm == "heapmem" || $vnm == "__pi_heapmem" } {
		# ignore this, should we warn?
		continue
	}
	set nnm "${suf}${vnm}"
	if { [lsearch -exact $PG($Pgm,AN) $nnm] >= 0 } {
	  xerror "variable $vnm declared (globally) more than once"
	  continue
	}

	# don't use #ifdef here, may help discover some potential errors
	append ins "#define $vnm (((__NT[pnfx]*)"
	append ins "TheStation)->$nnm)\n"

	s_vdec v nam $nnm
	# include the original variable name
	s_vdec v old $vnm
	# update global list of names
	lappend PG($Pgm,AN) $nnm
	lappend ors $v
      }

      if { $ors != "" } {
        # has been verified for duplicates
        s_vdl d pfx $pfx
        s_vdl d vrs $ors
        lappend PG($Pgm,AL) $d

        # insert the defines
        putS $ins
      }

      catchup
      continue
    }

    ###########################################################################
    # we are nested (bra > 0) #################################################
    ###########################################################################

    if { $TK == "runfsm" } {

      set run_mark $PAR_MARK

      set TK [ntoken]
      if { $PAR_IT != "k" } {
	xerror "fsm name expected after runfsm"
	continue
      }

      set fsm_sname $TK[pnfx]

      set TK [ntoken]
      # expected ( or some other delimiter, not necessarily ;
      if { $PAR_IT != "d" } {
	xerror "runfsm syntax error, delimiter expected after sfm name"
	continue
      }

      if { $TK == "(" } {
	set arg [get_args]
	if { $TK != ")" } {
	  # error (diagnosed by get_args)
	  continue
	}
	# looking at the delimiter following the closing )
	set TK [ntoken]
      } else {
	set arg ""
      }

      truncate $run_mark
      putS "[emit_create $fsm_sname $arg]$TK"

      continue
    }

    ####

    if { $TK == "crunning" } {

      # intercept crunning and convert its constant argument to the process
      # id

      set run_mark $PAR_MARK

      set TK [ntoken]
      if { $PAR_IT != "d" || $TK != "(" } {
	xerror "crunning must be followed by a parenthesis"
	continue
      }

      set arg [fix_args [get_args]]
      if { $TK != ")" } {
	# error
	continue
      }

      # this must be a keyword or constant zero

      if [iskwd $arg] {
	# this is the argument expected by VUEE function
	set arg "&zz_$arg[pnfx]_prcs"
      } else {
	if { [catch { expr $arg } arg] || $arg != 0 } {
	  xerror "the argument of crunning must be either a process name or\
		a constant expression evaluating to zero"
	  continue
	}
	# doesn't hurt to make sure
	set arg 0
      }

      # replace with a call to internal function
      truncate $run_mark
      putS "__pi_crunning ($arg)"

      continue
    }

    if { $TK == "__pi_crunning" } {

      # this one is a temporary fix for compatibility with the present mess of
      # co-existing manually tweaked VUEE-compliant praxes; until we get rid
      # of them (and the preceding chunk of code will kick in), there will be a
      # macro converting crunning to __pi_crunning, which will mess up things
      # if the argument is a non-keyword

      set run_mark $PAR_MARK

      set TK [ntoken]
      if { $PAR_IT != "d" || $TK != "(" } {
	xerror "crunning must be followed by a parenthesis"
	continue
      }

      set arg [fix_args [get_args]]
      if { $TK != ")" } {
	# error
	continue
      }

      # this is either e keyword (meaning that the macro has succeeded), or
      # something like &zz_!!..._xxx!!_prcs, in which case we have to dig up
      # the ...

      if [iskwd $arg] {
	# OK, we let it go
	continue
      }
      set arg [join $arg ""]
      if $FG(D) { dbg "parse_pfile: __pi_crunning = $arg" }
      if { ![regexp -nocase "^.zz_!!(.*)_\[a-z0-9_\]+!!" $arg ins v] &&
           ![regexp -nocase "^.zz_!!(.*)!!" $arg ins v] ||
	    [catch { expr $v } v] || $v != 0 } {
	xerror "the argument of crunning must be either a process name or\
		a constant expression evaluating to zero"
	continue
      }

      # replace 
      truncate $run_mark
      putS "__pi_crunning (0)"

      continue
    }

    # other non-declaration keywords? later we may want to get rid of the
    # macros in sysio.h

    ###########################################################################
    # handling fsm code #######################################################
    ###########################################################################

    if { $fg_fsm <= 0 } {
      if $FG(D) { dbg "fg_fsm: $fg_fsm -> -1 (k)" }
      set fg_fsm -1
      # illegal after keyword
      continue
    }

    ###########################################################################
    # within fsm, declarations allowed ########################################
    ###########################################################################
    if { $fg_fsm == 1 } {

      # this means that we are within an fsm and declarations are still legal

      if { $bra != $fsm_blev || $TK == "state" || $TK == "entry" ||
	$TK == "initial" } {
	# not any more; any of these renders declarations illegal
        if $FG(D) { dbg "fg_fsm: $fg_fsm -> 2 (i)" }
	set fg_fsm 2
	# have to redo the keyword
	set rep 1
	continue
      }

      # try the declaration
      if { $TK == "shared" } {
	set d 1
      } else {
	set d 0
      }
      set d [parse_decl 2 $d]
      if { $d == "" } {
	# if there are type declarations, keep going
	if { $PAR_TDEC == "" } {
        	if $FG(D) { dbg "fg_fsm: $fg_fsm -> 2 (t)" }
		set fg_fsm 2
	}
	continue
      }

      set dtp [g_vdl $d typ]

      if { $dtp != "V" } {
	xerror "only variables can be declared within an fsm"
      }

      set pfx [g_vdl $d pfx]

      # just in case
      if { [lsearch -exact $pfx "idiosyncratic"] >= 0 } {
	xerror "variables cannot be idiosyncratic"
	continue
      }

      set ins [lsearch -exact $pfx "shared"]
      if { $ins < 0 } {
	# we leave it alone; should we allow the keyword further down the list?
	continue
      }

      # a shared declaration
      set pfx [lreplace $pfx $ins $ins]
      if { [llength $pfx] == 0 } {
	xerror "type missing in shared declaration"
      }

      # variable list
      set vrs [g_vdl $d vrs]
      set ors ""
      # copy the variable list mangling the variables
      foreach v $vrs {
	set vnm [g_vdec $v nam]
	set nnm "__vattr_${fsm_name}_$vnm"
	if { [lsearch -exact $PG($Pgm,AN) $nnm] >= 0 } {
	  xerror "shared variable $vnm conflicts (globally) with another\
		variable"
	  continue
	}
	# defines
	set ins "(((__NT[pnfx]*)TheStation)->$nnm)"
	lappend PS($Pgm,AN) $nnm
	lappend dflist [list $vnm $ins]
	s_vdec v nam $nnm
	lappend ors $v
      }

      s_vdl d pfx $pfx
      s_vdl d vrs $ors
      lappend PG($Pgm,AL) $d
      # remove the original declaration
      truncate $PAR_MARK
      continue
    }

    ###########################################################################
    # within fsm, no more declarations ########################################
    ###########################################################################
    if { $fg_fsm > 0 } {

      if { $bra == $fsm_blev && ($TK == "state" || $TK == "entry" ||
	   $TK == "initial") } {
	# state, including "initial"
	set fsm_smark $PAR_MARK
	if { $TK == "initial" } {
	  set fstate "I"
	  set fsm_ins 1
	} else {
	  set fstate "S"
	  set fsm_ins 0
	}
	continue
      }

      # note: there's no need to handle proceed

    } else {

    ###########################################################################
    # keyword outside fsm #####################################################
    ###########################################################################

      if $FG(D) { dbg "fg_fsm: $fg_fsm -> -1 (k)" }
      set fg_fsm -1
    }

    continue
  }

  #############################################################################
  # not a keyword in ground state #############################################
  #############################################################################

  if { $PAR_IT != "d" } {
    # and not a delimiter
    continue
  }

  #############################################################################
  # delimiter in ground state #################################################
  #############################################################################

  if { $fg_fsm > 0 } {

    # within fsm; looking for the closing brace
    if { $TK != "\}" || $bra >= $fsm_blev } {
      # nothing special, keep going
      continue
    }

    ###########################################################################
    # closing the fsm #########################################################
    ###########################################################################

    # the name is mangled with program name
    set fsn "$fsm_name[pnfx]"

    foreach st $pslist {
      # verify proceed states
      if { [lsearch -exact $stlist $st] < 0 } {
	xerror "state $st used in proceed not defined in fsm"
      }
    }

    if { $stinit != "" } {
      # an explicit initial state, must get number zero
      set st [lsearch -exact $stlist $stinit]
      if { $st < 0 } {
	# impossible
	set st 0
      }
      # move it to front
      set stlist [linsert [lreplace $stlist $st $st] 0 $stinit]
    }

    set ins "\n[lnumseq [olinenum $fsm_mark]]"
    # defines for shared variables
    foreach d $dflist {
      append ins "\n#define [lindex $d 0] [lindex $d 1]"
    }
    append ins "\n"

    # the code method
    append ins "${fsn}::perform \{\n"

    insert $fsm_mark $ins

    if { $dflist != "" } {
      putS "\n"
      foreach d $dflist {
	putS "#undef [lindex $d 0]\n"
      }
      catchup
    }

    if $FG(D) { dbg "fg_fsm: $fg_fsm -> 0 (c)" }
    set fg_fsm 0

    if { [lsearch -exact $PG($Pgm,PN) $fsm_name] >= 0 } {
      xerror "fsm $fsm_name defined more than once"
    } else {
      lappend PG($Pgm,PN) $fsm_name
    }

    if { $fsm_name == "root" } {
      # flag == need the starter
      set rootp 1
    }

    # process description
    lappend PG($Pgm,PL) [list $fsn $stlist $fsm_type]
    continue
  }

  #############################################################################
  # other delimiters ##########################################################
  #############################################################################
  if { $bra == 0 && ($TK == "\}" || $TK == ";" || $TK == "#") } {

    # FIXME: this is wrong; the true delimiter has been swallowed by the
    # declaration, so we cannot really enter this chunk sensibly, except
    # for a line number sequence (the "#" case)

    if { $fg_fsm == -1 } {
      # fsm becomes legit
      if $FG(D) { dbg "fg_fsm: $fg_fsm -> 0 (l = $TK)" }
      set fg_fsm 0
    }

  } elseif { $fg_fsm == 0 } {
    if $FG(D) { dbg "fg_fsm: $fg_fsm -> -1 (d = $TK)" }
    set fg_fsm -1
  }
}

F {
###############################################################################
# after fsm ###################################################################
###############################################################################

	set fstate "K"

	if { $PAR_IT != "k" } {
		xerror "fsm name expected"
    		if $FG(D) { dbg "fg_fsm: $fg_fsm -> -1 (f)" }
		set fg_fsm -1
		continue
	}

	set fsm_name $TK

	set TK [ntoken]

	if { $PAR_IT != "d" || ( $TK != "\{" && $TK != "(" && $TK != "," &&
	     $TK != ";" ) } {
		xerror "fsm declaration syntax error, (, \{, or ; expected"
    		if $FG(D) { dbg "fg_fsm: $fg_fsm -> -1 (e)" }
		set fg_fsm -1
		continue
	}

	if { $TK == "," || $TK == ";" } {
		# announcement - skip to ";" while doing some rudimentary
		# verification
    		if $FG(D) { dbg "fg_fsm: $fg_fsm -> 0 (a)" }
		set fg_fsm 0
		while 1 {
			if { $PAR_IT == "d" } {
				if { $TK == ";" } {
					break
				}
				if { $TK != "," } {
    					if $FG(D) {
						dbg "fg_fsm: $fg_fsm -> -1 (b)"
					}
					set fg_fsm -1
					xerror "illegal fsm announcement"
					break
				}
			}
			set TK [ntoken]
		}

		truncate $fsm_mark
		catchup
		continue
	}

	if { $TK == "(" } {
		# we have a strand, expect type followed by )
		set fsm_type [parse_type]
		if { $fsm_type == "" || $TK != ")" } {
			xerror "strand fsm declaration syntax error,\
				invalid data type"
    			if $FG(D) { dbg "fg_fsm: $fg_fsm -> -1 (s)" }
			set fg_fsm -1
			continue
		}
		set TK [ntoken]
		if { $PAR_IT != "d" || $TK != "\{" } {
			xerror "strand fsm declaration syntax error,\
				\} expected"
    			if $FG(D) { dbg "fg_fsm: $fg_fsm -> -1 (z)" }
			set fg_fsm -1
			continue
		}
	} else {
		set fsm_type ""
	}

	# truncate the output to remove the fsm header (which has to be
	# fixed; we are now positioned past the opening brace of the thread's
	# function
	truncate $fsm_mark

	# initialize collectors for the sfm
	set dflist ""	;# defines (shared declaration renames)
	set stlist ""	;# states
	set pslist ""	;# proceed states (for verification)
	set stinit ""	;# initial state

	# just in case, the level must be 1 at this point
	set fsm_blev [brcnt]

	continue
}

I {
###############################################################################
# initial (within fsm) ########################################################
###############################################################################
	if { $PAR_IT != "k" || ($TK != "state" && $TK != "entry") } {
		# expecting a state
		xerror "initial state declaration error"
		set fstate "K"
	} else {
		set fstate "S"
	}
	continue
}

S {
###############################################################################
# state #######################################################################
###############################################################################
	if { $PAR_IT != "k" } {
		xerror "state name expected"
		set fstate "K"
		continue
	}
			
	if { [lsearch -exact $stlist $TK] >= 0 } {
		xerror "duplicate state name $TK"
		set fstate "K"
		continue
	}

	# we have a new state
	lappend stlist $TK

	if $fsm_ins {
		# initial
		if { $stinit != "" } {
			xerror "initial state already defined as $stinit"
			set fstate "K"
			continue
		}
		set stinit $TK
	}

	set fsm_sname $TK
	set fstate "T"

	continue
}

T {
###############################################################################
# state name delimiter ########################################################
###############################################################################
	set fstate "K"
	if { $PAR_IT != "d" || $TK != ":" } {
		xerror ": expected after state name"
	} else {
		truncate $fsm_smark
		catchup
		putS "transient ${fsm_sname}:"
	}
	continue
}
				default {
					errab \
					    "parse_vuee: illegal state $fstate"
				}
	    		}
	  	}
	}

	if $rootp {
		# the file contains the root process: add the starter
		putS "\nvoid __NT[pnfx]::__praxis_starter () \{ "
		putS [emit_create root[pnfx]]
		putS "; \}\n"
	}
}
	
###############################################################################
###############################################################################

proc usage { } {

	global argv0

	set pgname [file tail $argv0]

	puts stderr "Usage: $pgname \[-p|-v\] \[-n\] \[-e\] \[-V\] \[-A\]\
		\[-- vuee args\]"
	puts stderr "       -p  -> PicOS compiler (used as a filter)"
	puts stderr "       -v  -> VUEE compiler (the default)"
	puts stderr "       -n  -> do not call vuee automatically"
	puts stderr "       -e  -> call vuee for existing VUEE_TMP"
	puts stderr "       -V  -> debug info written to output (lots)"
	puts stderr "       -A  -> stop on first compilation error"
	puts stderr "       --  -> subsequent args passed to vuee"
	puts stderr "       -n together with -e shows VUEE_TMP status"
	exit 99
}

# default mode == vuee compiler
set FG(V) 1

# default flag == compile unless errors
set FG(C) 1

#arguments for VUEE
set FG(VA) ""

#debugging
set FG(D) 0

# abort on first error
set FG(A) 0

# run vuee on existing VUEE_TMP
set FG(E) 0

# ecog flag (used to generate proper line numbering sequence for ecogcc);
# will be empty or "line"
set FG(EC) ""

set an 0

foreach arg $argv {

	incr an

	if { $arg == "-p" } {
		set FG(V) 0
	} elseif { $arg == "-v" } {
		set FG(V) 1
	} elseif { $arg == "-n" } {
		set FG(C) 0
	} elseif { $arg == "-V" } {
		set FG(D) 1
	} elseif { $arg == "-A" } {
		set FG(A) 1
	} elseif { $arg == "-e" } {
		set FG(E) 1
	} elseif { $arg == "--" } {
		# arguments for the vuee compiler
		if !$FG(V) {
			errab "-- ... illegal with PicOS mode (-p)"
		}
		set FG(VA) [lrange $argv $an end]
		break
	} else {
		usage
	}
}

if { $FG(E) && !$FG(V) } {
	errab "-e illegal with PicOS mode (-p)"
}
	
o_initialize

set ErrCnt 0

proc dbg { m } { }

if $FG(V) {

	if $FG(D) {
		proc dbg { m } { puts $m }
	}

	puts "PiComp version $Version"
	parse_vuee

} else {

	if $FG(D) {
		# cannot use stdout because we filter
		proc dbg { m } { puts stderr $m }
	}

	# PicOS compiler

	if [catch { read stdin } src] {

		errab "cannot read input: $src"

	}

	parse_picos $src
	unset src

	puts -nonewline [output]

	if $PS(ERC) {

		exit 99
	}

}

exit 0
###
### To do:
###
###	All functions should be idiosyncratic and should be separated from
###	FSMs (using different sets of demangling macros).
###	On the other hand, static functions will be impossible this way, so
###	perhaps the idiosyncratic option is not that bad, after all.
###
