#!/bin/sh
###################\
exec tclsh "$0" "$@"

###############################################################################
#
# Two in one:
#
#	1. PicOS to C compiler
#	2. PicOS to VUEE compiler
#
# Copyright (C) Olsonet Communications Corporation, 2010
#
###############################################################################

set Version 0.1

proc dbg { m } {

	puts stderr $m
}

###############################################################################
###############################################################################

proc errab { m } {

	puts stderr $m
	exit 99
}

proc lappend_unique { li i } {

	upvar $li l

	if { ![info exists l] || [lsearch -exact $l $i] < 0 } {
		lappend l $i
	}
}

###############################################################################
###############################################################################

proc isalpha { c } {
#
# Applied to single characters only
#
	return [regexp -nocase "\[a-z_$\]" $c]
}

proc isnum { c } {
	return [regexp -nocase "\[0-9\]" $c]
}

proc isalphanum { c } {
	return [regexp -nocase "\[a-z0-9_$\]" $c]
}

proc isspace { c } {
	return [regexp "\[ \t\n\r\]" $c]
}

proc iskwd { s } {
	return [regexp -nocase "^\[a-z_$\]" $s]
}

###############################################################################
###############################################################################

proc xerror { msg { lnu "" } } {
#
# An error message (with line number)
#
	global PS ErrCnt RepErr

	if { $lnu == "" } {
		set ln $PS(LIN)
		set lf $PS(LIF)
	} else {
		set ln [lindex $lnu 0]
		set lf [lindex $lnu 1]
	}

	set erc "$lf:$ln"
	if [info exists RepErr($erc)] {
		# do not report more than one error per line per file
		return
	}
	set RepErr($erc) ""

	puts stderr "$lf:$ln: $msg"

	# parser error count
	incr PS(ERC)

	# global error count
	incr ErrCnt

	if { $ErrCnt > 15 } {
		puts stderr "$lf:$ln: too many errors"
		exit 99
	}
}

proc xsterr { { bra "" } } {
#
# Unexpected EOF error
#
	if { $bra != "" } {
		set t "unmatched "
		if { $bra == 1 } {
			append t "one \}"
		} else {
			append t "$bra \}'s"
		}
		xerror "$t at the end of file"
	} else {
		xerror "unterminated construct causing premature EOF"
	}
	exit 99
}

proc initialize_parser { src } {

	global PS

	# the input
	set PS(SRC) $src

	# bracket level
	set PS(BRL) 0

	# beginning of line flag
	set PS(BOP) 1
	set PS(BOL) 1

	# index into source
	set PS(INX) 0

	# line count/file
	set PS(LIN) -1
	set PS(LIF) "none"

	# output
	set PS(TAR) ""

	set PS(LON) 0
	set PS(LOF) ""

	# output BOL flag
	set PS(BQL) 1

	# error count
	set PS(ERC) 0
}

proc close_parser { } {

	array unset PS
}

proc output { } {

	global PS

	return $PS(TAR)
}

proc getC { } {
#
# Read next character from the parser's input
#
	global PS

	set c [string index $PS(SRC) $PS(INX)]

	if { $c != "" } {
		incr PS(INX)
	}

	if $PS(BOP) {
		set PS(BOL) 1
		incr PS(LIN)
	} else {
		set PS(BOL) 0
	}

	if { $c == "\n" } {
		set PS(BOP) 1
	} else {
		set PS(BOP) 0
	}

	return $c
}

proc peekC { } {
#
# Peek at next character
#
	global PS
	return [string index $PS(SRC) $PS(INX)]
}

proc putC { c } {
#
# Single character write to the parser's output
#
	global PS

	if { $PS(BQL) && $c != "#" } {
		# synchronize line numbers
		catchup
	}

	append PS(TAR) $c

	if { $c == "\n" } {
		incr PS(LON)
		set PS(BQL) 1
	} else {
		set PS(BQL) 0
	}
}

proc putS { s } {
#
# Append a string at the end of the parser's output
#
	global PS

	append PS(TAR) $s
	incr PS(LON) [regexp -all "\n" $s]
	set PS(BQL) [regexp "\n$" $s]
}

proc catchup { } {
#
# Catch up with line numbers, i.e., make sure that the effective line number
# at the current place in the parser's output is the same as on input
#
	global PS

	while 1 {
		if { $PS(LIF) != $PS(LOF) } {
			# different files, need an explicit reset
			break
		}
		set dif [expr $PS(LIN) - $PS(LON)]
		if { $dif == 0 } {
			# in perfect sync
			return
		}
		if { $dif > 16 || $dif < 0 } {
			# difference to big or negative, must be forced by an
			# explicit line number sequence
			break
		}
		# just insert eols
		while { $PS(LIN) > $PS(LON) } {
			append PS(TAR) "\n"
			incr PS(LON)
		}
		return
	}
	setlnum [list $PS(LIN) $PS(LIF)]
}

proc lnumseq { lnu } {
#
# Convert a line number (number, file name) into a sequence to be inserted into
# file
#
	return  "# [lindex $lnu 0] \"[lindex $lnu 1]\"\n"
}

proc setlnum { lnu } {
#
# Set the line number at the current point of the parser's output to an
# explicit value
#
	global PS

	set PS(LON) [lindex $lnu 0]
	set PS(LOF) [lindex $lnu 1]

	if !$PS(BQL) {
		append PS(TAR) "\n"
	}

	append PS(TAR) [lnumseq $lnu]
}

proc parse_lnum { } {
#
# Parse a line number sequence in the parser's input
#
	global PS

	set cmd ""

	set S $PS(SRC)
	set I $PS(INX)

	while 1 {

		set c [string index $S $I]
		if { $c == "" } {
			break
		}

		incr I

		if { $c == "\n" } {
			break
		}

		append cmd $c
	}

	if [regexp "^ *(\[0-9\]+) +\"(.*)\"(.*)" $cmd jnk ln fi re] {

		# will be bumped on BOP
		set PS(LIN) [expr $ln - 1]

		if { [string first "/___pcs___" $fi] >= 0 } {
			# clean up the name for error reports
			regsub "___pcs___" $fi "" fi
		}

		set PS(LIF) $fi
		set PS(INX) $I
		set PS(BOP) 1

		return 1
	}

	return 0
}

proc brcnt { } {
#
# Return current bracket level on input
#
	global PS
	return $PS(BRL)
}

proc getmark { } {
#
# Produce a "mark" representing the parser's state, e.g., to be reverted to
#
	global PS

	return [list [string length $PS(TAR)] $PS(LON) $PS(LOF) \
		$PS(BQL) $PS(BRL) $PS(BOP) $PS(BOL) $PS(INX) $PS(LIN) \
		$PS(LIF) ]
}

proc getmarq { } {
#
# Same as getmark, except that the input is backspaced by one character (needed
# by ntoken, which grabs the mark after swallowing the first character of the
# token
#
	global PS

	set ix [expr $PS(INX) - 1]
	return [list [string length $PS(TAR)] $PS(LON) $PS(LOF) \
		$PS(BQL) $PS(BRL) $PS(BOP) $PS(BOL) $ix $PS(LIN) \
		$PS(LIF) ]
}

proc truncate { mark } {
#
# Truncate the output to the mark, i.e., restore the output side of the parser
# state as it was when the mark was taken
#
	global PS

	set sl [lindex $mark 0]
	set li [lindex $mark 1]
	set lf [lindex $mark 2]
	set bq [lindex $mark 3]

	set PS(TAR) [string range $PS(TAR) 0 [expr $sl - 1]]
	set PS(LON) $li
	set PS(LOF) $lf
	set PS(BQL) $bq
}

proc backtrack { mk } {
#
# Restore the input to the mark
#
	global PS

	set PS(BRL) [lindex $mk 4]
	set PS(BOP) [lindex $mk 5]
	set PS(BOL) [lindex $mk 6]
	set PS(INX) [lindex $mk 7]
	set PS(LIN) [lindex $mk 8]
	set PS(LIF) [lindex $mk 9]
}

proc restore { mk } {
#
# Restore the complete parser state (both sides) to the mark
#
	global PS

	truncate $mk
	backtrack $mk
}

proc ilinenum { mk } {
#
# Extract the input line number from the mark
#
	global PS

	return [lrange $mk 8 9]
}

proc olinenum { mk } {
#
# Extract the output line number from the mark
#
	global PS

	return [lrange $mk 1 2]
}

proc insert { mk ins } {
#
# Insert text into output at the mark; anything following the mark will appear
# after the insert
#
	global PS

	set sl [lindex $mk 0]
	set txt [string range $PS(TAR) 0 [expr $sl - 1]]
	append txt $ins
	append txt "\n"
	append txt [lnumseq [olinenum $mk]]
	append txt [string range $PS(TAR) $sl end]
	set PS(TAR) $txt
}

proc ntoken { } {
#
# Returns the next token from the parser's input; the token is swallowed;
# PAR_IT tells the type, which can be: "k" (keyword), "n" (numeric, i.e., like
# a keyword starting from a digit), "d" (delimiter), "s" (string or a comment),
# "e" (end of file), "f" (failed end of file, i.e., EOF within a string).
#
# Note that strings and comments are treated similarly, except that comments
# are always returned as empty tokens, i.e., PAR_IT is "s", but the returned
# value is "". This cannot happen for a string, even if it is empty, because
# it includes the delimiters ("..." or ','). The idea is that the program can
# be recombined by simply concatenating the tokens successively returned by
# ntoken, as long as you make sure to insert one space between two conecutive
# keywords/numwords.
#
# The function atomatically outputs the scanned characters to the parser's
# output. If you want to replace something there, use marks, inserts, etc.
#
# PAR_MARK is automatically set to the mark immediately preceding the token
# being returned.
#
	global PAR_IT PAR_MARK PS

	set ws ""

	while 1 {

		set c [getC]

		if { $ws != "" } {
			# within a string or comment
			if { $c == "" } {
				# premature end
				break
			}
			if { $c == "\\" } {
				# collect the string token
				append as $c
				putC $c
				set c [getC]
				if { $c == "" } {
					# premature end
					break
				}
				append as $c
				putC $c
				continue
			}

			if { $c == "\n" && $ws == "/" } {
				# exit comment; we do not return them as tokens
				unset as
				set ws ""
				putC $c
				continue
			}

			append as $c
			putC $c
			if { $c == $ws } {
				if { $c == "*" } {
					# closing comment
					set c [getC]
					if { $c == "" } {
						break
					}
					append as $c
					putC $c
					if { $c != "/" } {
						# sorry
						continue
					}
					# end of comment
					unset as
					set ws ""
				} elseif { $c != "/" } {
					# terminate string
					set PAR_IT "s"
					set ws ""
					return $as
				}
			}
			continue
		}

		if [isspace $c] {
			putC $c
			continue
		}

		if { $c == "" } {
			set PAR_IT "e"
			return ""
		}

		set PAR_MARK [getmarq]

		if [isalphanum $c] {

			putC $c

			# handle a keyword
			if [isalpha $c] {
				# item type == keyword
				set PAR_IT "k"
			} else {
				# looks like a number?
				set PAR_IT "n"
			}

			set as $c

			while 1 {

				set c [peekC]

				if ![isalphanum $c] {
					return $as
				}

				append as $c
				putC $c
				getC
			}
		}

		set PAR_IT "d"

		switch -- $c {

			"#" {
				if $PS(BOL) {
					if [parse_lnum] {
						continue
					}
				}

				# treat as a token
				putC $c
				return $c
			}

			"'" -
			"\"" {
				putC $c
				# start string
				set as $c
				set ws $c
				continue
			}

			"/" {
				putC $c
				set c [peekC]
				if { $c == "/" || $c == "*" } {
					set as "/$c"
					set ws $c
					putC $c
					getC
					continue
				}
				return "/"
			}

			"\}" {
				putC $c
				incr PS(BRL) -1
				return "\}"
			}

			"\{" {
				putC $c
				incr PS(BRL)
				return "\{"
			}

		  	default {

				putC $c
				return $c
			}
		}
	}

	set PAR_IT "f"
	return ""
}

###############################################################################

proc legcs { c } {
#
# Legitimate delimiters in structures
#
	return [regexp "\[;,\{\}\\\[\\\]:\\\*\\\(\\\)\]" $c]
}

proc parse_decl { tok } {
#
# Parse a declaration and return its description; the argument is the first
# token of a suspected declaration, which must be a keyword.
#
# The function returns a list of these items:
#
#	0 - the prefix, i.e., the list of "type" keywords, like
#	    "volatile static int"
#
#	1 - the list of variables (more generally, elements), or type name
#	    (for a type declaration)
#
#	2 - the line number (number, file name) of the declaration (this is
#	    needed for consistent error reporting)
#
#	3 - the declaration type (a single letter):
#
#		T - type declaration, A - function announcements only,
#		M - mixed (function announcements with variables)
#		V - variables only, F - a function declaration
#
# For a non-type declaration, i.e., other than T, element 1 is a list of
# variables. Each item is a 4-element list with this layout:
#
#	0 - preamble (for example ** or "(" - for a function pointer); this is
#	    the part that belongs to the variable (rather than prefix), but is
#	    not part of the variable name
#
#	1 - the actual name of the variable (a keyword)
#
#	2 - the postamble, i.e., whatever follows the name, but is not an
#	    initializer, like in arr [3][5]
#
#	3 - the initializer, if present, i.e., the part after "=", or "" is
#	    there's no initializer
#
# For a type declaration (T), element 1 is the type name string (e.g., for
# detecting duplicates), while element 0 (the prefix) is the complete list of
# tokens comprising the declaration.
#
# On exit:
#
# PAR_MARK is set to the beginning of the declaration. If the returned
# value is "", it means that the token doesn't start a declaration. Note that
# the thing, whatever it is, has been parsed through until some point, so if
# you want to re-parse everything, you have to backtrack to PAR_MARK.
#
	global PAR_MARK PAR_IT PAR_DEL

	set pfx [list $tok]
	# variable list
	set vrs ""

	# remember where it starts
	set dec_mark $PAR_MARK
	# line of the declaration
	set vli [olinenum $dec_mark]

	# to be reset after handling each item: ###############################
	# 
	#	- variable name
	set vnm ""
	# 	- prefix in front of variable name, i.e., a sequence of *'s
	set vnp ""
	# 	- need a closing ")" - a function-pointer variable
	set clo 0
	#	- name tail, i.e., [] for array, ) for function pointer
	set vnt ""
	#	- initializer
	set vni ""
	#######################################################################

	# number of variables
	set nva 0
	# number of function announcements
	set nfa 0
	# function flag, can only be zero or one
	set nfd 0
	#######################################################################

	# tells whether we have a variable/function or type declaration; -1
	# means unknown yet
	set typedec -1

	# type (for typedefs, unions, and structures)
	set typ ""

	# brace level
	set blev [brcnt]

	set more 1

	if { $tok == "struct" || $tok == "union" || $tok == "enum" } {
		# this can be a type declaration, because it starts with
		# struct/union, but it doesn't have to be; typedec == -1
		# says exactly that
		set dstate "S"
		set tname $tok
	} else {
		set dstate "P"
	}

	while { $more } {

	    set tok [ntoken]
	    set rep 1

	    while { $rep } {

		set rep 0

	  	if { $PAR_IT == "e" || $PAR_IT == "f" } {
			xerror "incomplete declaration, premature end of file"
			return ""
		}

		switch $dstate {

		  P {
		  #############################################################
		  # collecting type prefix ####################################
		  #############################################################
			if { $PAR_IT == "k" } {
				if { $tok == "typedef" } {
					# the prefix must be empty for that
					xerror "typedef preceded by garbage"
					
				}
				if { $tok == "union" || $tok == "struct" ||
				     $tok == "enum" } {
					# pfx is nonempty, so this can't be a
					# type declaration any more, unless
					# there's typedef in front, which will
					# be handled separately
					set typedec 0
					# which one it is (for diagnostics)
					set tname $tok
					# type name (for future use?)
					set typ $tok
					set dstate "S"
				}
				# just a keyword
				lappend pfx $tok
				continue
			}

			# we have seen a sequence of keywords (none of them
			# being typedef, struct, or union) followed by a
			# delimiter; this means a straightforward non-type
			# declaration

			if { $tok == "*" } {
				set vnp "*"
				# collecting name prefix, i.e., *'s
				set dstate "M"
				continue
			}

			if { $tok == "(" } {

				# if this is followed by *, we are looking at
				# a function pointer declaration; otherwise,
				# it is a function (declaration or
				# announcement), and we are past the variable

				set fp_mark [getmark]
				set tok [ntoken]

				if { $PAR_IT == "d" && $tok == "*" } {
					# a function pointer declaration
					set vnp "(*"
					set clo 1
					# collecting name prefix
					set dstate "M"
					continue
				}

				# wrong guess
				restore $fp_mark

				# the last keyword is the function name
				set vix [llength $pfx]
				if { $vix < 2 } {
					return ""
				}

				incr vix -1

				set vnm [lindex $pfx $vix]
				set pfx [lrange $pfx 0 [expr $vix - 1]]

				# looking for name delimiter
				set tok "("
				set PAR_IT "d"
				set dstate "N"
				set rep 1
				continue
			}

			if { $tok == "\[" || $tok == "="  || $tok == ","  ||
			     $tok == ";" } {

				# this means that we are past the variable, so
				# we have to remove it from the prefix

				set vix [llength $pfx]

				if { $vix < 2 } {
					# not a declaration
					return ""
				}

				incr vix -1

				set vnm [lindex $pfx $vix]
				set vnp ""
				set pfx [lrange $pfx 0 [expr $vix - 1]]

				# looking for name delimiter
				set dstate "N"
				set rep 1
				continue
			}

			# something wrong, not a declaration
			return ""
		  }

		  M {
		  #############################################################
		  # collecting name prefix ####################################
		  #############################################################

			if { $PAR_IT == "d" } {

				if { $tok != "*" } {
					# we may try to diagnose some errors;
					# better not here, as we may be stopped
					# half-way through something
					return ""
				}

				append vnp $tok
				continue
			}

			if { $PAR_IT != "k" } {
				# something wrong
				return ""
			}

			# variable name
			set vnm $tok
			set dstate "N"
		  }

		  N {
		  #############################################################
		  # expecting variable name delimiter #########################
		  #############################################################

			if { $PAR_IT != "d" } {
				# not a declaration
				return ""
			}

			if { $clo == 1 } {
				# must be a closing parenthesis
				if { $tok != ")" } {
					xerror "unrecognizable function\
					pointer declaration, ) expected"
				}
				append vnt ")"
				incr clo
				# keep going
				continue
			}

			if { $clo == 2 } {
				# expecting opening parenthesis for the args
				if { $tok != "(" } {
					xerror "unrecognizable function\
						pointer declaration, ( expected"
					return ""
				}
				set arg [parse_arg]
				if { $PAR_DEL == "" } {
					return ""
				}
				append vnt "($arg)"
				# this no longer legal, but we stay in this
				# state
				incr clo
				continue
			}

			if { $tok == "(" } {
				if $clo {
					xerror "unrecognizable function\
						pointer declaration"
					return ""
				}
				# function declaration
				set arg [parse_arg]
				if { $PAR_DEL == "" } {
					# runaway argument diagnosed by
					# parse_arg
					return ""
				}
				append vnt "($arg)"
				# expected comma, semi, or "\{"
				set dstate "U"
				continue
			}

			if { $tok == "\[" } {
				append vnt "\["
				set dstate "A"
				continue
			}

			if { $tok == "=" } {
				set vni [parse_ini]
				if { $PAR_DEL != "," && $PAR_DEL != ";" } {
					return ""
				}
				set PAR_IT "d"
				set tok $PAR_DEL
				# fall through
			}

			if { $tok == "," || $tok == ";" } {
				# done with the variable
				incr nva
				lappend vrs [list $vnp $vnm $vnt $vni]
				set vnp ""
				set vnm ""
				set vnt ""
				set vni ""
				set clo 0
				if { $tok == ";" } {
					set more 0
				}
				set dstate "M"
				continue
			}
		
			return ""
		  }

		  A {
		  #############################################################
		  # looks like an array #######################################
		  #############################################################

			if { $PAR_IT == "d" } {
				if { $tok == "\]" } {
					# may be more
					set dstate "N"
				}

				if { $tok == ";" || [brcnt] != $blev } {
					# something wrong
					return ""
				}
			}
			append vnt $tok
		  }

		  U {
		  #############################################################
		  # function declaration ######################################
		  #############################################################

			if { $PAR_IT != "d" } {
				xerror "illegal function declaration"
				return ""
			}

			if { $tok == "\{" } {
				# this is an actual function declaration, as
				# opposed to an announcement
				if { $vrs != "" } {
					# must be alone
					xerror "illegal declaration"
					return ""
				}

				incr nfd

				lappend vrs [list $vnp $vnm $vnt ""]

				set vnp ""
				set vnm ""
				set vnt ""
				set vni ""
				set clo 0

				set more 0

				set dstate "M"
				continue
			}

			# must be a comma or semi
			if { $tok != "," && $tok != ";" } {
				xerror "illegal declaration, ; or , expected"
				return ""
			}

			lappend vrs [list $vnp $vnm $vnt ""]
			incr nfa
			set vnp ""
			set vnm ""
			set vnt ""
			set vni ""
			set clo 0
			if { $tok == ";" } {
				set more 0
			}
			set dstate "M"
			continue
		  }
		
		  S {
		  #############################################################
		  # struct or union ###########################################
		  #############################################################

			# this is the only state out if we succeed -> to parse
			# the struct's body
			set dstate "W"

			if { $PAR_IT == "k" } {
				# this may look like a type declaration
				if { $typedec != 0 } {
					# the keyword counts to the type name
					append typ " $tok"
				}
				lappend pfx $tok
				# flag == structure name present
				set str_named 1
			} else {
				# this cannot be a type declaration (unless
				# typedef shows up in front)
				set typedec 0
				# do not read next token, have got it already
				set rep 1
				# no name
				set str_named 0
			}
		  }
		
		  W {
		  #############################################################
		  # struct or union body ######################################
		  #############################################################

			if { $PAR_IT != "d" || $tok != "\{" } {
				if $str_named {
					# this looks like a "struct name"
					# reference in type prefix
					set rep 1
					set dstate "P"
					continue
				}
				xerror "illegal $tname declaration"
				return ""
			}

			lappend pfx $tok
			set br [brcnt]

			while 1 {
				set tok [ntoken]
				lappend pfx $tok
				if { $PAR_IT == "d" } {
					if { $tok == "\}" && [brcnt] < $br } {
						# closing brace
						break
					}
					if ![legcs $tok] {
						xerror "illegal token $tok in\
							$tname"
						return ""
					}
				}
				if { $PAR_IT == "e" || $PAR_IT == "f" } {
					xerror "incomplete declaration at end\
						of file"
					return ""
				}
			}

			# this is the end of struct/union body; if this is
			# followed by anything other than ;, parse it as a
			# variable declaration, even if it says "type"

			set tok [ntoken]

			if { $PAR_IT == "d" && $tok == ";" } {
				if { $typedec == 0 } {
					# it cannot be a type declaration
					xerror "illegal $tname declaration,\
						missing variable list or type\
						name"
					return ""
				}

				# type declaration OK

				set more 0
				set dstate "M"
				continue
			}

			set rep 1
			set typ ""

			if { $PAR_IT == "d" && $tok == "*" || $tok == "(" } {
				set dstate "P"
			} elseif { $PAR_IT == "k" } {
				set dstate "M"
			} else {
				xerror "declaration syntax error, variable name\
					expected"
				return ""
			}
			continue
		  }

		  default {

			xerror "illegal state $dstate in parse_decl,\
				internal error"
			exit 99
		  }
		}
	    }
	}

	set PAR_MARK $dec_mark

	# check for typedef; if the first pfx keyword is typedef, there must be
	# a single "variable" (no initializer) which is the name of the defined
	# type

	if { [lindex $pfx 0] == "typedef" } {
		if { [llength $vrs] != 1 } {
			xerror "typedef syntax error, looks like multiple type\
				names"
			return ""
		}
		set br [lindex $vrs 0]
		if { [lindex $br 3] != "" } {
			xerror "typedef syntax error, illegal initializer"
			return ""
		}
		# type = "variable" name
		set typ [lindex $br 1]
		# concatenate everything with the prefix
		append pfx [lindex $br 0]$typ[lindex $br 2]
	}

	if { $typ != "" } {
		# type declaration
		set vrs $typ
		set typ "T"
	} elseif $nfd {
		# function declaration (body)
		set typ "F"
	} elseif { $nva && !$nfa } {
		# variables only
		set typ "V"
	} elseif { $nfa && !$nva } {
		# function announcements only
		set typ "A"
	} else {
		# mixed
		set typ "M"
	}

	return [list $pfx $vrs $vli $typ]
}

proc isfundec { v } {
#
# Returns 1 if the declared item is a function announcement
#
	if { [string index [lindex $v 2] 0] == "(" } {
		return 1
	}
	return 0
}

###############################################################################

proc parse_type { } {
#
# Extract a type declaration, extremely heuristically, grabs a sequence of
# keywords possibly with interspersed sequences of asterisks
#
	global PAR_IT PAR_DEL

	set res ""

	while 1 {

		set tok [ntoken]

		if { $PAR_IT == "k" } {

			append res "$tok "

		} elseif { $tok == "*" } {

			append res "* "

		} else {

			set PAR_DEL $tok

			return [string trim $res]
		}
	}
}

proc outdecl { dec { init 1 } } {
#
# Convert a declaration description (e.g., returned by parse_decl) back into a
# program string; init -> include the initializer. The string is terminated by
# a semicolon.
#
	set pfx [lindex $dec 0]
	set lin ""

	foreach w $pfx {
		append lin "$w "
	}

	if { [lindex $dec 3] != "T" } {

		# for a type declaration, the prefix contains everything

		set vrs [lindex $dec 1]

		foreach v $vrs {

			append lin "[lindex $v 0][lindex $v 1][lindex $v 2]"

			if $init {
				set vni [lindex $v 3]
				if { $vni != "" } {
					append lin "=[lindex $vni]"
				}
			}
	
			append lin ","
		}

		set lin [string trimright $lin ","]
	}

	return "$lin;\n"
}

proc outinit { dec } {
#
# Generate dynamic initializers. There is no way to do it right in all
# circumstances without a semi-complete C parser, mostly because of the
# possibly tricky initializers for structures. Thus, we assume that the
# (hopefully rare) tricky cases will be handled by conditional compilation
# for which we offer here some naive assistance. If the initializer starts
# with a left brace, it is assumed to be a program. Instead of trying to
# assign that stuff, we just run the part in braces as a program. This
# assumes that a braced initializer cannot be possibly legally "assigned"
# in C++, e.g.,
#
#		struct my_struct C =
#		#ifdef __SMURPH__
#					{ C.a = 1; C.b = 3; }
#		#else
#					{ 1, 3 }
#		#endif
#						;
# Better ideas, anyone?
#
	set vrs [lindex $dec 1]
	set lin ""

	# flag == line rerefernce active
	set ldp 0

	foreach v $vrs {

		# the initializer
		set vni [lindex $v 3]
		if { $vni == "" } {
			continue
		}

		# effective name
		set nnm [lindex $v 1]
		# original name
		set vnm [lindex $v 4]

		if { [string index $vni 0] == "\{" } {
			# under VUEE, this means a program
			if { $lin != "" } {
				append lin "\n"
			}
			append lin "#define $vnm $nnm\n"
			append lin [lnumseq [lindex $dec 2]]
			append lin $vni
			append lin "\n"
			append lin "#undef $vnm\n"
			set ldp 0
		} else {
			if !$ldp {
				# line reference
				append lin [lnumseq [lindex $dec 2]]
				set ldp 1
			}
			append lin \
			    "[lindex $v 0]$nnm[lindex $v 2]=[lindex $vni];"
		}
	}

	if { $lin != "" } {
		append lin "\n"
	}

	return "$lin"
}

proc parse_arg { } {
#
# Parses stuff in parentheses (past the opening "("), typically corresponding
# to function arguments
#
	global PAR_DEL PAR_IT

	set cnt 0
	set arg ""

	while 1 {
		set tok [ntoken]
		if { $PAR_IT == "d" } {
			if { $tok == "(" } {
				incr cnt
			} elseif { $tok == ")" } {
				incr cnt -1
				if { $cnt < 0 } {
					break
				}
			} elseif { $tok == "\{" || $tok == "\}" ||
				   $tok == ";" } {
				xerror "runaway argument"
				return ""
			}
		} elseif { $PAR_IT == "e" ||
			   $PAR_IT == "f" } {
			xerror "runaway argument"
			set PAR_DEL ""
			return ""
		}
		append arg "$tok "
	}
	set PAR_DEL ")"
	return $arg
}

proc parse_ini { } {
#
# Parse a variable initializer, i.e., looking for , or ; while counting
# brackets and parentheses
#
	global PAR_DEL PAR_IT

	set br [brcnt]
	set pr 0

	set res ""
	set PAR_DEL ""

	while 1 {
		set tok [ntoken]
		set cb [brcnt]
		if { $PAR_IT == "d" } {
			if { $tok == "(" } {
				incr pr
			} elseif { $tok == ")" } {
				incr pr -1
				if { $pr < 0 } {
					xerror "runaway initializer"
					return ""
				}
			} elseif { ($tok == "," || $tok == ";") && $pr == 0 &&
				    $cb == $br } {
				set PAR_DEL $tok
				return $res
			}
			if { $cb < $br } {
				xerror "runaway initializer"
				return ""
			}
		} elseif { $PAR_IT == "e" ||
			   $PAR_IT == "f" } {
			xerror "runaway initializer"
			return ""
		}
		append res "$tok "
	}
}

###############################################################################
###############################################################################

proc parse_picos { str } {

	global PAR_IT PAR_DEL PAR_MARK

	initialize_parser $str

	#
	# fg_fsm == -1 = no fsm expected
	#            0 = fsm expected
	#	     1 = within fsm + declarations expected
	#	     2 = within fsm + no more declarations
	#
	set fg_fsm 0
	# the state of the global automaton
	set fstate "K"

	#######################################################################
	while 1 {

		set tok [ntoken]
		set bra [brcnt]
		set rep 1
		
	  	# this is the "outer" loop in which we acquire the next token;
	  	# the inner loop is needed for an idle turn, i.e., to get to a
	  	# different state without reading the next token

	  	if { $bra < 0 } {
			xerror "too many closing braces"
			break
	  	}

	  	if { $PAR_IT == "f" } {
			xsterr
	  	}

	  	if { $PAR_IT == "e" } {
			if $bra {
				xsterr $bra
			}
			break
	  	} 

	  	while { $rep } {

	    		# the inner loop; set rep to redo
	    		set rep 0

	    		switch $fstate {
K {
###############################################################################
# keyword distributor #########################################################
###############################################################################
	if { $PAR_IT == "k" } {

		if { $bra == 0 && $fg_fsm == 0 && $tok == "fsm" } {
			# a legit fsm
			set fg_fsm 1
			set fsm_mark $PAR_MARK
			set fstate "F"
			continue
		}

		if { $bra > 0 && $tok == "runfsm" } {

			# this can happen inside and outside of fsm, but not at
			# level 0

			set run_mark $PAR_MARK

			set tok [ntoken]
			if { $PAR_IT != "k" } {
				xerror "fsm name expected after runfsm"
				continue
			}

			set fsm_sname $tok

			set tok [ntoken]
			if { $PAR_IT != "d" } {
				xerror "runfsm syntax error"
				continue
			}

			set ins "zzz_fork ($fsm_sname, "
			if { $tok != "(" } {
				# no arguments
				append ins "0)$tok"
			} else {
				append ins "(address)("
				set arg [parse_arg]
				if { $PAR_DEL == "" } {
					# error
					continue
				}
				append ins "$arg))"
			}

			truncate $run_mark
			putS $ins

			continue
		}

		if { $fg_fsm == 1 } {

			# declaration inside fsm is still legit

			if { $bra != $fsm_blev || $tok == "state" ||
			     $tok == "entry" || $tok == "initial" } {
				# not any more; any of these
				# renders declarations illegal
				set fg_fsm 2
				# have to redo the keyword
				set rep 1
				continue
			}

			# try the declaration
			set d [parse_decl $tok]

			if { $d == "" } {
				# no more declarations; note that the first
				# keyword has been swallowed
				set fg_fsm 2
				continue
			}

			# a declaration inside an fsm
			if { [lindex $d 3] != "V" } {
				xerror "illegal declaration inside an fsm,\
					only variables can be declared there"
				continue
			}

			set pfx [lindex $d 0]

			if { [lindex $pfx 0] != "shared" } {
				# we leave it alone
				continue
			}

			# a shared declaration
			set pfx [lreplace $pfx 0 0]
			if { [llength $pfx] == 0 } {
				xerror "type missing in shared declaration"
				continue
			}
			# variable list
			set vrs [lindex $d 1]
			set ors ""
			# copy the variable list renaming the variables
			foreach v $vrs {
				set vnm [lindex $v 1]
				set nnm "__fsm_shared_$vnm"
				# defines
				lappend dflist [list $vnm $nnm]
				set v [lreplace $v 1 1 $nnm]
				lappend ors $v
			}
			lappend sdlist [lreplace $d 0 1 $pfx $ors]
			# remove the original declaration
			truncate $PAR_MARK
			# keep this continue even though it is superfluous
			continue
		}

		if { $fg_fsm > 0 } {

			# looking for stuff that can only be legitimately
			# found inside as fsm

			if { $bra == $fsm_blev && ($tok == "state" ||
			     $tok == "entry" || $tok == "initial") } {
				# state, including "initial"
				set fsm_smark $PAR_MARK
				if { $tok == "initial" } {
					set fstate "I"
					set fsm_ins 1
				} else {
					set fstate "S"
					set fsm_ins 0
				}
				continue
			}

			if { $stappd && $tok == "proceed" } {
				# the proceed kwd is copied to output
				set fstate "P"
				continue
			}

		} else {
			# outside fsm; fsm is never legit after a keyword
			set fg_fsm -1
		}

		continue
	}

	# not a keyword
	if { $PAR_IT != "d" } {
		# and not a delimiter
		continue
	}

	if { $fg_fsm > 0 } {

		# within fsm; looking for the closing brace
		if { $tok != "\}" || $bra >= $fsm_blev } {
			# nothing special, keep going
			continue
		}

		# close the fsm

		foreach st $pslist {
			# verify proceed states
			if { [lsearch -exact $stlist $st] < 0 } {
				xerror "state $st used in proceed not\
					defined in fsm"
			}
		}

		if { $stinit != "" } {
			# an explicit initial state, must get number zero
			set st [lsearch -exact $stlist $stinit]
			if { $st < 0 } {
				# impossible
				set st 0
			}
			# move it to front
			set stlist [linsert [lreplace $stlist $st $st] 0 \
				$stinit]
		}

		set ins 0
		foreach d $stlist {
			# define the state constants
			lappend dflist [list $d $ins]
			incr ins
		}

		# prepare the insert to replace the fsm function header
		set ins "\n[lnumseq [olinenum $fsm_mark]]"

		# "shared" declarations
		foreach d $sdlist {
			append ins "\n[lnumseq [lindex $d 2]]"
			append ins "static [outdecl $d]"
		}

		# defines
		foreach d $dflist {
			append ins "\n#define [lindex $d 0] [lindex $d 1]"
		}

		append ins "\n"

		# now goes the new function header
		append ins "int $fsm_name (word zz_st, address zz_"

		if { $fsm_type != "" } {
			append ins "da) \{ $fsm_type *data = "
			append ins "(${fsm_type}*) zz_da; "
		} else {
			append ins "dummy) \{ "
		}

		append ins "switch (zz_st) \{ "

		insert $fsm_mark $ins

		# one extra brace at the end
		putS "\}\n"
	
		# followed by undefines
		foreach d $dflist {
			putS "#undef [lindex $d 0]\n"
		}
		catchup
		set fg_fsm 0

		continue
	}

	if { $bra == 0 && ($tok == "\}" || $tok == ";") } {

		if { $fg_fsm == -1 } {
			# fsm becomes legit
			set fg_fsm 0
		}

	} elseif { $fg_fsm == 0 } {

		set fg_fsm -1
	}
}

F {
###############################################################################
# after fsm ###################################################################
###############################################################################

	# this is unconditional; "F" is only used to extract the header
	set fstate "K"

	if { $PAR_IT != "k" } {
		xerror "fsm name expected"
		set fg_fsm -1
		continue
	}

	set fsm_name $tok

	set tok [ntoken]

	if { $PAR_IT != "d" || ( $tok != "\{" && $tok != "(" && $tok != ";" &&
	     $tok != ",") } {
		xerror "fsm declaration syntax error, (, \{, or ; expected"
		set fg_fsm -1
		continue
	}

	if { $tok == "," || $tok == ";" } {
		set ins "extern int"
		while 1 {
			append ins " $fsm_name (word, address)"
			if { $tok == ";" } {
				break
			}
			if { $tok != "," } {
				xerror "fsm announcement syntax error, comma or\
					; expected"
				break
			}
			append ins ", "
			set fsm_name [ntoken]
			if { $PAR_IT != "k" } {
				xerror "fsm announcement syntax error,\
					fsm name expected"
				break
			}
			set tok [ntoken]
		}
		append ins ";"
		truncate $fsm_mark
		putS $ins
		catchup
		set fstate "K"
		set fg_fsm 0
		continue
	}

	if { $tok == "(" } {
		# we have a strand, expect type followed by )
		set fsm_type [parse_type]
		if { $fsm_type == "" || $PAR_DEL != ")" } {
			xerror "strand fsm declaration syntax error,\
				invalid data type"
			set fg_fsm -1
			continue
		}
		set tok [ntoken]
		if { $PAR_IT != "d" || $tok != "\{" } {
			xerror "strand fsm declaration syntax error,\
				\} expected"
			set fg_fsm -1
			continue
		}
	} else {
		set fsm_type ""
	}

	# truncate the output to remove the fsm header (which has to be
	# fixed; we are now positioned past the opening brace of the thread's
	# function
	truncate $fsm_mark

	# initialize collectors for the sfm
	set sdlist ""	;# shared declarations
	set dflist ""	;# defines (states + shared declaration renames)
	set stlist ""	;# states
	set pslist ""	;# proceed states (for verification)
	set stinit ""	;# initial state
	set stappd 0 	;# flag == state command has appeared

	# just in case, the level must be 1 at this point
	set fsm_blev [brcnt]

	continue
}

I {
###############################################################################
# initial (within fsm) ########################################################
###############################################################################
	if { $PAR_IT != "k" || ($tok != "state" && $tok != "entry") } {
		# expecting a state
		xerror "initial state declaration error"
		set fstate "K"
	} else {
		set fstate "S"
	}
	continue
}

S {
###############################################################################
# state #######################################################################
###############################################################################
	if { $PAR_IT != "k" } {
		xerror "state name expected"
		set fstate "K"
		continue
	}
			
	if { [lsearch -exact $stlist $tok] >= 0 } {
		xerror "duplicate state name $tok"
		set fstate "K"
		continue
	}

	# we have a new state
	lappend stlist $tok

	if $fsm_ins {
		# initial
		if { $stinit != "" } {
			xerror "initial state already defined as $stinit"
			set fstate "K"
			continue
		}
		set stinit $tok
	}

	set fsm_sname $tok
	set fstate "T"

	continue
}

T {
###############################################################################
# state name delimiter ########################################################
###############################################################################
	set fstate "K"
	if { $PAR_IT != "d" || $tok != ":" } {
		xerror ": expected after state name"
	} else {
		truncate $fsm_smark
		catchup
		putS "case $fsm_sname :"
		set stappd 1
	}
	continue
}
				
P {
###############################################################################
# after proceed ###############################################################
###############################################################################
	set fsm_smark $PAR_MARK

	if { $PAR_IT == "k" } {
		# followed directly by state name, expect ;
		set fsm_ins 0
		set rep 1
		set fstate "Q"
		continue
	}

	if { $PAR_IT == "d" && $tok == "(" } {
		set fsm_ins 1
		# expect state name
		set fstate "Q"
		continue
	}

	xerror "proceed syntax error"
	set fstate "K"

	continue
}
				
Q {
###############################################################################
# after proceed (expecting state name) ########################################
###############################################################################
	set fstate "K"

	if { $PAR_IT != "k" } {
		xerror "state name expected"
		continue
	}

	set fsm_sname $tok
	set tok [ntoken]
	if { $PAR_IT != "d" } {
		xerror "delimiter expected after state name"
		continue
	}

	if $fsm_ins {
		# this must be a parenthesis (followed by a ;)
		if { $tok != ")" } {
			xerror ") expected after state name"
			continue
		}
		set tok [ntoken]
		if { $PAR_IT != "d" || $tok != ";" } {
			xerror "; expected after )"
			continue
		}
	} else {
		# just the semi
		if { $tok != ";" } {
			xerror "; expected after state name"
			continue
		}
	}

	truncate $fsm_smark
	putS "($fsm_sname);"

	continue
}
				default {
					errab \
					    "parse_picos: illegal state $fstate"
				}
	    		}
	  	}
	}
}
	
###############################################################################
###############################################################################

proc mkdrec { dname } {
#
# List all subdirectories of the indicated directory recursively in alphabetical
# order
#
	global MKRECV

	if [catch { exec ls $dname } sdl] {
		# doesn't exist
		return
	}

	set MKRECV($dname) ""
	
	foreach f $sdl {
		if [regexp -nocase "attic|junk" $f] {
			# ignore
			continue
		}
		if { $f == "CVS" || $f == "VUEE_TMP" || $f == "KTMP" } {
			# ignore as well
			continue
		}
		if [regexp "\\~\\$" $f] {
			# ignore exotic filenames (cause problems on Windows)
			continue
		}
		set f [file normalize [file join $dname $f]]
		if { $f == "" } {
			continue
		}
		if [info exists MKRECV($f)] {
			# avoid link loops
			continue
		}
		if [file isdirectory $f] {
			set MKRECV($f) ""
			mkdrec $f
		}
	}
}

proc finddir { name tail } {
#
# Try to find one of the extra include directoried, either from an evironment
# variable, or by searching upward
#
	global env

	set envar "${name}PATH"

	set dir ""
	if [info exists env($envar)] {
		set dir $env($envar)
		# check if present
		if { $dir != "" || ![file isdirectory $dir] } {
			puts "warning: environment variable $envar\
				is defined, but it does not point to a valid\
				directory"
			set dir ""
		}
	}

	if { $dir != "" } {
		return [file normalize [file join $dir $tail]]
	}

	# try searching from here up stopping at the first directory named
	# that contains name/tail

	set ftail [file join $name $tail]

	set tdi [pwd]
	set lst ""

	for { set i 0 } { $i < 32 } { incr i } {

		set tdi [file normalize "$tdi/.."]

		if { $tdi == $lst } {
			# at root
			break
		}

		set dir [file join $tdi $ftail]

		if [file isdirectory $dir] {
			return [file normalize $dir]
		}

		set lst $tdi
	}

	errab "cannot locate $name directory\
		(set ${name}PATH in the environment)"
}

proc findexec { name } {
#
# Find an executable
#
	global env

	if ![info exists env(PATH)] {
		set dirs { "/bin" "/usr/bin" "/usr/local/bin" }
	} else {
		set dirs [split $env(PATH) ":"]
	}

	foreach d $dirs {
		set p [file normalize [file join $d $name]]
		if [file executable $p] {
			return $p
		}
		append p ".exe"
		if [file executable $p] {
			return $p
		}
	}

	return ""
}

proc mkdlist { } {
#
# Create the list of local subdirectories to search for include files
#
	global MKRECV CWD DirList EDirList env

	mkdrec $CWD

	set DirList [lsort [array names MKRECV]]

	array unset MKRECV

	set vuee [finddir "VUEE" "PICOS"]
	set side [finddir "SIDE" "Examples/IncLib"]

	# check if the VUEE directory looks sane
	foreach fn { "board.cc" "tarp.h" "pins.h" } {
		set fn [file join $vuee $fn]
		if ![file isfile $fn] {
			errab "directory $vuee does not look complete; perhaps\
				mklinks is needed?"
		}
	}
	set EDirList [list $vuee $side]
}
	
proc fprerr { } {
	errab "app.c/app.cc cannot coexist with app_... files in the same\
		directory"
}

proc find_pgms { } {
#
# Find all programs in the current directory
#
	global CWD PG PgmList

	set PgmList ""

	if [catch { exec ls $CWD } flist] {
		errab "cannot scan current directory: $flist"
	}

	set empsuff 0

	foreach fn $flist {

		if { $fn == "app.c" || $fn == "app.cc" } {
			if { $PgmList != "" } {
				fprerr
			}
			set empsuff 1
			set pn ""
			lappend PgmList $pn
			set PG($pn,RF) $fn
			set PG($pn,NT) "Node"
			continue
		}

		if [regexp "^app_(\[a-zA-Z0-9\]+)\\.cc$" $fn jnk pn] {
			if $empsuff {
				fprerr
			}
			lappend PgmList $pn
			set PG($pn,RF) $fn
			set PG($pn,NT) "Node_$pn"
		}
	}

	if { $PgmList == "" } {
		errab\
		    "no app\[_...\] program file(s) found in current directory"
	}
}

proc verify_externals { } {
#
# Checks if externals (transformed to node attributes) are satisfied
#
	global PG Pgm

	foreach ex $PG($Pgm,EA) {

		if { [lsearch -exact $PG($Pgm,AN) [lindex $ex 0]] < 0 } {
			xerror \
			    "external symbol [lindex $ex 1] is never defined" \
				[lindex $ex 2]
		}
	}
}

proc vuee_out { str } {

	if ![regexp "^(.Compiling)\[ \t\]+(.*)" $str jnk cmp name] {
		return $str
	}

	if [regexp "^P_(.+)_zzz_(.*)_\[0-9\]*.cc" $name jnk froot prog] {
		set name ${froot}.cc
		if { $prog != "" } {
			append name " of $prog"
		}
	} elseif [regexp "^__vueehdr_(.*).h$" $name jnk prog] {
		set name "vuee header"
		if { $prog != "" } {
			append name " for $prog"
		}
	} elseif [regexp "^__vueeini_(.*).cc$" $name jnk prog] {
		set name "vuee initializer"
		if { $prog != "" } {
			append name " for $prog"
		}
	} elseif [regexp "^__vuee_root.cc" $name] {
		set name "vuee root"
	}

	return "$cmp $name"
}

proc compile_vuee { } {
#
# Run the VUEE compiler on preprocessed target
#
	global TDIR FG EXEC

	set cwd [pwd]

	if [catch { cd $TDIR } err] {
		cd $cwd
		return "cd'ing to $TDIR: $err"
	}

	puts "running vuee [join $FG(VA)]"

	set ef "__vuee_errors"

	catch { file delete -force $ef }

	set vnam "|[join [concat [list $EXEC(vuee)] $FG(VA)]] 2> $ef"
	if [catch { open $vnam "r" } vfd] {
		catch { file delete -force $ef }
		cd $cwd
		return "pipe: $vfd"
	}

	while 1 {
		if [catch { gets $vfd line } err] {
			catch { close $vfd }
			catch { file delete -force $ef }
			return "pipe: $err"
		}
		if { $err < 0 } {
			break
		}
		puts [vuee_out $line]
	}

	set efd ""
	if { ![catch { open $ef "r" } efd] && ![catch { read $efd } err] } {
		# errors?
		if { $err != "" } {
			puts stderr $err
		}
	}

	catch { close $efd }
	catch { file delete -force $ef }

	if [file exists "side"] {
		set ef "side"
	} elseif [file exists "side.exe"] {
		set ef "side.exe"
	} else {
		cd $cwd
		return "side image not created"
	}

	if [catch { file rename -force $ef [file join $cwd $ef] } err] {
		cd $cwd
		return $err
	}
	cd $cwd

	return ""
}

proc which_endian { } {
#
# We will learn this from vuee; Tcl8.4 doesn't know; Tcl8.5 is smarter
#
	global FG EXEC

	if [catch { exec $EXEC(vuee) -Q } res] {
		errab "cannot execute vuee: $res"
	}

	if { [string first "Lit" $res] >= 0 } {
		# little
		set FG(EN) 0
	} elseif { [string first "Big" $res] >= 0 } {
		# big
		set FG(EN) 1
	} else {
		puts "warning: cannot get endianness from vuee,\
			assumming 'little'"
		set FG(EN) 0
	}
}

proc parse_vuee { } {
#
# Compile all programs in current directory into VUEE
#
	global DirList Pgm PgmList CWD TDIR SFList FG EXEC ErrCnt

	# find the requisite executables
	foreach p { "vuee" "vue2" "vue" } {
		set e [findexec $p]
		if { $e != "" } {
			break
		}
	}

	if { $e == "" } {
		errab "cannot find vuee execuable (also tried vue2 and vue)"
	}
	set EXEC(vuee) $e

	set e [findexec "cpp"]
	if { $e == "" } {
		errab "cannot find cpp executable"
	}
	set EXEC(cpp) $e

	# determine machine endianness from vuee; we need this to set the
	# only (AFAIK) system-dependent symbol required by VUEE

	unset e

	which_endian

	set CWD [file normalize [pwd]]

	find_pgms

	mkdlist

	set TDIR [file join $CWD "VUEE_TMP"]

	file delete -force $TDIR

	if [catch { file mkdir $TDIR } err] {
		errab "cannot create tmp directory $TDIR, $err"
	}

	if ![file exists "options.sys"] {
		errab "vuee requires a global options.sys file in the praxis\
			directory"
	}

	if [catch { file copy -force "options.sys" $TDIR } err] {
		errab "cannot copy options.sys to $TDIR, $err"
	}

	foreach p $PgmList {

		set Pgm $p

		compile_pgm
		verify_externals
		emit_vhdr
		emit_vini
	}

	emit_glue

	if { $FG(C) && $ErrCnt == 0 } {
		set err [compile_vuee]
		if { $err != "" } {
			errab $err
		}
	}
}

proc setsymbols { dl } {
#
# Preset symbols for parsing files
#
	global Symbols

	array unset Symbols

	foreach d $dl {
		set v ""
		regexp "^(\[^=\]+)=(.*)" $d jnk d v
		set Symbols($d) $v
	}
}

proc compile_pgm { } {
#
# Compile one program
#
	global PG Pgm SFList ToCompile Processed NotFound TDIR EXEC FG

	# list of handled files
	set SFList ""

	# current program tag
	set pg $Pgm

	# queue of files to compile
	set ToCompile [file normalize [list $PG($pg,RF)]]

	# not found files that were explicitly requested to compile
	set NotFound ""

	# scratch file for cpp
	set SCF [file join $TDIR "__cpp_tmp.c"]

	if { $pg != "" } {
		puts "compiling $pg"
	}

	while { $ToCompile != "" } {
		set cfn [lindex $ToCompile 0]
		set ToCompile [lrange $ToCompile 1 end]
		if [info exists Processed($cfn)] {
			# already handled
			continue
		}
		set Processed($cfn) ""

		set exp { __SMURPH__ LITTLE_ENDIAN=0 BIG_ENDIAN=1 }

		if { $FG(EN) == 0 } {
			lappend exp "BYTE_ORDER=0"
		} else {
			lappend exp "BYTE_ORDER=1"
		}

		setsymbols $exp

		# note that the last line of prelude is empty, as it
		# should be
		set exp [scanfile $cfn 1 [split [emit_thrname] "\n"]]

		if { $exp != "" } {

			# we have to use a scratch file as cpp produces output
			# together with errors
			if [catch { exec $EXEC(cpp) << $exp > $SCF } res] {
				catch { file delete -force $SCF }
				unset exp
				puts stderr $res
				errab "compilation aborted"
			}

			unset exp

			if [catch {
				set exp [open $SCF "r"]
				set res [read $exp]
			} err] {
				errab "cannot read scratch file $SCF: $err"
				catch { close $exp }
				catch { file delete -force $SCF }
			}

			catch { close $exp }
			catch { file delete -force $SCF }
		}

		if { $res != "" } {
			# note: the target file names can be arbitrarily
			# changed, provided the line number sequencing works
			lappend SFList [list $cfn $res]
		}
	}

	if { $NotFound != "" } {
		set NotFound [join $NotFound ", "]
		pwarn "files not found: $NotFound"
	}

	array unset Processed

	set res ""

	# attribute list (declarations), must be global
	set PG($pg,AL) ""
	# attribute names (for easy detection of duplicates)
	set PG($pg,AN) ""
	# extern attribute list (for detecting the unsatisfied ones)
	set PG($pg,EA) ""
	# idiosyncratic functions
	set PG($pg,ID) ""
	# process list
	set PG($pg,PL) ""
	# process name list
	set PG($pg,PN) ""
	# type declarations
	set PG($pg,TD) ""
	# type name list (to prevent duplicates)
	set PG($pg,TN) ""

	set cnt 0
	foreach cfn $SFList {
		set froot [file rootname [file tail [lindex $cfn 0]]]
		parse_pfile $cnt [lindex $cfn 1]
		# write the file
		wtfile "P_${froot}_zzz[pnfx]_${cnt}.cc" [output]
		close_parser
		incr cnt
	}
}

proc wtfile { fn out } {
#
# Write a file to VUEE_TMP
#
	global TDIR

	set tf [file join $TDIR $fn]
	if [catch { open $tf "w" } fd] {
		errab "cannot open output file $tf, $fd"
	}
	if [catch { puts -nonewline $fd $out } err] {
		errab "cannot write to output file $tf, $err"
	}

	catch { close $fd }
}

proc swarn { m } {

	global FLine CFName

	puts "$CFName:$FLine (warning): $m"
}

proc pwarn { m } {

	global Pgm

	if { $Pgm != "" } {
		set m "program $Pgm, $m"
	}

	puts "warning: $m"
}

proc flook { fn prefdir dirs } {
#
# Lookup a given file:
#
# prefdir - preferred directory, i.e., the directory to be tried first (the one
#	    containing the includer)
#
# dirs    - the package directory list to search
#
	global CWD

	if { $prefdir != "" } {
		set dirs [concat [list $prefdir] $dirs]
	}

	set dir [file dirname $fn]

	if { $dir != "." && $dir != "" } {
		# the file name has a directory prefix
		set fil [file tail $fn]
		set dir [file normalize $dir]
		if { [string first $CWD $dir] != 0 } {
			# something wrong (this cannot happen)
			errab "cannot determine path for file $fn"
		}
		set cwdl [string length $CWD]
		# this is the normalized tail
		set dir [string range $dir $cwdl end]
		set dl [string length $dir]
		# now we are searching for a directory whose tail matches dir
		# and which contains $fn
		set ffn ""
		foreach d $dirs {
			set pos [string last $dir $d]
			if { $pos < 0 } {
				continue
			}
			if { [expr $pos + $dl] != [string length $d] } {
				continue
			}
			# we have a match on directory name
			set ff [file normalize [file join $d $fil]]
			if [file isfile $ff] {
				# check for a duplicate
				if { $ffn != "" && $ffn != $ff } {
					swarn "multiple occurrences of file $fn\
						 (at\ $ffn and $ff)"
					break
				} else {
					set ffn $ff
					set ddn [string range $d 0 \
						[expr $pos - 1]]
				}
			}
		}

		if { $ffn == "" } {
			# this is an error
			errab "cannot locate path-prefixed file $fn"
		}
		return $ffn
	}

	# a regular file
	set ffn ""
	foreach d $dirs {
		if { $dir == "" } {
			continue
		}
		set ff [file normalize [file join $d $fn]]
		if [file isfile $ff] {
			if { $ffn != "" && $ffn != $ff } {
				swarn "multiple occurrences of\
					file $fn (at $ffn and $ff)"
				break
			} else {
				set ffn $ff
			}
		}
	}

	return $ffn
}

proc needlist { ar fname } {
#
# Returns the list of files from "//+++". The argument is the piece of line
# past the +++ string.
#
	global DirList ToCompile NotFound

	set fl ""
	while 1 {
		set ar [string trim $ar]
		if { $ar == "" } {
			break
		}

		set d0 [string index $ar 0]
		if { $d0 == "\"" } {
			set d1 $d0
		} elseif { $d0 == "<" } {
			set d1 ">"
		} else {
			set d0 ""
			set d1 ""
		}

		set pat "$d0\[ \t\]*(\[^ \t$d1]+\\.(cc?|asm?))\[ \t\]*$d1"

		if ![regexp $pat $ar jk nfn] {
			# we don't understand this
			swarn "'//+++' syntax error: '$ar'"
			break
		}

		set cm [string first $jk $ar]

		if { $cm < 0 } {
			# impossible
			set ar ""
		} else {
			set ar [string range $ar [expr $cm + \
				[string length $jk]] end]
		}

		lappend fl $nfn
	}

	# add the files

	foreach nfn $fl {
		set dnn [file dirname $fname]
		set fn [flook $nfn $dnn $DirList]
		if { $fn == "" && [file extension $nfn] == ".c" } {
			# try ".cc"
			set fn [flook "[file rootname $nfn].cc" $dnn $DirList]
		}
		if { $fn == "" } {
			lappend_unique NotFound $nfn
		} else {
			lappend_unique ToCompile $fn
		}
	}
}

proc slineseq { } {
#
# Generate a line sequencing string for the currently expanded source file
# (before it becomes a parser source)
#
	global CFName FLine

	return [lnumseq [list $FLine $CFName]]
}

proc remcmnt { str } {
#
# Eliminate trailing comments from #if conditions and #defines
#
	set es [string first "//" $str]
	set ps [string first "/*" $str]
	set sl [string length $str]

	if { $es < 0 } {
		set es $sl
	}
	if { $ps < 0 } {
		set ps $sl
	}
	if { $es < $ps } {
		set ps $es
	}

	return [string trim [string range $str 0 [expr $ps - 1]]]
}

proc sexpr { str } {
#
# Evaluates naive IF conditions
#
	global Symbols

	# remove trailing comments
	set str [remcmnt $str]

	if { $str == "" } {
		return -1
	}

	regsub -all "\[ \t\]+" $str "" str

	set turn 0

	while { [regexp -nocase "^\[a-z_.\]\[a-z_0-9.\]*" $str mat] ||
		     [regexp -nocase "\[^a-z_0-9.\](\[a-z_.\]\[a-z_0-9.\]*)" \
			$str jk mat] } {

		# we have something looking like a bare keyword
		if ![info exists Symbols($mat)] {
			break
		}

		# substitute the definition and keep going
		set frm [string first $mat $str]
		set len [string length $mat]
		set nex [string range $str 0 [expr $frm - 1]]
		append nex $Symbols($mat)
		append nex [string range $str [expr $frm + $len] end]
		set str $nex
		incr turn
		if { $turn > 32 } {
			break
		}
	}

	if [catch { eval expr $str } val] {
		return -1
	}

	if $val {
		return 1
	}

	return 0
}

proc scanfile { fname inner { prelude "" } } {
#
# Expand a source file explicitly including whatever possible. If inner is 0,
# it means that the file is external, i.e., it belongs to VUEE (comes from
# VUEE/PICOS). In that case, we do not actually include the file contents, only
# go through its #ifs/#ifdefs, but also include #defines. Then, the entire file
# is run through cpp to expand the macros and eliminate the defines.
#
	global CFName FLine Symbols DirList EDirList FG

	set CFName $fname

	# line count
	set FLine 1

	if [catch { open $fname "r" } fd] {
		errab "cannot open file '$fname': $fd"
	}

	#
	# Note: this is different from mkmk in these respects:
	#
	# - we do not scan just for dependencies, but for contents (or partial
	#   contents, for the external files)
	# - multiple legitimate inclusions are OK
	# - we put line number sequences whenever an inclusion exits
	#

	set ifnest 0

	# assume that the entire file is encapsulated in a dummy if at level
	# zero, which is being totally ignored
	#
	# Flags:
	#
	#	0	- ignore, i.e., both parts should be scanned
	#	1	- accepting the current part
	#	2	- skipping the current part, waiting for else or endif
	#	3	- skipping both parts because the outer if is being
	#		  skipped
	#

	set ifstack($ifnest) "0"

	# the output
	set res [lnumseq [list 1 $CFName]]

	while 1 {

		if { $prelude == "" } {
			if { [gets $fd line] < 0 } {
				if { $ifnest > 0 } {
					swarn "#endif missing"
				}
				break
			}
			incr FLine
		} else {
			# prelude lines are never escaped, so this doesn't
			# interfere with subsequent gets; also, the prelude
			# stays at line 0
			set line [lindex $prelude 0]
			if { $line == "" } {
				# a prelude ends with an empty line
				set prelude ""
				set FLine 1
				append res "[slineseq]"
				continue
			}
			set prelude [lrange $prelude 1 end]
		}

		# handle //+++ requests, but only in internal files; such
		# requests will add files to be compiled in the program's set
		if { $ifstack($ifnest) <= 1 && $inner && \
		    [regexp "^\[ \t\]*//\\+\\+\\+(.*)" $line jk ar] } {
			# needed files
			needlist $ar $fname
			# output an empty line to maintain correct count
			append res "\n"
			continue
		}

		if ![regexp "^\[ \t\]*#" $line] {
			# nothing special, keep going, output if necessary
			if { $inner && $ifstack($ifnest) <= 1 } {
				append res "$line\n"
			}
			continue
		}

		# if we have multiple lines terminated with \, we have to merge
		# them together before interpreting the content
		set lc 1
		while { [regexp "(.*)\[\\\\\]\[ \t\]*$" $line jk newl] } {
			# check if the new line has even number of \'s at the
			# end
			if { [regexp "\[\\\\\]+$" $newl bc] &&
			     [expr [string length $bc] & 1] } {
				# this isn't an escape
				break;
			}
			# remove the escape sequence
			set line $newl
			if { [gets $fd newl] < 0 } {
				swarn "continuation line missing at file end"
				break
			}
			incr lc
			incr FLine
			append line $newl
		}

		if ![regexp "^\[ \t\]*#\[ \t\]*(\[a-z\]+)\[ \t\]*(.*)" \
		    $line jk cm ar] {
			# unrecognizable
			swarn "unrecognized pp sequence $line, ignored"
			if { $inner && $ifstack($ifnest) <= 1 } {
				while { $lc } {
					append res "\n"
					incr lc -1
				}
			}
			continue
		}

		if { $cm == "if" || $cm == "ifdef" || $cm == "ifndef" } {
			if { $ifstack($ifnest) > 1 } {
				# we are skipping an outer if, so we should
				# skip this one entirely
				incr ifnest
				set ifstack($ifnest) 3
				continue
			}
			# we have to evaluate this if
			incr ifnest
			if { $cm == "ifdef" || $cm == "ifndef" } {
				if ![regexp -nocase "^\[a-z_0-9.\]+" $ar nam] {
					# illegal
					swarn "illegal argument of #$cm,\
						assuming undefined"
					# treat as a undefined symbol
					if { $cm == "ifdef" } {
						set ifstack($ifnest) 2
					} else {
						set ifstack($ifnest) 1
					}
				} elseif [info exists Symbols($nam)] {
					if { $cm == "ifdef" } {
						set ifstack($ifnest) 1
					} else {
						set ifstack($ifnest) 2
					}
				} else {
					if { $cm == "ifdef" } {
						set ifstack($ifnest) 2
					} else {
						set ifstack($ifnest) 1
					}
				}
				continue
			}
			# if
			set val [sexpr $ar]
			if { $val < 0 } {
				swarn "cannot evaluate #if condition,\
						assuming zero"
				set val 0
			}
			if $val {
				set ifstack($ifnest) 1
			} else {
				set ifstack($ifnest) 2
			}
			continue
		}

		if { $cm == "else" } {

			if { $ifnest < 1 } {
			    swarn "extraneous #else, ignored"
			    continue
			}

			if { $ifstack($ifnest) == 1 } {
				# start skipping, including the #else
				set ifstack($ifnest) 2
			} elseif { $ifstack($ifnest) == 2 } {
				# start accepting, but without the else; issue
				# line sequence + one empty line (for the else)
				append res "[slineseq]\n"
				set ifstack($ifnest) 1
			} elseif { $ifstack($ifnest) == 0 } {
				# impossible
				swarn "stray #else"
			}
				
			continue
		}

		if { $cm == "endif" } {
			if { $ifnest > 0 } {
				set s $ifstack($ifnest)
				incr ifnest -1
				if { $s == 0 } {
					# impossible
					swarn "stray #endif"
				} elseif { $s == 1 } {
					# ignore #endif, but maintain correct
					# line count
					while { $lc } {
						append res "\n"
						incr lc -1
					}
				} else {
					# skipping (this part or both)
					if { $ifstack($ifnest) <= 1 } {
						append res "[slineseq]\n"
					}
				}
			} else {
			    	swarn "extraneous #endif, ignored"
				continue
			}
			continue
		}

		if { $ifstack($ifnest) > 1 } {
			continue
		}

		if { $cm == "define" } {
			append res "$line\n"
			incr lc -1
			while { $lc } {
				append res "\n"
				incr lc -1
			}

			set ar [remcmnt $ar]

			set nam ""
			if ![regexp -nocase "^(\[a-z_0-9.\]+)(\[ \t\]+(.*))?" \
			    $ar jk kwd jk nam] {
				swarn "#define syntax error"
				continue
			}

			set Symbols($kwd) $nam
			continue
		}

		if { $cm == "undef" } {

			if ![regexp -nocase "^\[a-z_0-9.\]+" $ar kwd] {
				swarn "#undef syntax error, ignored"
				while { $lc } {
					append res "\n"
					incr lc -1
				}
				continue
			}

			append res "$line\n"
			incr lc -1
			while { $lc } {
				append res "\n"
				incr lc -1
			}

			if [info exists Symbols($kwd)] {
				unset Symbols($kwd)
			}
			continue
		}

		if { $cm == "include" } {
			if ![regexp -nocase "\[\"<\](\[^\"><\]+)\[\">\]" $ar \
			    jk fn] {
				# the file name to include may be a symbol
				if ![regexp -nocase "^\[ \t\]*(\[a-z_0-9.\]+)" \
				    $ar jk fn] {
					# unrecognizable
					swarn "unrecognizable #include\
						argument, ignored"
					while { $lc } {
						append res "\n"
						incr lc -1
					}
					continue
				}
				# try the symbol
				if ![info exists Symbols($fn)] {
					append res "$line\n"
					swarn "unrecognizable #include syntax"
					while { $lc } {
						append res "\n"
						incr lc -1
					}
					continue
				}
				set fn [string trim $Symbols($fn) "\"<>"]
			}
			set fn [string trim $fn]
			if { $fn == "" } {
				continue
			}
			# look it up locally
			set fm [flook $fn "" $DirList]
			if { $fm == "" } {
				set fm [flook $fn "" $EDirList]
				if { $fm == "" } {
					swarn "included file $fn not found"
					while { $lc } {
						append res "\n"
						incr lc -1
					}
					continue
				}
				set fn 0
			} else {
				set fn 1
			}
			set jk $CFName
			set ar $FLine
			append res [scanfile $fm $fn]
			set CFName $jk
			set FLine $ar
			append res "[slineseq]"
			continue
		}
	}
	catch { close $fd }
	return $res
}

proc pnfx { } {
#
# Pgm name pre/suffix
#
	global Pgm

	if { $Pgm == "" } {
		return ""
	}

	return "_$Pgm"
}

proc emit_create { pname { arg "" } } {
#
# Generate a sequence for creating a SMURPH process
#
	set ins "(TheNode->tally_in_pcs()?(create $pname"
	if { $arg != "" } {
		append ins "($arg)"
	}
	append ins ")->_pp_apid_():0)"

	return $ins
}

proc emit_thrname { } {
#
	global Pgm

	set res "#ifndef THREADNAME\n#define THREADNAME(a) a"
	if { $Pgm != "" } {
		append res " ## [pnfx]"
	}
	append res "\n#endif\n"
	return $res
}

proc emit_glue { } {
#
# Create the "glue" file (SMURPH Root) for the praxis - one for the whole set
#
	global PG PgmList Pgm

	set fn "__vuee_root.cc"

	set res "#include \"sysio.h\"\n"
	append res "#include \"board.h\"\n"
	append res "#include \"board.cc\"\n"

	foreach Pgm $PgmList {
		append res "void __build_[pnfx]node (data_no_t*);\n"
	}

	append res "process Root : BoardRoot \{\n"
	append res "void buildNode (const char *tp, data_no_t *nddata) \{\n"

	set np [llength $PgmList]

	for { set ix 0 } { $ix < $np } { incr ix } {
		set Pgm [lindex $PgmList $ix]
		if { $ix > 0 } {
			append res "else "
		}
		if { $ix != [expr $np - 1] } {
			append res "if (strcmp (tp, \"$Pgm\") == 0) "
		}
		append res "__build_[pnfx]node (nddata); "
	}

	append res "\n\};\n\}\;\n"

	wtfile $fn $res
}
	
proc emit_vini { } {
#
# Create __vueeini...h
#
	global PG Pgm

	set fn "__vueeini[pnfx].cc"
	set fh "__vueehdr[pnfx].h"

	set res "#include \"$fh\"\nvoid __NT[pnfx]::init () \{\n"

	# code to pre-zero-out attributes
	append res "memset (__attr_init_origin, 0, "
	append res "__attr_init_end - __attr_init_origin);\n"

	# and the proper initializers
	foreach d $PG($Pgm,AL) {
		set ini [outinit $d]
		if { $ini != "" } {
			append res $ini
		}
	}

	append res "__praxis_starter ();\n\}\n"

	append res "void __build_[pnfx]node (data_no_t *nddata) \{ "
	append res "create __NT[pnfx] (nddata); \}\n"

	wtfile $fn $res
}

proc emit_vhdr { } {
#
# Create __vueehdr...h
#
	global PG Pgm

	set fn "__vueehdr[pnfx].h"
	set ta "__vueehdr[pnfx]_h"

	set res "#ifndef $ta\n[emit_thrname]#include \"board.h\"\n"

	foreach d $PG($Pgm,TD) {
		# type declarations
		append res "[lnumseq [lindex $d 2]][outdecl $d 0]\n"
	}

	append res "\station __NT[pnfx] : PicOSNode \{ \n"

	# attributes

	append res "char __attr_init_origin \[0\];\n"

	foreach d $PG($Pgm,AL) {

		append res "[lnumseq [lindex $d 2]][outdecl $d 0]\n"
	}

	append res "char __attr_init_end \[0\];\n"

	append res "void __praxis_starter ();\n"
	append res "void reset () \{ PicOSNode::reset (); \};\n"
	append res "void init (); \n\};\n"

	append res "#include \"stdattr.h\"\n"

	# fsm's

	foreach d $PG($Pgm,PL) {

		set nam [lindex $d 0]
		set stl [lindex $d 1]
		set dty [lindex $d 2]

		append res "process $nam : _PP_ (__NT[pnfx]) \{\n"
		append res "states \{ "
		append res [join $stl ","]
		append res " \};\n"

		if { $dty != "" } {
			append res "$dty *data;\nvoid setup ($dty *d) \{ "
			append res "data = d; \};\n"
		}

		append res "perform;\n\};\n"
	}

	append res "#endif\n"

	wtfile $fn $res
}

proc parse_pfile { cnt src } {
#
# Compile one source file into a VUEE-compilable format
#
	global PG Pgm PAR_IT PAR_MARK PAR_DEL

	initialize_parser $src

	putS "#include \"__vueehdr[pnfx].h\"\n"

	set fstate "K"
	set fg_fsm 0
	set rootp 0

	while 1 {

		set tok [ntoken]
		set bra [brcnt]
		set rep 1

		if { $bra < 0 } {
			xerror "too many closing brackets"
			break
		}

		if { $PAR_IT == "f" } {
			xsterr
		}

	  	if { $PAR_IT == "e" } {
			if $bra {
				xsterr $bra
			}
			break
	  	} 

	  	while { $rep } {

	    		# the inner loop; set rep to redo
	    		set rep 0

	    		switch $fstate {
K {
###############################################################################
# keyword distributor #########################################################
###############################################################################
  if { $PAR_IT == "k" } {

    if { $bra == 0 } {

      # level 0, be on a lookout for:
      # - fsm's
      # - declarations

      if { $fg_fsm == 0 && $tok == "fsm" } {
	set fg_fsm 1
	set fsm_mark $PAR_MARK
	set fstate "F"
	continue
      }

      # try a declaration
      set d [parse_decl $tok]

      if { $d == "" } {
	continue
      }

      set pfx [lindex $d 0]
      set dtp [lindex $d 3]

      if { [lsearch -exact $pfx "shared"] >= 0 } {
	xerror "shared illegal in global scope"
	continue
      }

      # more sanity checks?

      set ins [lsearch -exact $pfx "idiosyncratic"]

      #########################################################################
      # handle a function declaration or announcement #########################
      #########################################################################
      if { $dtp == "A" || $dtp == "F" } {

	if { $ins >= 0 } {

	  # remove the original declaration
	  truncate $PAR_MARK

	  if { $dtp == "A" } {
	    # function announcement
	    set vrs [lindex $d 1]

	    set ins "\n"

	    foreach v $vrs {

	      # original name
	      set vnm [lindex $v 1]

	      # mangled (method) name
	      set nnm "_na_$vnm"
	      append ins "#ifndef $vnm\n#define $vnm (((__NT[pnfx]*)"
	      append ins "TheStation)->$nnm)\n#endif\n"
	      lappend_unique PG($Pgm,ID) [list $nnm $vnm [lindex $d 2]]
	    }

	    insert $PAR_MARK $ins
	    catchup

	    continue
	  }

	  # function declaration
	  set pfx [lreplace $pfx $ins $ins]

	  set ins " "
	  foreach w $pfx {
	    append ins "$w "
	  }

	  set vrs [lindex $d 1]
	  # there is just a single "variable"
	  set v [lindex $vrs 0]
	  set vnm [lindex $v 1]
	  set vnt [lindex $v 2]
	  set nnm "_na_$vnm"

	  append ins "__NT[pnfx]::$nnm $vnt \{"

	  insert $PAR_MARK $ins
	  catchup

	  if { [lsearch -exact $PG($Pgm,AN) $nnm] >= 0 } {
	    xerror "idiosyncratic function $vnm declared more than once"
	  } else {
	    set v [lreplace $v 1 1 $nnm]
	    # include the original name as fifth item
	    lappend v $vnm
	    lappend PG($Pgm,AN) $nnm
	    lappend PG($Pgm,AL) [lreplace $d 0 1 $pfx [list $v]]
	  }

	  continue
	}

	# not idiosyncratic, stays put
	continue
      }

      if { $ins >= 0 } {
	xerror "only functions can be idiosyncratic"
	continue
      }

      # the declaration will be removed (at least ignored)
      truncate $PAR_MARK

      if { $dtp == "T" } {
	# this is a type declaration; save for the headers
	set ins [lindex $d 1]
	if { [lsearch -exact $PG($Pgm,TN) $ins] < 0 } {
	  lappend PG($Pgm,TD) $d
	  lappend PG($Pgm,TN) $ins
	}
	continue
      }

      #########################################################################
      # trueconst #############################################################
      #########################################################################
      set ins [lsearch -exact $pfx "trueconst"]
      if { $ins >= 0 } {
	# this is left alone, with truconst replaced by const
	set pfx [lreplace $pfx $ins $ins "const"]
	putS [outdecl [lreplace $d 0 0 $pfx]]
	catchup
	continue
      }

      #########################################################################
      # handle externs ########################################################
      #########################################################################
      set ins [lsearch -exact $pfx "extern"]
      if { $ins >= 0 } {
	# externs are transformed into macros and saved for verification

	set ins [lsearch -exact $pfx "static"]
	if { $ins >= 0 } {
	  xerror "extern cannot be static"
	  continue
	}

	set vrs [lindex $d 1]
	set ins "\n"
	foreach v $vrs {
	  if [isfundec $v] {
	    # ignore function announcements altogether
	    continue
	  }
	  set vnm [lindex $v 1]
	  set nnm "__vattr_$vnm"
	  append ins "#ifndef $vnm\n#define $vnm (((__NT[pnfx]*)"
	  append ins "TheStation)->$nnm)\n#endif\n"
	  lappend_unique PG($Pgm,EA) [list $nnm $vnm [lindex $d 2]]
	}

	putS $ins
	catchup
	continue
      }

      #########################################################################
      # handle regular declarations ###########################################
      #########################################################################
      set ins [lsearch -exact $pfx "const"]
      if { $ins >= 0 } {
	# turn const to var for now; we may want to do something about them
	# later
	set pfx [lreplace $pfx $ins $ins]
      }

      set suf "__vattr_"

      set ins [lsearch -exact $pfx "static"]
      if { $ins >= 0 } {
	# static is additionally mangled with the file-specific counter
	append suf "${cnt}_"
	set pfx [lreplace $pfx $ins $ins]
      }

      if { [llength $pfx] == 0 } {
	# check the prefix after all this trimming
	xerror "missing type in declaration"
	continue
      }

      set vrs [lindex $d 1]
      set ors ""
      # insert
      set ins "\n"

      # rename the variables
      foreach v $vrs {

	if [isfundec $v] {
	  # ignore function announcements
	  continue
	}

	set vnm [lindex $v 1]
	set nnm "${suf}${vnm}"
	if { [lsearch -exact $PG($Pgm,AN) $nnm] >= 0 } {
	  xerror "variable $vnm declared (globally) more than once"
	  continue
	}

	# don't use #ifdef here, may help discover some potential errors
	append ins "#define $vnm (((__NT[pnfx]*)"
	append ins "TheStation)->$nnm)\n"

	set v [lreplace $v 1 1 $nnm]
	# include the original variable name as a fifth item in the new list
	lappend v $vnm
	# update global list of names
	lappend PG($Pgm,AN) $nnm
	lappend ors $v
      }

      # has been verified for duplicates
      lappend PG($Pgm,AL) [lreplace $d 0 1 $pfx $ors]

      # insert the defines
      insert $PAR_MARK $ins
      catchup
      continue
    }

    ###########################################################################
    # we are nested (bra > 0) #################################################
    ###########################################################################

    if { $tok == "runfsm" } {

      set run_mark $PAR_MARK

      set tok [ntoken]
      if { $PAR_IT != "k" } {
	xerror "fsm name expected after runfsm"
	continue
      }

      set fsm_sname $tok[pnfx]

      set tok [ntoken]
      # expected ( or some other delimiter, not necessarily ;
      if { $PAR_IT != "d" } {
	xerror "runfsm syntax error, delimiter expected after sfm name"
	continue
      }

      if { $tok == "(" } {
	set arg [parse_arg]
	if { $PAR_DEL == "" } {
	  # error (diagnosed by parse_arg)
	  continue
	}
	# looking at the delimiter following the closing )
	set tok [ntoken]
      } else {
	set arg ""
      }

      truncate $run_mark
      putS "[emit_create $fsm_sname $arg]$tok"

      continue
    }

    # other non-declaration keywords? later we may want to get rid of the
    # macros in sysio.h

    ###########################################################################
    # handling fsm code #######################################################
    ###########################################################################

    if { $fg_fsm <= 0 } {
      set fg_fsm -1
      # illegal after keyword
      continue
    }

    ###########################################################################
    # within fsm, declarations allowed ########################################
    ###########################################################################
    if { $fg_fsm == 1 } {

      # this means that we are within an fsm and declarations are still legal

      if { $bra != $fsm_blev || $tok == "state" || $tok == "entry" ||
	$tok == "initial" } {
	# not any more; any of these renders declarations illegal
	set fg_fsm 2
	# have to redo the keyword
	set rep 1
	continue
      }

      # try the declaration
      set d [parse_decl $tok]
      set dtp [lindex $d 3]

      if { $d == "" } {
	# no more declarations; note that the first keyword has been swallowed
	set fg_fsm 2
	continue
      }

      if { $dtp != "V" } {
	xerror "only variables can be declared within an fsm"
      }

      set pfx [lindex $d 0]

      # just in case
      if { [lsearch -exact $pfx "idiosyncratic"] >= 0 } {
	xerror "variables cannot be idiosyncratic"
	continue
      }

      if { [lindex $pfx 0] != "shared" } {
	# we leave it alone; should we allow the keyword further down the list?
	continue
      }

      # a shared declaration
      set pfx [lreplace $pfx 0 0]
      if { [llength $pfx] == 0 } {
	xerror "type missing in shared declaration"
      }

      # variable list
      set vrs [lindex $d 1]
      set ors ""
      # copy the variable list mangling the variables
      foreach v $vrs {
	set vnm [lindex $v 1]
	set nnm "__vattr_${fsm_name}_$vnm"
	if { [lsearch -exact $PG($Pgm,AN) $nnm] >= 0 } {
	  xerror "shared variable $vnm conflicts (globally) with another\
		variable"
	  continue
	}
	# defines
	set ins "(((__NT[pnfx]*)TheStation)->$nnm)"
	lappend PS($Pgm,AN) $nnm
	lappend dflist [list $vnm $ins]
	set v [lreplace $v 1 1 $nnm]
	lappend ors $v
      }

      lappend PG($Pgm,AL) [lreplace $d 0 1 $pfx $ors]
      # remove the original declaration
      truncate $PAR_MARK
      continue
    }

    ###########################################################################
    # within fsm, no more declarations ########################################
    ###########################################################################
    if { $fg_fsm > 0 } {

      if { $bra == $fsm_blev && ($tok == "state" || $tok == "entry" ||
	   $tok == "initial") } {
	# state, including "initial"
	set fsm_smark $PAR_MARK
	if { $tok == "initial" } {
	  set fstate "I"
	  set fsm_ins 1
	} else {
	  set fstate "S"
	  set fsm_ins 0
	}
	continue
      }

      # note: there's no need to handle proceed

    } else {

    ###########################################################################
    # keyword outside fsm #####################################################
    ###########################################################################

      set fg_fsm -1
    }

    continue
  }

  #############################################################################
  # not a keyword in ground state #############################################
  #############################################################################

  if { $PAR_IT != "d" } {
    # and not a delimiter
    continue
  }

  #############################################################################
  # delimiter in ground state #################################################
  #############################################################################

  if { $fg_fsm > 0 } {

    # within fsm; looking for the closing brace
    if { $tok != "\}" || $bra >= $fsm_blev } {
      # nothing special, keep going
      continue
    }

    ###########################################################################
    # closing the fsm #########################################################
    ###########################################################################

    # the name is mangled with program name
    set fsn "$fsm_name[pnfx]"

    foreach st $pslist {
      # verify proceed states
      if { [lsearch -exact $stlist $st] < 0 } {
	xerror "state $st used in proceed not defined in fsm"
      }
    }

    if { $stinit != "" } {
      # an explicit initial state, must get number zero
      set st [lsearch -exact $stlist $stinit]
      if { $st < 0 } {
	# impossible
	set st 0
      }
      # move it to front
      set stlist [linsert [lreplace $stlist $st $st] 0 $stinit]
    }

    set ins "\n[lnumseq [olinenum $fsm_mark]]"
    # defines for shared variables
    foreach d $dflist {
      append ins "\n#define [lindex $d 0] [lindex $d 1]"
    }
    append ins "\n"

    # the code method
    append ins "${fsn}::perform \{\n"

    insert $fsm_mark $ins

    if { $dflist != "" } {
      putS "\n"
      foreach d $dflist {
	putS "#undef [lindex $d 0]\n"
      }
      catchup
    }

    set fg_fsm 0

    if { [lsearch -exact $PG($Pgm,PN) $fsm_name] >= 0 } {
      xerror "fsm $fsm_name defined more than once"
    } else {
      lappend PG($Pgm,PN) $fsm_name
    }

    if { $fsm_name == "root" } {
      # flag == need the starter
      set rootp 1
    }

    # process description
    lappend PG($Pgm,PL) [list $fsn $stlist $fsm_type]
    continue
  }

  #############################################################################
  # other delimiters ##########################################################
  #############################################################################
  if { $bra == 0 && ($tok == "\}" || $tok == ";") } {

    if { $fg_fsm == -1 } {
      # fsm becomes legit
      set fg_fsm 0
    }

  } elseif { $fg_fsm == 0 } {

    set fg_fsm -1
  }
}

F {
###############################################################################
# after fsm ###################################################################
###############################################################################

	set fstate "K"

	if { $PAR_IT != "k" } {
		xerror "fsm name expected"
		set fg_fsm -1
		continue
	}

	set fsm_name $tok

	set tok [ntoken]

	if { $PAR_IT != "d" || ( $tok != "\{" && $tok != "(" && $tok != "," &&
	     $tok != ";" ) } {
		xerror "fsm declaration syntax error, ( or \{ expected"
		set fg_fsm -1
		continue
	}

	if { $tok == "," || $tok == ";" } {
		# announcement - skip to ";" while doing some rudimentary
		# verification
		set fg_fsm 0
		set fstate "K"
		while 1 {
			if { $PAR_IT == "d" } {
				if { $tok == ";" } {
					break
				}
				if { $tok != "," } {
					set fg_fsm -1
					xerror "illegal fsm announcement"
					break
				}
			}
			set tok [ntoken]
		}

		truncate $fsm_mark
		catchup
		continue
	}

	if { $tok == "(" } {
		# we have a strand, expect type followed by )
		set fsm_type [parse_type]
		if { $fsm_type == "" || $PAR_DEL != ")" } {
			xerror "strand fsm declaration syntax error,\
				invalid data type"
			set fg_fsm -1
			continue
		}
		set tok [ntoken]
		if { $PAR_IT != "d" || $tok != "\{" } {
			xerror "strand fsm declaration syntax error,\
				\} expected"
			set fg_fsm -1
			continue
		}
	} else {
		set fsm_type ""
	}

	# truncate the output to remove the fsm header (which has to be
	# fixed; we are now positioned past the opening brace of the thread's
	# function
	truncate $fsm_mark

	# initialize collectors for the sfm
	set dflist ""	;# defines (shared declaration renames)
	set stlist ""	;# states
	set pslist ""	;# proceed states (for verification)
	set stinit ""	;# initial state

	# just in case, the level must be 1 at this point
	set fsm_blev [brcnt]

	continue
}

I {
###############################################################################
# initial (within fsm) ########################################################
###############################################################################
	if { $PAR_IT != "k" || ($tok != "state" && $tok != "entry") } {
		# expecting a state
		xerror "initial state declaration error"
		set fstate "K"
	} else {
		set fstate "S"
	}
	continue
}

S {
###############################################################################
# state #######################################################################
###############################################################################
	if { $PAR_IT != "k" } {
		xerror "state name expected"
		set fstate "K"
		continue
	}
			
	if { [lsearch -exact $stlist $tok] >= 0 } {
		xerror "duplicate state name $tok"
		set fstate "K"
		continue
	}

	# we have a new state
	lappend stlist $tok

	if $fsm_ins {
		# initial
		if { $stinit != "" } {
			xerror "initial state already defined as $stinit"
			set fstate "K"
			continue
		}
		set stinit $tok
	}

	set fsm_sname $tok
	set fstate "T"

	continue
}

T {
###############################################################################
# state name delimiter ########################################################
###############################################################################
	set fstate "K"
	if { $PAR_IT != "d" || $tok != ":" } {
		xerror ": expected after state name"
	} else {
		truncate $fsm_smark
		catchup
		putS "transient ${fsm_sname}:"
	}
	continue
}
				default {
					errab \
					    "parse_vuee: illegal state $fstate"
				}
	    		}
	  	}
	}

	if $rootp {
		# the file contains the root process: add the starter
		putS "\nvoid __NT[pnfx]::__praxis_starter () \{ "
		putS [emit_create root[pnfx]]
		putS "; \}\n"
	}
}
	
###############################################################################
###############################################################################

proc usage { } {

	global argv0

	puts stderr "Usage: $argv0 [-p|-v] [-n]"
	exit 99
}

# default mode == vuee compiler
set FG(V) 1

# default flag == compile unless errors
set FG(C) 1

#arguments for VUEE
set FG(VA) ""

set an 0

foreach arg $argv {

	incr an

	if { $arg == "-p" } {
		set FG(V) 0
	} elseif { $arg == "-v" } {
		set FG(V) 1
	} elseif { $arg == "-n" } {
		set FG(C) 0
	} elseif { $arg == "--" } {
		# arguments for the vuee compiler
		if !$FG(V) {
			errab "-- ... illegal with PicOS mode (-p)"
		}
		set FG(VA) [lrange $argv $an end]
		break
	} else {
		usage
	}
}

set ErrCnt 0

if $FG(V) {

	puts "PiComp version $Version"
	parse_vuee

} else {

	# PicOS compiler

	if [catch { read stdin } src] {

		errab "cannot read input: $src"

	}

	parse_picos $src
	unset src

	puts -nonewline [output]

	if $PS(ERC) {

		exit 99
	}

}

exit 0
